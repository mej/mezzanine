#!/usr/bin/perl -w
#
# buildtool -- Product Build Management Tool
# 
# Copyright (C) 2000, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: buildtool,v 1.21 2000/05/21 21:46:14 mej Exp $
#

# Include the Perl Modules we need
use POSIX;
use Getopt::Mixed;

# Constants
#
# Keep these in sync with the ones in revtool, or
# talk perl into using headers and #define's.
#
# 1-20 are generic errors
sub REVTOOL_NO_SERVER()           {1;}
sub REVTOOL_SERVER_CRASH()        {2;}
sub REVTOOL_BAD_LOGIN()           {3;}
sub REVTOOL_COMMAND_FAILED()      {4;}
sub REVTOOL_ACCESS_DENIED()       {5;}

# 21-40 are retrieval/update errors
sub REVTOOL_FILE_NOT_FOUND()      {21;}
sub REVTOOL_FILE_REMOVED()        {22;}
sub REVTOOL_CONFLICT_FOUND()      {23;}
sub REVTOOL_INVALID_TAG()         {24;}

# 41-60 are add/remove errors
sub REVTOOL_BAD_ADDITION()        {41;}
sub REVTOOL_BAD_REMOVAL()         {42;}

# 61-80 are commit errors
sub REVTOOL_NEED_UPDATE()         {61;}

# 127 is a catch-all
sub REVTOOL_UNSPECIFIED_ERROR()   {127;}

# Print usage information
sub
print_usage_info
{
    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   buildtool [ options ]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -b --build [stage]               Stop building after a particular stage (see below)\n";
    print "    -p --product --package [name]    Specify the product or package to build\n";
    print "    -q --quiet                       Be somewhat quiet.  Simply gives basic progress info\n";
    print "    -Q --really-quiet --silent       Be very quiet.  Only errors are reported\n";
    print "    -D --dir [directory]             Specify \"directory\" as the location of your .prod files\n";
    print "    -f --force                       Ignore errors, build as much as possible\n";
    print "\n";
    exit(0);
}

# Generate timestamp for debugging/log file
sub
get_timestamp
{
    $ts = POSIX::strftime("%A, %d %B %Y %H:%M:%S %Z", localtime);
    return $ts;
}

# Report a fatal error
sub
fatal_error
{
    my $msg = $_[0];

    print STDERR $msg;
    print $GLOBAL_LOG $msg if ($GLOBAL_LOG);
    exit(-1);
}

# Debugging output
sub
dprintf
{
    return if (! $debug);
    print "[debug:$progname] ";
    printf @_;
    if ($GLOBAL_LOG) {
        print $GLOBAL_LOG "[debug:$progname] ";
        printf $GLOBAL_LOG @_;
    }
}
sub
dprint
{
    return if (! $debug);
    print "[debug:$progname] ", @_;
    if ($GLOBAL_LOG) {
        print $GLOBAL_LOG "[debug:$progname] ", @_;
    }
}

# Print an error
sub
eprintf
{
    print "$progname:  Error:  ";
    printf @_;
    if ($GLOBAL_LOG) {
        print $GLOBAL_LOG "$progname:  Error:  ";
        printf $GLOBAL_LOG @_;
    }
}
sub
eprint
{
    print "$progname:  Error:  ", @_;
    if ($GLOBAL_LOG) {
        print $GLOBAL_LOG "$progname:  Error:  ", @_;
    }
}

# Normal print (i.e., don't print this in -q or -Q mode)
sub
nprintf
{
    return if ($verbosity < 2);
    printf @_;
    if ($GLOBAL_LOG) {
        printf $GLOBAL_LOG @_;
    }
}
sub
nprint
{
    return if ($verbosity < 2);
    print @_;
    if ($GLOBAL_LOG) {
        print $GLOBAL_LOG @_;
    }
}

# Quiet print (i.e., print in -q mode but not in -Q mode)
sub
qprintf
{
    return if ($verbosity < 1);
    printf @_;
    if ($GLOBAL_LOG) {
        printf $GLOBAL_LOG @_;
    }
}
sub
qprint
{
    return if ($verbosity < 1);
    print @_;
    if ($GLOBAL_LOG) {
        print $GLOBAL_LOG @_;
    }
}

# Make a directory hierarchy
sub
mkdirhier
{
    my $dir = $_[0];
    my @dirs = split("/", $dir);
    my $path = "";

    foreach $dir (@dirs) {
        $path .= "$dir/";
        dprint "mkdirhier() checking for \"$path\"\n";
        if (! -d $path) {
            dprint "mkdirhier() creating \"$path\"\n";
            mkdir($path, 0755) || eprint("Unable to create $path -- $!\n");
        }
    }
    dprint "Something went wrong in mkdirhier()!\n" if (! -d $_[0]);
}

# Translate abbreviated variable names into their canonical forms
sub
get_var_name
{
    my $var = $_[0];

    $var =~ tr/[a-z]/[A-Z]/;

    # Commonly shortened variables are REVISION/TAG,
    # VERSION, DATE, CVSROOT, SPECFILE, DIRS
    if ($var =~ /^REV/ || $var =~ /^TAG/) {
        $var = "REVISION";
    } elsif ($var =~ /^REL/) {
        $var = "RELEASE";
    } elsif ($var =~ /^VER/) {
        $var = "VERSION";
    } elsif ($var =~ /^SPEC/) {
        $var = "SPECFILE";
    } elsif ($var =~ /^DIR/) {
        $var = "DIRS";
    } elsif ($var =~ /^LOC/) {
        $var = "LOCATIONS";
    }
    return $var;
}

# Locate the product file for a particular product
sub
find_product_file
{
    my ($prodname, $prodver) = @_;
    my $prod = "$prodname-$prodver";
    my $prodfile;
    my @contents;
    local *PRODFILE;

    dprint "find_product_file($prodname, $prodver)\n";
    if ($prodver) {
        # If it already has the .prod extension, and it exists, return that
        if ($prod =~ /\.prod$/) {
            if (-f $prod) {
                return $prod;
            } elsif (-f "$proddir/$prod") {
                # Just needed a path
                return "$proddir/$prod";
            } else {
                $prod =~ s/\.prod$//;
            }
        } else {
            # It has no .prod extension.  Let's try just giving it one.
            if (-f "$prod.prod") {
                return "$prod.prod";
            } elsif (-f "$proddir/$prod.prod") {
                # Extension and path needed...
                return "$proddir/$prod.prod";
            }
        }
    }

    # Try just the product name
    if ($prodname =~ /\.prod$/) {
        if (-f $prodname) {
            return $prodname;
        } elsif (-f "$proddir/$prodname") {
            # Just needed a path
            return "$proddir/$prodname";
        } else {
            $prodname =~ s/\.prod$//;
        }
    } else {
        # It has no .prod extension.  Let's try just giving it one.
        if (-f "$prodname.prod") {
            return "$prodname.prod";
        } elsif (-f "$proddir/$prodname.prod") {
            # Extension and path needed...
            return "$proddir/$prodname.prod";
        }
    }

    # Well, rats.  We've eliminated the simple cases.  Time to get creative.
    # Find all the product files and search for one that matches
    opendir(DIR, "$proddir");
    @contents = sort(grep($_ =~ /\.prod$/, readdir(DIR)));
    closedir(DIR);
    foreach $prodfile (@contents) {
        my (@lines, @names, @versions);

        dprint "find_product_file():  Searching product file $prodfile for a match...\n";
        open(PRODFILE, "$proddir/$prodfile") || next;
        @lines = <PRODFILE>;
        @names = grep($_ =~ /^\s*name\s*:/i, @lines);
        @versions = grep($_ =~ /^\s*ver(sion)?\s*:/i, @lines);
        if (grep($_ =~ /$prodname/, @names) && grep($_ =~ /$prodver/, @versions)) {
            # Found it.
            dprint "find_product_file():  Match found!\n";
            return "$proddir/$prodfile";
        }
    }
    # Give up.  It doesn't exist.
    return 0;
}

# Parse a product entry line from a file or the command line
sub
parse_product_entry
{
    my ($line, $prodname, $prodver) = @_;
    my ($type, $name, $module, $filename, $pkgvar, $var, $val);
    my $type_guess = 0;
    my (%pkgvars, @inp);
    my $prod = "$prodname-$prodver";

    dprint "parse_product_entry(\"$line\", \"$prodname\", \"$prodver\")\n";
    undef %pkgvars;
    undef $module;
    undef $type;
    @inp = split(/\s+/, $line);
    if ($inp[0] =~ /^(prod|mod|srpm)[^:]*:/) {
        # Line begins with <type>:<name>, like "module:Eterm"
        ($type, $name) = split(":", shift @inp);
        $type =~ tr/[A-Z]/[a-z]/;
        dprint "parse_product_entry():  Found type \"$type\" and name \"$name\"\n";
        if ($type =~ /^prod/) {
            $type = "product";
        } elsif ($type =~ /^mod/) {
            $type = "module";
        } elsif ($type =~ /^srpm/) {
            $type = "srpm";
        } else {
            eprint "$type is not a valid package type.  I'll try to guess the correct one.\n";
            $type = 0;
        }
    }
    if (! $type) {
        # They didn't tell us the type, so let's guess educatedly.
        $type_guess = 1;
        ($name = shift @inp) =~ s/^[^:]*://;
        dprint "Guessing type of \"$name\"\n";
        if ($name =~ /\.src\.rpm/) {
            # Name ends with .src.rpm.  That's an easy one.
            $type = "srpm";
        } else {
            my @contents = ();

            # Check to see if there is a product file for it
            if (opendir(DIR, "$proddir")) {
                @contents = readdir(DIR);
                closedir(DIR);
            }
            @contents = grep($_ =~ /^$name-?/ && $_ =~ /\.prod$/, @contents);
            # Product files win over modules because they contain more detail
            # about the package and are more likely to succeed.
            if ($#contents >= 0) {
                $type = "product";
                ($name = $contents[0]) =~ s/\.prod$//;
            } else {
                $type = "module";
            }
        }
    }
    if ($type_guess) {
        nprint "$progname:  Note:  Since you didn't specify, I have guessed that \"$name\" is a $type.\n";
    }
    if ($name =~ /\/.+$/) {
        ($module = $name) =~ s/^([^\/]+)(.+)$/$1/;
        $name =~ s/^(.*)\/([^\/]+)$/$2/;
    } else {
        $module = $name;
    }
    # The rest of the line is whitespace-delimited sets of var=value
    foreach $varval (@inp) {
        ($var, $val) = split("=", $varval);
        $var = &get_var_name($var);
        $pkgvars{$var} = $val;
    }
    if ($type eq "product") {
        my ($pname, $pver);

        # Separate name and version
        if ($pkgvars{VERSION}) {
            ($pname, $pver) = ($name, $pkgvars{VERSION});
            $name = "$pname-$pver";
        } elsif ($name =~ /^(\S+)-((?:\d|us|a|alpha|b|beta)[^-]+)$/) {
            ($pname, $pver) = ($1, $2);
        } else {
            $pver = 0;
        }

        # Recursively convert products into their component packages
        $prods->{$name}{PRODUCT} = $prod;
        dprint "parse_product_entry():  Parent product of $name is $prod.\n";
        if (! &parse_prod_file($pname, $pver)) {
            dprint "parse_product_entry():  parse_prod_file($pname, $pver) failed.\n";
            undef $prods->{$name}{PRODUCT};
            if ($type_guess) {
                # If this was a guess, a potential infinite loop exists if we try
                # to parse the product entry again.  So just punt at this point.
                dprint "parse_product_entry() returning 0.\n";
                return 0;
            } else {
                my $tmp;

                $line =~ s/^[^:]+://;
                $tmp = &parse_product_entry($line, $prodname, $prodver);
                dprint "parse_product_entry():  parse_product_entry(\"$line\", $prodname, $prodver) returned $tmp, so I will to.\n";
                return $tmp;
            }
        }
        dprint "parse_product_entry():  parse_prod_file($pname, $pver) succeeded, so I'm returning 1.\n";
        return 1;
    }

    dprint "parse_product_entry():  Module is $module, name is $name\n";
    # Add defaults for stuff that is required
    if ($type eq "module") {
        if ($pkgvars{REVISION} =~ /^head$/i) {
            undef $pkgvars{REVISION};
        }
    } elsif ($type eq "srpm") {
        $name =~ s/\.src\.rpm$//;
        if (!defined $pkgvars{RELEASE}) {
            if ($name !~ /^\S+-[^-]+-[^-]+$/) {
                eprint "I wasn't given enough information about the $name package in $prodfile.  For SRPM\n";
                eprint "packages, the version and release information must be specified as variables or\n";
                eprint "embedded in the package name.  I'm going to have to skip that one.\n";
                return 0;
            } else {
                ($tmp = $name) =~ s/^\S+-[^-]+-//;
                $name =~ s/-[^-]+$//;
                $pkgvars{RELEASE} = $tmp;
            }
        }
        if (!defined $pkgvars{VERSION}) {
            if ($name !~ /^\S+-[^-]+$/) {
                eprint "I wasn't given enough information about the $name package in $prodfile.  For SRPM\n";
                eprint "packages, the version and release information must be specified as variables or\n";
                eprint "embedded in the package name.  I'm going to have to skip that one.\n";
                return 0;
            } else {
                ($tmp = $name) =~ s/^(\S+)-([^-]+)$/$2/;
                $name =~ s/^(\S+)-([^-]+)$/$1/;
                $pkgvars{VERSION} = $tmp;
            }
        }
        $filename = sprintf("%s$name-$pkgvars{VERSION}-$pkgvars{RELEASE}.src.rpm", ($module ? "$module/" : ""));
    }

    # Check for duplicates
    if (grep($_ eq $name, @packages)) {
        eprint "I already have $name as a $pkgs->{$name}{TYPE} package in $pkgs->{$name}{PRODUCT}.\n";
        eprint "I will ignore the duplicate entry found in $prodname $prodver\n";
        return 0;
    }
    # Now that we've got the name/version/release in their final forms, set up the data structures.
    $pkgs->{$name}{TYPE} = $type;
    $pkgs->{$name}{MODULE} = $module;
    $pkgs->{$name}{FILENAME} = ($filename ? $filename : $module);
    dprint "parse_product_entry():  New package:  $name (module $pkgs->{$name}{MODULE}, "
            . "filename $pkgs->{$name}{FILENAME}) is a $pkgs->{$name}{TYPE}\n";
    foreach $pkgvar (keys %pkgvars) {
        if ($pkgvars{$pkgvar} !~ /^$/) {
            $pkgs->{$name}{$pkgvar} = $pkgvars{$pkgvar};
            dprint "parse_product_entry():  Added variable $pkgvar to package $name with value \"$pkgs->{$name}{$pkgvar}\"\n";
        }
    }
    # Go through each propogated variable.  If there is no assigned value for that
    # variable for the current package, see if it has a value for the parent product
    # of that package.  If not, try the parent product of that product, and continue
    # going back through the product hierarchy until we find a value or run out.
    foreach $pkgvar ("REVISION", "LOCATIONS", "RPMCMD", "TAR", "ZIP", "STAGES", "CVSROOT") {
        if (! $pkgs->{$name}{$pkgvar}) {
            my ($pkg, $val) = undef;

            dprint "parse_product_entry():  No value for the variable $pkgvar for $name.\n";
            for ($pkg = $prod; $pkg; $pkg = $prods->{$pkg}{PRODUCT}) {
                dprint "parse_product_entry():  Checking $pkg for $pkgvar\n";
                if ($prods->{$pkg}{$pkgvar}) {
                    $val = $prods->{$pkg}{$pkgvar};
                    dprint "parse_product_entry():  Found fallback value $val in product $pkg\n";
                    last;
                }
            }
            if ($val) {
                $pkgs->{$name}{$pkgvar} = $val;
            }
        }
    }
    if (!defined $pkgs->{$name}{STAGES}) {
        dprint "parse_product_entry():  Defaulting to all stages for $name\n";
        $pkgs->{$name}{STAGES} = "scebpia";
    }
    push @packages, $name;
    $pkgs->{$name}{PRODUCT} = $prod;
    dprint "parse_product_entry():  Parent product of $name set to $prod.  I'm done, returning 1.\n";
    return 1;
}

# Parse product definition files recursively to establish
# all the products we need to work with and what packages or
# other products compose them.
sub
parse_prod_file
{
    my ($prodname, $prodver) = @_;
    my ($prodfile, $skip_to_name, $skip_to_next_ver, $found, $line);
    my $prod = "$prodname-$prodver";
    local *PROD;

    dprint "parse_prod_file($prodname, $prodver)\n";
    if (!($prodfile = &find_product_file($prodname, $prodver))) {
        dprint "parse_prod_file():  find_product_file() failed.  Returning 0.\n";
        return 0;
    }
    dprint "parse_prod_file():  Found product file \"$prodfile\"\n";
    open(PROD, "$prodfile") || return 0;

    ($skip_to_name, $skip_to_next_ver, $found) = (1, 0, 0); 
    while (<PROD>) {
        chomp($line = $_);
        dprint "parse_prod_file():  Parsing $prodfile:  \"$line\"\n";
        $line =~ s/^\s*(.*\S)\s*$/$1/;  # Strip leading and trailing whitespace
        next if ($line =~ /^\#/ || $line !~ /\S/);
        next if ($skip_to_name && $line !~ /^name\s*:/i);
        next if ($skip_to_next_ver && $line !~ /^ver(sion)?\s*:/i);
        if ($skip_to_name) {
            $line =~ s/^[^:]+:\s*//;
            if ($line eq $prodname) {
                dprint "parse_prod_file():  Found product name match\n";
                $skip_to_name = 0;
                $skip_to_next_ver = 1;
                next;
            }
        } elsif ($line =~ /^name\s*:/) {
            # New product.  Time to quit.
            last;
        } elsif ($skip_to_next_ver) {
            $line =~ s/^[^:]+:\s*//;
            next if ($line ne $prodver && $prodver);
            # Found it!
            if ($line eq $prodver) {
                dprint "parse_prod_file():  Found product version match.  Time to parse the product.\n";
            } else {
                dprint "parse_prod_file():  No product version given.  Using first entry:  $line\n";
                $prodver = $line;
                $prod = "$prodname-$prodver";
            }
            ($found, $skip_to_next_ver) = (1, 0);
            push @products, $prod;
            next;
        } elsif ($line =~ /^ver(sion)?\s*:/) {
            # New version.  Time to quit.
            last;
        } else {
            dprint "parse_prod_file():  Checking \"$line\" for product variables.\n";
            if ($line !~ /^(prod|mod|srpm)/i && $line =~ /^([^ \t:]+)\s*:\s*(\S+.*)$/) {
                my ($var, $val);

                # The regexp above should only match var:value (a product variable)
                ($var, $val) = ($1, $2);
                $var = &get_var_name($var);
                dprint "parse_prod_file():  Product variable for $prod:  $var -> $val\n";
                $prods->{$prod}{$var} = $val;
#                if ($prods->{$prod}{VARS} !~ /$var/) {
#                    $prods->{$prod}{VARS} .= "$var ";
#                }
            } else {
                my $tmp;

                dprint "parse_prod_file():  Calling parse_product_entry()...\n";
                $tmp = &parse_product_entry($line, $prodname, $prodver);
                dprint "parse_prod_file():  parse_product_entry() returned $tmp\n";
            }
        }
    }
    dprint "parse_prod_file():  Closing file $prodfile and returning $found\n";
    close(PROD);
    return ($found);
}

# What to do if a package fails
sub
fail_package
{
    my ($pkg, $stage, $msg) = @_;

    push @failed_pkgs, $pkg;
    $failure->{$pkg}{STAGE} = $stage;
    if ($msg) {
        $failure->{$pkg}{MESSAGE} = $msg;
        eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage:  $failure->{$pkg}{MESSAGE}.\n";
    } else {
        eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage.\n";
    }
    exit(-1) if (! $opt_f);
    @packages = grep($_ ne $pkg, @packages);
    return 0;
}

sub
fetch_package
{
    my $cmd = $_[0];
    my ($err, $msg, $line) = undef;
    local *REVTOOL;

    dprint "About to run $cmd\n";
    if (!open(REVTOOL, "$cmd 2>&1 |")) {
        $err = REVTOOL_COMMAND_FAILED;
        $msg = "Execution of \"$cmd\" failed -- $!";
        last;
    }
    while (<REVTOOL>) {
        chomp($line = $_);
        if ($debug) {
            nprint "From revtool -> $line\n";
        } else {
            nprint "$line\n";
        }
        next if ($line =~ /^\[debug:/);
        # Check the output for errors
        if ($line =~ /^revtool:\s*Error/) {
            ($msg = $line) =~ s/^revtool:\s*Error:\s*//;
        }
    }
    close(REVTOOL);
    $err = $?;
    dprintf "\"$cmd\" returned $err (%d)\n", $err >> 8;
    return ($err >> 8, $msg);
}

# Build RPMS from the spec file
sub
build_rpms
{
    my ($pkg, $specfile) = @_;
    my ($cmd, $rpm, $msg, $err, $line, $srpm);
    my (@failed_deps, @not_found, @spec_errors);
    local *RPM;

    $rpm = ($pkgs->{$pkg}{RPMCMD} ? $pkgs->{$pkg}{RPMCMD} : "rpm");
    $cmd = "$rpm --rcfile $rpmrc -ba $specfile";
    dprint "About to run \"$cmd\"\n";
    if (!open(RPM, "$cmd </dev/null 2>&1 |")) {
        return (1, "Execution of \"$cmd\" failed -- $!", undef);
    }
    $err = 0;
    while (<RPM>) {
        chomp($line = $_);
        nprint "$line\n";
        if ($line =~ /^Wrote: .*\.src\.rpm$/) {
            ($srpm = $line) =~ s/^Wrote:\s+//;
        } elsif ($line =~ /^line \d+: [^:]+: /
                 || $line =~ /^Failed to find \w+:/
                 || $line =~ /^Symlink points to BuildRoot: /) {
            $err = 1;
            push @spec_errors, $line;
        } elsif ($line =~ /^Bad exit status from/) {
            $err = 1;
            $line =~ s/^Bad exit status from \S+ \((%\w+)\)/$1/;
            $msg = "The RPM $line stage exited abnormally";
            last;
        } elsif ($line =~ /^error: failed build dependencies:/) {
            $err = 1;
            while (<RPM>) {
                chomp($line = $_);
                last if ($line !~ /is needed by/);
                $line =~ s/^\s+(\S+)\s+is needed by .*$/$1/;
                push @failed_deps, $line;
            }
            $msg = sprintf("Building this SRPM requires the following packages:  %s", join(" ", @failed_deps));
            last;
        } elsif ($line =~ /^Architecture is not included:/) {
            $err = 1;
            $line =~ s/^Architecture is not included:\s+//;
            $msg = "This SRPM does not build on the $line architecture";
        } elsif ($line =~ /^File (.*): No such file or directory$/
                 || $line =~ /^Bad file: (.*): No such file or directory$/
                 || $line =~ /^File is not a regular file: (.*)$/
                 || $line =~ /^Unable to open icon (\S+):$/
                 || $line =~ /^File not found(?: by glob)?: (.*)$/) {
            $err = 1;
            push @not_found, $line;
        }
    }
    close(RPM);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0 && $err == 0) {
        $err = 1;
        $msg = "Unhandled RPM build error";
    } elsif ($#not_found != -1) {
        $msg = sprintf("The following were expected by rpm, but no matching files were found:  %s",
                       join(" ", @not_found));
    } elsif ($#spec_errors != -1) {
        $msg = sprintf("The spec file contains the following errors:  \"%s\"", join("\" \"", @spec_errors));
    }
    dprint "build_rpms():  Returning $err, $msg, $srpm\n";
    return ($err, $msg, $srpm);
}

#
# The build process stages
#
sub
do_bootstrap_stage
{
    my ($line, $err, $msg);
    my @p = @packages;
    local *RPMMACROS;
    local *RPMRC;

    qprint "$progname:  Entering the bootstrap stage.  (${\(&get_timestamp())})\n";
    if (! -d "$builddir") {
        mkdir("$builddir", 0755) || &fatal_error("Cannot create $builddir -- $!\n");
        foreach $dir ("BUILD", "SRPMS", "RPMS", "SPECS", "SOURCES") {
            mkdir("$builddir/$dir", 0755);
        }
    }
    if (-f "$ENV{HOME}/.rpmmacros" && -s _) {
        $rpmmacros = "$ENV{HOME}/.rpmmacros";
    } else {
        $rpmmacros = "$basedir/rpmmacros";
        if (!(-f "$basedir/rpmmacros" && -s _)) {
            # Create basic rpmmacros
            open(RPMMACROS, ">$rpmmacros") || &fatal_error("Cannot create $rpmmacros -- $!\n");
            print RPMMACROS "\%_topdir        $builddir\n";
            close(RPMMACROS);
        }
    }
    if (-f "$ENV{HOME}/.rpmrc" && -s _) {
        $rpmrc = "$ENV{HOME}/.rpmrc";
    } else {
        $rpmrc = "$basedir/rpmrc";
        if (!(-f "$basedir/rpmrc" && -s _)) {
            # Create basic rpmrc
            open(RPMRC, ">$rpmrc") || &fatal_error("Cannot create $rpmrc -- $!\n");
            print RPMRC "optflags:   i386 $ENV{CFLAGS}\n";
            print RPMRC "macrofiles: /usr/lib/rpm/macros:/usr/lib/rpm/%{_target}/macros:/etc/rpm/macros.specspo:",
                         "/etc/rpm/macros:/etc/rpm/%{_target}/macros:~/.rpmmacros:$rpmmacros\n";
            close(RPMRC);
        }
    }
    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /s/) {
            nprint "$progname:  Skipping bootstrap stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting bootstrap stage for the \"$pkg\" package....\n";
        $filename = $pkgs->{$pkg}{FILENAME};
        if ($pkgs->{$pkg}{CVSROOT}) {
            $cvsroot = "-D $pkgs->{$pkg}{CVSROOT}";
        } else {
            $cvsroot = "";
        }
        if ($pkgs->{$pkg}{REVISION}) {
            $tag = "-t $pkgs->{$pkg}{REVISION}";
        } else {
            $tag = "";
        }
        dprint "Checking for $filename\n";
        # If it already exists , go on.
        if (($pkgs->{$pkg}{TYPE} eq "module" && -d $filename)
            || ($pkgs->{$pkg}{TYPE} eq "srpm" && -f $filename && -s _)) {
            nprint "$progname:  $filename already exists.  I'll assume it's the right one.\n";
            nprint "$progname:  Bootstrap stage for \"$pkg\" is complete.\n";
            next;
        }
        $cmd = "$revtool $cvsroot $tag -g $filename";
        ($err, $msg) = &fetch_package($cmd);  # Download the package using revtool
        if ($err) {
            &fail_package($pkg, "bootstrap", $msg);
            next;
        }
        if (!(($pkgs->{$pkg}{TYPE} eq "module" && -d $filename)
              || ($pkgs->{$pkg}{TYPE} eq "srpm" && -f $filename && -s _))) {
            # If it's not there, we must've missed the error.
            &fail_package($pkg, "bootstrap", "Unhandled error condition");
            next;
        }
        nprint "$progname:  Bootstrap stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Bootstrap stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_compose_stage
{
    my ($specfile, $target, $pn, $dir, $err, $line, $src, $tarball, $cwd);
    my (@contents, @tmp, @dirs, @sfiles, @srcs);
    my @p = @packages;
    local *DIR;
    local *CMD;

    qprint "$progname:  Entering the compose stage.  (${\(&get_timestamp())})\n";
    chomp($cwd = `pwd`);

    # No compose stage for SRPM's since they're *already* SRPM's....
    foreach $pkg (grep $pkgs->{$_}{TYPE} eq "module", @p) {
        if ($pkgs->{$pkg}{STAGES} !~ /c/) {
            nprint "$progname:  Skipping compose stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting compose stage for the \"$pkg\" package....  (${\(&get_timestamp())})\n";

        # The first step is to examine the module directory to find
        # the names of the vendor source files/directories and the spec file.
        if (! chdir("$cwd/$pkgs->{$pkg}{MODULE}")) {
            &fail_package($pkg, "compose", "Could not chdir into $cwd/$pkgs->{$pkg}{MODULE} -- $!");
            next;
        }
        ($pn = $prodname) =~ s/^va-//;
        opendir(DIR, ".");
        @contents = readdir(DIR);
        closedir(DIR);
        if (grep($_ =~ /\.src\.rpm$/, @contents)) {
            # The target SRPM already exists.  Skip this stage.
            nprint "$progname:  The target SRPM for \"$pkg\" already exists in $cwd/$pkgs->{$pkg}{MODULE}.\n";
            nprint "$progname:  I'll assume it's the right one.  Compose stage for \"$pkg\" is complete.\n";
            next;
        }
            
        if ($pkgs->{$pkg}{SPECFILE} && -f $pkgs->{$pkg}{SPECFILE}) {
            # If they gave us the spec file and it exists, use that.
            $specfile = $pkgs->{$pkg}{SPECFILE};
        } else {
            # First choice:  Exactly one file named <pkg>-<distro>.spec
            @tmp = grep($_ =~ /^($pkg-)?(va-)?$pn\.spec/, @contents);
            if ($#tmp != 0) {
                # Second choice:  Exactly one file named <pkg>.spec
                @tmp = grep($_ =~ /^$pkg\.spec/, @contents);
                if ($#tmp != 0) {
                    # Third choice:  The first match to *.spec*
                    @tmp = grep($_ =~ /\.spec/, @contents);
                }
            }
            $specfile = $tmp[0];
            if (!defined $specfile || $specfile =~ /^$/) {
                # Our attempt to guess failed.  They need to specify the spec file in the .prod file.
                &fail_package($pkg, "compose", "No spec file could be located in $pkgs->{$pkg}{MODULE}");
                next;
            }
        }

        undef @srcs;
        if ($pkgs->{$pkg}{SRCS}) {
            @srcs = split(",", $pkgs->{$pkg}{SRCS});
        } else {
            my $fname;

            foreach $fname (@contents) {
                next if ($fname =~ /^(CVS|SCCS|RCS|BitKeeper)$/);
                next if ($fname =~ /^\./);
                next if ($fname =~ /\.spec(\.in)?$/);
                if (-d $fname) {
                    push @srcs, "$fname:$fname.tar.gz";
                } else {
                    push @srcs, $fname;
                }
            }
        }

        foreach $src (@srcs) {
            my ($src_files, $tarball) = split(":", $src);

            $src_files =~ s/\&/ /g;
            if ($tarball) {
                my $zip;

                if ($pkgs->{$pkg}{TAR}) {
                    $cmd = $pkgs->{$pkg}{TAR};
                    $cmd =~ s/\%f/$src_files/;
                    $cmd =~ s/\%t/$builddir\/SOURCES\/$tarball/;
                } else {
                    if ($pkgs->{$pkg}{ZIP}) {
                        $zip = "--use-compress-program=\"$pkgs->{$pkg}{ZIP}\"";
                    } elsif ($src =~ /(gz|Z)$/) {
                        $zip = "--use-compress-program=gzip";
                    } elsif ($src =~ /\.bz2$/) {
                        $zip = "--use-compress-program=bzip2";
                    }
                    $cmd = "tar --exclude CVS --exclude RCS --exclude BitKeeper --exclude SCCS"
                            . " $zip -cf $builddir/SOURCES/$tarball $src_files";
                }
                dprint "Creating $tarball:  $cmd\n";
                unlink($tarball);
                if (!open(CMD, "$cmd 2>&1 |")) {
                    &fail_package($pkg, "compose", "Execution of \"$cmd\" failed -- $!");
                    $err = 1;
                    last;
                }
                $err = 0;
                while (<CMD>) {
                    chomp($line = $_);
                    nprint "tar output -> $line\n";
                }
                close(CMD);
                dprint "\"$cmd\" returned $?\n";
                if ($?) {
                    &fail_package($pkg, "compose", "Creation of vendor source tarball $tarball from failed");
                    $err = 1;
                    last;
                }
            } else {
                my $rc;

                $rc = system("cp -f $src_files $builddir/SOURCES/") >> 8;
                if ($rc) {
                    &fail_package($pkg, "compose", "Unable to copy $src_files to $builddir/SOURCES/ -- $!");
                    $err = 1;
                    last;
                }
            }
        }
        if ($err) {
            next;
        }

        # Now build the new SRPM from the new vendor source tarball and the spec file.
        ($err, $msg, $srpm) = &build_rpms($pkg, $specfile);
        dprint "do_compose_stage():  build_rpms($pkg, $specfile) returned $err, $msg, $srpm\n";
        if ($err) {
            &fail_package($pkg, "compose", $msg);
            next;
        }
        dprint "Module apparently just built its SRPM as $srpm\n";

        # Copy it here and assign FILENAME to it.
        system("mv $srpm .");
        $pkgs->{$pkg}{FILENAME} = $srpm;
        $pkgs->{$pkg}{FILENAME} =~ s/^(\S+)\/([^\/]+\.src\.rpm)$/$2/;
        $pkgs->{$pkg}{FILENAME} = "$basedir/$pkgs->{$pkg}{MODULE}/$pkgs->{$pkg}{FILENAME}";
        dprint "Filename is $pkgs->{$pkg}{FILENAME}\n";

        nprint "$progname:  Compose stage for \"$pkg\" is complete.  (${\(&get_timestamp())})\n";
    }
    chdir($cwd);
    qprint "$progname:  Compose stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_explode_stage
{
    my ($cmd, $err, $msg, $line, $specfile, $rpm) = undef;
    my @manifest;
    my @p = @packages;
    local *RPM;

    qprint "$progname:  Entering the explode stage.  (${\(&get_timestamp())})\n";

    foreach $pkg (@p) {
        undef @manifest;
        if ($pkgs->{$pkg}{STAGES} !~ /e/ && $pkgs->{$pkg}{STAGES} !~ /x/) {
            nprint "$progname:  Skipping explode stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting explode stage for the \"$pkg\" package....\n";
        $rpm = ($pkgs->{$pkg}{RPMCMD} ? $pkgs->{$pkg}{RPMCMD} : "rpm");

        # Examine the SRPM and figure out everything it contains.
        $cmd = "$rpm --rcfile $rpmrc -qlp $pkgs->{$pkg}{FILENAME}";
        dprint "About to run \"$cmd\"\n";
        if (!open(RPM, "$cmd 2>&1 |")) {
            &fail_package($pkg, "explode", "Execution of \"$cmd\" failed -- $!");
            next;
        }
        if (defined $pkgs->{$pkg}{SPECFILE}) {
            $specfile = $pkgs->{$pkg}{SPECFILE};
        } else {
            undef $specfile;
        }
        while (<RPM>) {
            chomp($line = $_);
            dprint "RPM contents -> $line\n";
            push @manifest, $line;  # Add the file to the manifest
            if ($line =~ /\.spec(\.in)?$/) {
                if (!defined $specfile) {
                    $specfile = $line;
                    dprint "Found spec file as $specfile\n";
                } elsif ($specfile eq $line) {
                    dprint "Found spec file $specfile as predicted.\n";
                } else {
                    qprint "$progname:  Warning:  $pkgs->{$pkg}{FILENAME} contains the spec file $line\n";
                    qprint "$progname:  which is different from the one I was told to expect ($specfile).\n";
                    qprint "$progname:  I will ignore the auto-detected one as requested, but this may be a problem.\n";
                }
            }
        }
        close(RPM);
        dprint "\"$cmd\" returned $?\n";
        if ($? != 0) {
            # FIXME:  What to do here?
        }
        if (! $specfile) {
            &fail_package($pkg, "explode", "Unable to locate spec file in SRPM");
            next;
        }
        # We'll use these later, so they MUST be defined for
        # any package we plan on actually building later.
        $pkgs->{$pkg}{SPECFILE} = "$builddir/SPECS/$specfile";
        $pkgs->{$pkg}{MANIFEST} = join(" ", @manifest);

        # Check for each of those files.
        $err = 0;
        foreach $piece (@manifest) {
            # FIXME:  Need to handle _topdir for people who did their own rpm* files.
            if (($piece =~ /\.spec(\.in)?$/ && -f "$builddir/SPECS/$piece")
                || (-f "$builddir/SOURCES/$piece")) {
                next;
            }
            $err = 1;  # Something is missing.  We must explode this SRPM.
            last;
        }
        # If everything is there, go on.
        if (! $err) {
            nprint "$progname:  SRPM has already been completely exploded.\n";
            nprint "$progname:  Explode stage for \"$pkg\" is complete.\n";
            next;
        }

        # Explode the SRPM into its components
        $cmd = "rpm --rcfile $rpmrc -U $pkgs->{$pkg}{FILENAME}";
        dprint "About to run \"$cmd\"\n";
        if (!open(RPM, "$cmd 2>&1 |")) {
            &fail_package($pkg, "explode", "Execution of \"$cmd\" failed -- $!");
            next;
        }
        $err = 0;
        while (<RPM>) {
            chomp($line = $_);
            nprint "$line\n";
            if ($line !~ /^$/) {
                # Any output from this command is an error.
                $err = 1;
                $msg = "$line";
                last;
            }
        }
        close(RPM);
        dprint "\"$cmd\" returned $?\n";
        if ($? != 0) {
            # FIXME:  What to do here?
        }
        if ($err) {
            &fail_package($pkg, "explode", $msg);
            next;
        }
        nprint "$progname:  Explode stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Explode stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_build_stage
{
    my ($cmd, $err, $msg, $line, $specfile, $rpm, $tmp, $target) = undef;
    my ($target_age, $orig_age, $spec_age, $srpm);
    my @p = @packages;

    qprint "$progname:  Entering the build stage.  (${\(&get_timestamp())})\n";

    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /b/) {
            nprint "$progname:  Skipping build stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting build stage for the \"$pkg\" package....  (${\(&get_timestamp())})\n";

        # Check for a target SRPM that is newer than the original SRPM and the
        # spec file.  If such an SRPM exists, skip the build stage for this package.
        $target = "$builddir/SRPMS/$pkg" . "-"
                   . "$pkgs->{$pkg}{VERSION}" . "-" . "$pkgs->{$pkg}{RELEASE}.src.rpm";
        $specfile = $pkgs->{$pkg}{SPECFILE};
        dprint "Target SRPM is $target\n";
        if (-f $target) {
            $target_age = -M _;
            $orig_age = -M $pkgs->{$pkg}{FILENAME};
            $spec_age = -M $specfile;
            dprint "File ages:  $orig_age for $pkgs->{$pkg}{FILENAME}, $target_age for $target,"
                    . " and $spec_age for $specfile\n";
            if ($target_age < $spec_age && $target_age < $orig_age) {
                nprint "$progname:  The target SRPM already exists.\n";
                nprint "$progname:  Build stage for \"$pkg\" is complete.\n";
                next;
            }
        }

        # Rebuild from the spec file
        ($err, $msg, $srpm) = &build_rpms($pkg, $specfile);
        dprint "do_build_stage():  build_rpms($pkg, $specfile) returned $err, $msg, $srpm\n";
        if ($err) {
            &fail_package($pkg, "build", $msg);
        }
        nprint "$progname:  Build stage for \"$pkg\" is complete.  (${\(&get_timestamp())})\n";
    }
    qprint "$progname:  Build stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_package_stage
{
    my ($path, $version, $release);
    my @outfiles;
    my @contents;
    my @p = @packages;
    local *DIR;

    qprint "$progname:  Entering the package accumulation stage.  (${\(&get_timestamp())})\n";

    # Create the directories where we'll put the packages
    # FIXME:  The prod files should probably be able to specify this
    if (! -d "$basedir/$prod") {
        mkdir("$basedir/$prod", 0755) || &fatal_error("Cannot create $basedir/$prod -- $!\n");
        foreach $dir ("SRPMS", "RPMS") {
            mkdir("$basedir/$prod/$dir", 0755);
        }
    }
    
    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /p/) {
            nprint "$progname:  Skipping package accumulation stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting package accumulation stage for the \"$pkg\" package....\n";
        $version = $pkgs->{$pkg}{VERSION};
        $release = $pkgs->{$pkg}{RELEASE};
        undef @outfiles;

        # Find all the RPM's installed by this package
        dprint "Opening directory $builddir/SRPMS to scan for output files.\n";
        opendir(DIR, "$builddir/SRPMS") || &fatal_error("Cannot open directory $builddir/SRPMS -- $!\n");
        @contents = readdir(DIR);
        foreach $rpm (@contents) {
            dprint "Checking $builddir/SRPMS/$rpm\n";
            if ($rpm =~ /^$pkg-\S*$version-$release\.src\.rpm/) {
                dprint "Got output file $rpm\n";
                push @outfiles, "$builddir/SRPMS/$rpm";
            }
        }
        closedir(DIR);

        dprint "Opening directory $builddir/RPMS to scan for output files.\n";
        @contents = glob("$builddir/RPMS/*/$pkg*.rpm");
        foreach $rpm (@contents) {
            dprint "Checking $rpm\n";
            if ($rpm =~ /^$pkg-\S*$version-$release\.\S+\.rpm/) {
                dprint "Got output file $rpm\n";
                push @outfiles, $rpm;
            }
        }

        if ($#outfiles == -1) {
            &fail_package($pkg, "package accumulation", "No output RPM's were found");
            next;
        }
        dprint "Output files for $pkg:  ", join(" ", @outfiles), "\n";

        # Move each RPM into the appropriate place
        foreach $rpm (@outfiles) {
            ($path = $rpm) =~ s/^\S+\/(S?RPMS\/)/$1/;  # Get only the names of the subdirectories
            $path =~ s/\/([^\/]+)$//;
            $path = "$basedir/$prod/$path";
            dprint "Path is \"$path\"\n";
            &mkdirhier("$path");
            system("cp $rpm $path/");
        }
        nprint "$progname:  Package accumulation stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Package accumulation stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_iso_stage
{
    my @p = @packages;

    qprint "$progname:  Entering the ISO image stage.  (${\(&get_timestamp())})\n";
    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /i/) {
            nprint "$progname:  Skipping ISO image stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting ISO image stage for the \"$pkg\" package....\n";

        nprint "$progname:  ISO image stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  ISO image stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_cleanup_stage
{
    my @p = @packages;

    qprint "$progname:  Entering the cleanup stage.  (${\(&get_timestamp())})\n";
    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /a/) {
            nprint "$progname:  Skipping cleanup stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting cleanup stage for the \"$pkg\" package....\n";

        nprint "$progname:  Cleanup stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Cleanup stage is now complete.  (${\(&get_timestamp())})\n";
}

# Once we're all done, summarize any failures at the very end
# so that they're easy to find if the user is generating a log.
sub
summarize_failures
{
    my ($ns, $nf, $nt);

    $ns = $#packages + 1;
    $nf = $#failed_pkgs + 1;
    $nt = $ns + $nf;
    qprintf "Package Summary:  Out of %d total packages, %d succeeded and %d failed.\n", $nt, $ns, $nf;

    foreach $pkg (@failed_pkgs) {
        if ($failure->{$pkg}{MESSAGE}) {
            eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage:  $failure->{$pkg}{MESSAGE}.\n";
        } else {
            eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage.\n";
        }
    }
}

# This routine does the actual build process
sub
build_process
{
    $ENV{MAKE} = "make";  # Make sure we don't parallel build, because it doesn't work.
    $ENV{CFLAGS} = "-O2 -march=pentium";  # A bit of optimization, but not much.
    undef $ENV{LD_LIBRARY_PATH};  # Make glibc happy

    # Perform the build in stages, checking after each one to see if we should stop
    &do_bootstrap_stage();
    return if ($opt_b eq "s");

    &do_compose_stage();
    return if ($opt_b eq "c");

    &do_explode_stage();
    return if ($opt_b eq "e" || $opt_b eq "x");

    &do_build_stage();
    return if ($opt_b eq "b");

    &do_package_stage();
    return if ($opt_b eq "p");

    &do_iso_stage();
    return if ($opt_b eq "i");

    &do_cleanup_stage();
}

# main() here is basically the same as main() in C
sub
main
{
    # Set up the basic variables
    $progname = "buildtool";
    $version = "0.1.0";

    # See the Getopt::Mixed man page for details on the syntax of this line
    $valid_opts = "h help>h v version>v d debug>d b=s build>b p=s product>p package>p"
                   . " q quiet>q Q really-quiet>Q silent>Q D dir>D f force>f l=s log>l";
    Getopt::Mixed::getOptions($valid_opts);

    # Post-parse the options stuff
    if ($opt_v) {
	print "$progname $version by Michael Jennings\n";
        print "Copyright (c) 2000, Michael Jennings and VA Linux Systems, Inc.\n";
	exit(0);
    }
    if ($opt_h) {
	&print_usage_info();   # Never returns
    }
    $debug = $opt_d;
    $verbosity = ($opt_Q ? 0 : ($opt_q ? 1 : 2));
    $GLOBAL_LOG = 0;
    if ($opt_l) {
        if (!open(LOGFILE, ">$opt_l")) {
            eprint "Unable to open $opt_l -- $!\n";
        } else {
            $GLOBAL_LOG = \*LOGFILE;
            open(STDERR, ">&LOGFILE");
        }
    }
    if ($opt_D) {
        $proddir = $opt_D;
    } elsif ($ENV{PROD_DIR} && $ENV{PROD_DIR} =~ /^\//) {
        $proddir = $ENV{PROD_DIR};
    } else {
        chomp($proddir = `pwd`);
        $proddir .= "/products";
    }
    $opt_b = "p" if (! $opt_b);
    chomp($basedir = (($ENV{BASE_DIR} && $ENV{BASE_DIR} =~ /^\//) ? $ENV{BASE_DIR} : `pwd`));
    $builddir = ($ENV{BUILD_DIR} ? $ENV{BUILD_DIR} : "$basedir/build");
    $revtool = sprintf("revtool%s", ($opt_d ? " --debug" : ""));

    # We actually begin work here.
    $prod = $opt_p;
    if ($prod =~ /^(\S+)-((?:\d|us|a|alpha|b|beta)[^-]+)$/) {
        ($prodname, $prodver) = ($1, $2);
    } else {
        ($prodname, $prodver) = ($prod, 0);
    }
    if ($prod) {
        qprint "$progname:  Building product:  $prodname $prodver\n";
    } else {
        eprint "You didn't tell me what to build, so I'm not quite sure what to do.\n";
        eprint "If you aren't familiar with how to use $progname, try $progname --help.\n";
        return;
    }

    # Parse the product definition files to figure out what the heck we need to build. :)
    if (! &parse_prod_file($prodname, $prodver)) {
        if (! &parse_product_entry($prod)) {
            eprint "$prod does not seem to be a valid product or product entry.\n";
            eprint "Perhaps you made a typo?\n";
            return;
        }
    }
    dprint "Products to be built:  ", join(" ", @products), "\n";

    if ($opt_b ne "Z") {  # -dbZ, a.k.a. How To Debug the Parser :-)
        &build_process();
        &summarize_failures();
    }
    close(LOGFILE) if ($GLOBAL_LOG);
}

&main();
