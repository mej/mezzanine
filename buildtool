#!/usr/bin/perl -w
#
# buildtool -- Product Build Management Tool
# 
# Copyright (C) 2000-2001, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: buildtool,v 1.155 2001/08/21 22:47:40 mej Exp $
#

# Include the Perl Modules we need
require POSIX;
require Getopt::Long;
use Cwd;
use Avalon::Util;
use Avalon::RevCtl;
use Avalon::PkgVars;
use Avalon::Src;
use Avalon::Pkg;
use Avalon::Build;
use Avalon::Prod;

# Print usage information
sub
print_usage_info
{
    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   buildtool [ options ]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -q --quiet                       Be somewhat quiet.  Simply gives basic progress info\n";
    print "    -Q --really-quiet --silent       Be very quiet.  Only errors are reported\n";
    print "    -D --dir <directory>             Specify the repository to use (overrides all product files)\n";
    print "    -l --log <logfile>               Specify a log file to send informational output to\n";
    print "    -P --parallel [expr]             Parallelize the build process based on the number of CPU's\n";
    print "    -t --target <arch>               Tell rpm to build for a particular target architecture\n";
    print "    -C --cflags <flags>              Specify the \$CFLAGS variable to use for building\n";
    print "    -U --user <userid>               Specify a userid for the repository (overrides product files)\n";
    print "    -T --tag <tag>                   Specify a tag to use (overrides all product files)\n";
    print "       --nocache                     Do not scan the cache (use with care)\n";
    print "       --clean                       Clean up RPM and buildroot directories when done\n";
    print "\n";
    exit(AVALON_SUCCESS);
}

# Normal print (i.e., don't print this in -q or -Q mode)
sub nprintf    {printf @_ if ($GLOBAL_LOG || $verbosity >= 2);}
sub nprint     {print  @_ if ($GLOBAL_LOG || $verbosity >= 2);}
# Quiet print (i.e., print in -q mode but not in -Q mode)
sub qprintf    {printf @_ if ($GLOBAL_LOG || $verbosity >= 1);}
sub qprint     {print  @_ if ($GLOBAL_LOG || $verbosity >= 1);}

# What to do if a package completes successfully
sub
complete_package
{
    my $pkg = $_[0];

    push @completed_pkgs, $pkg;
    nprint "Package build for $pkg completed successfully.  (${\(&get_timestamp())})\n";
}

# What to do if a package fails
sub
fail_package
{
    my ($pkg, $msg) = @_;

    push @failed_pkgs, $pkg;
    if ($msg) {
        $msg =~ s/\.+$//;
        $failure->{$pkg}{MESSAGE} = $msg;
        eprint "Package \"$pkg\" failed:  $msg.\n";
    } else {
        eprint "Package \"$pkg\" failed with an unknown error.\n";
    }
}

# Remove failed packages and packages we don't build from the list
sub
update_package_list
{
    my $parray = shift;
    my @p = @{$parray};

    @{$parray} = ();
    foreach my $pkg (@p) {
        next if ($pkgs->{$pkg}{TYPE} eq "image");
        if (!grep($_ eq $pkg, @failed_pkgs)) {
            push @{$parray}, $pkg;
        }
    }
    return (@{$parray});
}

# Build a single package from source (if needed) and place the resulting files where they go.
sub
build_single_package
{
    my $pkg = shift;
    my ($pkgfile, $err, $msg, $outfiles);

    # Binaries or not, we need to know the full path and name of the source package.
    if (! ($pkgfile = &pkgvar_filename($pkgs->{$pkg}{MODULE}, $pkgs->{$pkg}{FILENAME}))) {
        &fail_package($pkg, "I don't know what file/module to build from!");
        return AVALON_NO_SOURCES;
    }

    # If there are binaries, no point in trying to build source.
    if ($pkgs->{$pkg}{BINS}) {
        $outfiles = join(' ', &pkgvar_filename(), @{$pkgs->{$pkg}{BINS}});
    } else {
        # Build the source
        &pkgvar_target($target);
        ($err, $msg, $outfiles) = &build_package();
        if ($err != AVALON_SUCCESS) {
            &fail_package($pkg, $msg);
            return $err;
        }
    }
    $err = &place_package_files($pkg, $outfiles, $pkgs->{$pkg}{LOCATIONS});
    return $err if ($err != AVALON_SUCCESS);
    &complete_package($pkg);
    return AVALON_SUCCESS;
}

# Spawn a child buildtool
sub
build_package_forked
{
    my ($pkg, $logfile) = @_;
    my $pid;

    do {
        if ($pid = fork()) {
            # Parent -- return PID
            nprint "Spawned child process $pid to build $pkg (log file is $logfile)\n";
            return $pid;
        } elsif (defined $pid) {
            my ($err, $buildroot);

            # Child -- reset state as needed and jump to build process
            close $GLOBAL_LOG if ($GLOBAL_LOG);
            open(STDOUT, ">/dev/null");
            open(STDIN, "</dev/null");
            &nuke_tree($logfile) if (-e $logfile);
            if (!open(LOGFILE, ">$logfile")) {
                eprint "Unable to open $logfile -- $!\n";
            } else {
                $GLOBAL_LOG = \*LOGFILE;
                #system("chattr +S $logfile");  # Try to set sync on the log file, fail silently
                open(STDERR, ">&LOGFILE");
                select LOGFILE; $| = 1;
            }
            $buildroot = &pkgvar_buildroot();
            if ($buildroot) {
                &pkgvar_buildroot("$buildroot/$pkg.$$");
            } else {
                &pkgvar_buildroot("/var/tmp/avalon-buildroot.$$");
            }
            $err = &build_single_package($pkg);
            close(LOGFILE) if ($GLOBAL_LOG);
            exit ($err);
        } elsif ($! !~ /No more processes/ && $! !~ /Resource temporarily unavailable/) {
            &fatal_error("fork() failed -- $!\n");
        }
        # Temporary failure
        dprint "Failed temporarily -- $!\n";
        sleep 5;
    } while (1);
}

# Download packages from the repository
sub
download_packages
{
    my @packages = @_;
    my ($line, $err, $msg);

    nprint "Downloading packages, please wait..." if (! &debug_get());
    foreach $pkg (@packages) {
        my ($files, $tag);

        $err = 0;
        $files = &pkgvar_filename($pkgs->{$pkg}{MODULE}, $pkgs->{$pkg}{FILENAME});
        if (defined($pkgs->{$pkg}{BINS})) {
            $files = join(' ', $files, @{$pkgs->{$pkg}{BINS}});
        }
        &pkgvar_filename($files);

	# Set the proper REPOSITORY and tag for the checkout.
        
        if ($global_tree) {
            &revctl_repository($global_tree);
        } elsif ($pkgs->{$pkg}{REPOSITORY}) {
            &revctl_repository($pkgs->{$pkg}{REPOSITORY});
        } else {
            &revctl_repository("");
        }
        if ($global_user) {
            my $repository;

            $repository = &revctl_repository();
            $repository =~ s/\w+\@/$global_user\@/;
            &revctl_repository($repository);
        }
        if ($global_tag) {
            &revctl_tag(($global_tag eq "head") ? "" : $global_tag);
        } elsif ($pkgs->{$pkg}{TAG}) {
            &revctl_tag(($pkgs->{$pkg}{TAG} eq "head") ? "" : $pkgs->{$pkg}{TAG});
        } else {
            &revctl_tag("");
        }

        nprint "$pkg..." if (! &debug_get());
        ($err, $msg) = &fetch_package();
        if ($err != AVALON_SUCCESS && $err != AVALON_DUPLICATE) {
            &fail_package($pkg, $msg);
            next;
        }
    }
    nprint "done.\n\n" if (! &debug_get());
}

sub
place_package_files
{
    my ($pkg, $outfiles, $locations) = @_;
    my @outfiles;
    my @contents;

    # If we didn't find any, something is very wrong.
    if (! $outfiles) {
        &fail_package($pkg, "No output packages were found");
        return AVALON_PACKAGE_FAILED;
    }
    if (! $locations) {
        wprint "No locations specified for $pkg.\n";
        return AVALON_SUCCESS;
    }
    dprint "Output files for $pkg:  $outfiles\n";

    # Copy each package into the appropriate place
    foreach my $file (split(' ', $outfiles)) {
        foreach my $loc (split(",", $locations)) {
            my ($regex, $stop, $dest);

            # Format is:  /regexp/.path  where . is some delimiter character that
            # tells us whether to check other locations or stop once we match
            # (':' to continue looking for matches, or '=' to stop if a match is found).
            dprint "Testing location \"$loc\"\n";
            if ($loc !~ m/^\/([^\/]+)\/(.)(\S+)?$/) {
                eprint "Location specifier \"$loc\" is invalid.\n";
                next;
            }
            ($regex, $stop, $dest) = ($1, $2, $3);
            if ($stop eq "!") {
                # A negative match test.  If we get a match, don't accept it.
                next if ($file =~ $regex);
            } else {
                # No match.  Try next location.
                next if ($file !~ $regex);
            }
            dprint "Match found.\n";

            if ($dest) {
                # If the destination does not contain a filename, add the filename portion of
                # $file to the directory path in $dest.  The destination could be used to rename
                # a file, however; that's why this check is in place.
                if (substr($dest, -3, 3) ne substr($file, -3, 3)) {
                    my $tmp;

                    ($tmp = $file) =~ s/^.*\/([^\/]+)$/$1/;
                    $dest = "$dest/$tmp";
                }
                # If it exists, delete it
                if (-e $dest) {
                    &nuke_tree($dest);
                }
                # Then link it
                dprint "ln -f $file $dest\n";
                if (!link($file, $dest)) {
                    &fail_package($pkg, "Unable to create $dest as a link to $file -- $!");
                    last;
                }
            }

            # If the stop character is '=', stop checking for matches for this package.
            # If it's ':' (actually, any other character than '='), keep looking for matches.
            last if ($stop eq "=");
            dprint "Non-exclusive match.  Continuing on....\n";
        }
    }
    return AVALON_SUCCESS;
}

# This routine parallelizes the product build so that each package is built by an individual buildtool process.
sub
parallel_build
{
    my @packages = @_;
    my ($pwd, $builddir, $logdir, $buildroot, $dummy);
    my (@children, @vars);
    my %child_pkg;

    # Create the directories for building this product
    &pkgvar_topdir(&make_build_dir(&getcwd()));
    $logdir = &make_log_dir($builddir);
    # Need to do this here for parallel builds because it's not parallel-safe.  Race condition. :(
    &prepare_build_tree();

    # Download all the packages.
    &download_packages(@packages);
    &update_package_list(\@packages);

    qprint "$progname:  Beginning $num_cpus-way build of ${\(scalar(@packages))} packages.  (${\(&get_timestamp())})\n";
    for (; scalar(@packages) || scalar(@children);) {
        my ($pid, $line, $left, $failed, $bldg, $err);

        # As long as there are packages left to build or children left to wait on, we loop.
        for (; scalar(@packages) && (scalar(@children) < $num_cpus);) {
            my ($pkg, $logfile);

            # Spawn child processes until we fill up our allotment ($num_cpus)
            $pkg = shift @packages;
            $logfile = "$logdir/$pkg.log";
            $pid = &build_package_forked($pkg, $logfile);
            push @children, $pid;
            $child_pkg{$pid} = $pkg;
        }

        # Okay, we can't build anything more right now.  Print some status info.
        $line = "";
        foreach my $pid (@children) {
            $line .= "$child_pkg{$pid} ($pid)    ";
        }
        nprint "$progname:  Currently building:  $line\n";
        nprint "$progname:  ${\(scalar(@completed_pkgs))} packages completed (${\(scalar(@failed_pkgs))} failed), "
            . "${\(scalar(@children))} building, ${\(scalar(@packages))} in queue.\n";

        # This loop waits until one of our immediate children dies before continuing.
        do {
            $pid = waitpid(-1, 0);
        } while (! ($pkg = $child_pkg{$pid}));
        $err = $? >> 8;
        if ($pid == -1) {
            # This should never happen.
            eprint "Ummm, waitpid() returned -1.  That wasn't very nice.  I'm offended.\n";
            next;
        }

        # Remove the child from our PID list
        @children = grep($_ != $pid, @children);

        # Check to see how it existed
        if ($err == AVALON_SUCCESS) {
            # Yay! :-)
            &complete_package($pkg);
        } else {
            my @tmp;
            local *ERRLOG;

            # Doh, it failed.  Look through the log file to try and find the problem.
            if (!open(ERRLOG, "$logdir/$pkg.log")) {
                &fail_package($pkg, "Child process returned $err but the log file is missing");
                next;
            }
            @tmp = <ERRLOG>;
            close(ERRLOG);
            # If the last line doesn't match, take the last line out of all the lines that do.
            if ($tmp[$#tmp] !~ /error: /i) {
                @tmp = grep($_ =~ /error: /i, @tmp);
            }
            chomp($line = $tmp[$#tmp]);
            # Record that the package failed.
            if ($line =~ /^$progname:  Error:  Package \S+ failed:  (.*)$/) {
                &fail_package($pkg, $1);
            } else {
                $line = "Couldn't find error in log" if (! $line);
                $line =~ s/^\w+:\s*Error:\s*//;
                &fail_package($pkg, "Child process exited with code $err -- $line");
            }
        }
        # End of loop.  Time to spawn the next child.
    }
    &cleanup_build_tree();
    return (scalar(@failed_pkgs) ? AVALON_PACKAGE_FAILED : AVALON_SUCCESS);
}

sub
build_product
{
    my @packages = @_;
    my $builddir;

    &pkgvar_topdir(&make_build_dir(&getcwd()));
    if (!chdir($builddir)) {
        &fatal_error("Unable to chdir to build directory -- $!\n");
    }

    # Download all the packages.
    &download_packages(@packages);
    &update_package_list(\@packages);

    # Call build_package() for each package; we don't care how that works as long as it does. :-)
    foreach my $pkg (@packages) {
        &build_single_package($pkg);
    }

    # Now we clean up.
    &cleanup_build_tree();
    return (scalar(@failed_pkgs) ? AVALON_PACKAGE_FAILED : AVALON_SUCCESS);
}

# Once we're all done, summarize any failures at the very end
# so that they're easy to find if the user is generating a log.
sub
summarize_failures
{
    my ($ns, $nf, $nt, $nb, $face);

    # $ns is the number of successful packages.  $nf is the number of failures.
    # $nt is the total number of packages we tried to build.
    $ns = scalar(@completed_pkgs);
    $nf = scalar(@failed_pkgs);
    $nt = scalar(@packages);
    $nb = $nt - $ns - $nf;

    if ($nf == 0) {
        $face = ":-)";
    } elsif ($ns == 0) {
        $face = ":-(";
    } elsif ($ns > $nf) {
        $face = ":-}";
    } elsif ($nf > $ns) {
        $face = ":-{";
    } else {
        $face = ":-|";
    }

    qprint "Build Summary:  $ns Successful    $nf Failed    $nb Not Built    $nt Total    $face\n";
    if ($nf) {
        foreach $pkg (@failed_pkgs) {
            if ($failure->{$pkg}{MESSAGE}) {
                eprint "Package \"$pkg\" failed:  $failure->{$pkg}{MESSAGE}.\n";
            } else {
                eprint "Package \"$pkg\" failed; reason unknown.  Check the log to see what went wrong.\n";
            }
        }
    }
}

# main() here is basically the same as main() in C
sub
main
{
    # Set up the basic variables
    $progname = "buildtool";
    $version = "2.1";
    umask 022;
    $ret = AVALON_SUCCESS;

    # No input.
    open(STDIN, "</dev/null");

    # See the Getopt::Long man page for details on the syntax of this line
    @valid_opts = ("h|help", "v|version", "d|debug", "q|quiet", "Q|really-quiet|silent", "D|dir|tree=s",
                   "l|log=s", "P|parallel:s", "t|target=s", "p|prod|product|prodfile=s", "C|cflags=s",
                   "T|tag=s", "nocache", "clean:s", "U|user=s");
    Getopt::Long::Configure("no_getopt_compat", "bundling", "no_ignore_case");
    Getopt::Long::GetOptions(@valid_opts);

    #
    # Options Handling
    #
    if ($opt_v) {
        # Do not edit this variable.  It is updated automatically by CVS when you commit
        my $rcs_info = 'CVS Revision $Revision: 1.155 $ created on $Date: 2001/08/21 22:47:40 $ by $Author: mej $ ';

        $rcs_info =~ s/\$\s*Revision: (\S+) \$/$1/;
        $rcs_info =~ s/\$\s*Date: (\S+) (\S+) \$/$1 at $2/;
        $rcs_info =~ s/\$\s*Author: (\S+) \$ /$1/;
        print "\n";
	print "$progname $version by Michael Jennings <mej\@eterm.org>\n";
        print "Copyright (c) 2000, Michael Jennings and VA Linux Systems, Inc.\n";
        print "  ($rcs_info)\n";
        print "\n";
	return AVALON_SUCCESS;
    }
    if ($opt_h) {
	&print_usage_info();   # Never returns
    }
    &debug_set($opt_d);
    $GLOBAL_LOG = 0;
    open(STDERR, ">&STDOUT");
    if ($opt_l) {
        if (!open(LOGFILE, ">$opt_l")) {
            eprint "Unable to open $opt_l -- $!\n";
        } else {
            $GLOBAL_LOG = \*LOGFILE;
            #system("chattr +S $opt_l");  # Try to set sync on the log file, fail silently
            open(STDOUT, ">&LOGFILE");
            select LOGFILE; $| = 1;
        }
    }
    select STDOUT; $| = 1;
    $verbosity = ($opt_Q ? 0 : ($opt_q ? 1 : 2));
    $global_user = $opt_U;
    $global_tree = $opt_D;
    $global_tag = $opt_T;
    &pkgvar_cleanup($opt_clean);
    &pkgvar_target($opt_t);

    # Figure out parallelization stuff
    if (defined($opt_P)) {
        $num_cpus = &count_cpus();
        if ($opt_P) {
            my ($mult, $add) = (1, 0);

            $opt_P =~ m/^(?:[Xx]([\d.]+))?([-+][\d.]+)?$/;
            ($mult, $add) = ($1, $2);
            $num_cpus = $num_cpus * ($mult ? $mult : 1) + ($add ? $add : 0);
        }
    } else {
        $num_cpus = 1;
    }
    dprint "Using $num_cpus parallel process(es).\n";

    # Try to parse the product name we were given into a name or a name-version combo
    if ($opt_p) {
        $prod = $opt_p;
    } else {
        $prod = $prodname = &basename(&getcwd());
    }
    &pkgvar_buildroot($ENV{AVALON_BUILDROOT});

    if (! $opt_clean) {
        $opt_clean = "build";
    }
    dprint "Cleaning:  $opt_clean\n";

    #
    # Signal handling
    #
    $SIG{HUP} = 'IGNORE';
    $SIG{INT} = \&handle_signal;
    $SIG{TERM} = \&handle_signal;
    $SIG{QUIT} = \&handle_fatal_signal;
    $SIG{ILL} = \&handle_fatal_signal;
    $SIG{ABRT} = \&handle_fatal_signal;
    $SIG{FPE} = \&handle_fatal_signal;
    $SIG{SEGV} = \&handle_fatal_signal;
    $SIG{BUS} = \&handle_fatal_signal;
    $SIG{TSTP} = 'IGNORE';
    $SIG{TTIN} = 'IGNORE';
    $SIG{TTOU} = 'IGNORE';

    #
    # Environment modifications
    #
    $ENV{MAKE} = "make";  # Make sure we don't parallel build, because it doesn't work.
    $ENV{CFLAGS} = ($opt_C ? $opt_C : "-O2 -march=pentiumpro");
    delete $ENV{LD_RUN_PATH};  # Don't hard code any RPATH's into binaries
    delete $ENV{LD_LIBRARY_PATH};  # Make glibc happy
    $ENV{PATH} = "/usr/build/bin:/usr/local/build/bin:/usr/lib/qt-1.45/bin:/usr/lib/qt-2.1.0/bin"
                  . ":/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/kerberos/sbin"
                  . ":/usr/kerberos/bin:.";

    # Parse the product definition files to figure out what the heck we need to build. :)
    if (! &parse_prod_file($prod, 0, 0)) {
        if (! &parse_product_entry($prod)) {
            eprint "$prod does not seem to be a valid product or product entry.\n";
            eprint "Perhaps you made a typo?\n";
            return AVALON_BAD_PRODUCT;
        }
    }
    return AVALON_BAD_PRODUCT if (!scalar(@packages));

    dprint "Products to be built (", scalar(@packages), " packages):  ", join(" ", @products), "\n";
    if ($num_cpus > 1) {
        $ret = &parallel_build(@packages);
    } else {
        $ret = &build_product(@packages);
    }
    &summarize_failures();
    qprint "Build completed.  (${\(&get_timestamp())})\n";
    close($GLOBAL_LOG) if ($GLOBAL_LOG);
    return $ret;
}

exit &main();
