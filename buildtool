#!/usr/bin/perl -w
#
# buildtool -- Product Build Management Tool
# 
# Copyright (C) 2000-2001, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: buildtool,v 1.131 2001/04/07 02:22:39 mej Exp $
#

# Include the Perl Modules we need
require POSIX;
require Getopt::Long;
use Cwd;
use Avalon::Util;
use Avalon::Srctool;

# Print usage information
sub
print_usage_info
{
    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   buildtool [ options ]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -b --build <stage>               Stop building after a particular stage (see below)\n";
    print "    -p --product --package <name>    Specify the product or package to build\n";
    print "    -q --quiet                       Be somewhat quiet.  Simply gives basic progress info\n";
    print "    -Q --really-quiet --silent       Be very quiet.  Only errors are reported\n";
    print "    -D --dir <directory>             Specify \"directory\" as the base directory for the build\n";
    print "    -f --force                       Ignore errors, build as much as possible\n";
    print "    -l --log <logfile>               Specify a log file to send informational output to\n";
    print "    -P --parallel [expr]             Parallelize the build process based on the number of CPU's\n";
    print "    -t --target <arch>               Tell rpm to build for a particular target architecture\n";
    print "    -C --cflags <flags>              Specify the \$CFLAGS variable to use for building\n";
    print "       --tree <repository>           Specify the repository to use (overrides all product files)\n";
    print "       --tag <tag>                   Specify a tag to use (overrides all product files)\n";
    print "       --nocache                     Do not scan the cache (use with care)\n";
    print "       --clean                       Clean up RPM and buildroot directories when done\n";
    print "\n";
    print "The stages and their abbreviations (for use with the -b option) are:\n";
    print "  bootstrap (s), component (c), build (b), package accumulation (p)\n\n";
    print "The default is \"-bp\" if you do not specify otherwise.\n\n";
    exit(AVALON_SUCCESS);
}

# Normal print (i.e., don't print this in -q or -Q mode)
sub
nprintf
{
    if ($GLOBAL_LOG || $verbosity >= 2) {
        printf @_;
    }
}
sub
nprint
{
    if ($GLOBAL_LOG || $verbosity >= 2) {
        print @_;
    }
}

# Quiet print (i.e., print in -q mode but not in -Q mode)
sub
qprintf
{
    if ($GLOBAL_LOG || $verbosity >= 1) {
        printf @_;
    }
}
sub
qprint
{
    if ($GLOBAL_LOG || $verbosity >= 1) {
        print @_;
    }
}

# Count CPU's for purposes of parallelization
sub
count_cpus
{
    my $cpus;
    my @lines;
    local *CPU;

    open(CPU, "/proc/cpuinfo") || return 1;
    @lines = <CPU>;
    close(CPU);
    @lines = grep(/^processor/, @lines);
    $cpus = $#lines + 1;
    dprint "Found $cpus processors.\n";
    return ($cpus >= 1 ? $cpus : 1);
}

# Spawn a child buildtool
sub
spawn_cmd
{
    my ($pkg, $logfile) = @_;
    my $pid;

    do {
        if ($pid = fork()) {
            # Parent -- return PID
            nprint "Spawned child process $pid to build $pkg (log file is $logfile)\n";
            return $pid;
        } elsif (defined $pid) {
            # Child -- reset state as needed and jump to build process
            $opt_f = 0;
            $verbosity = 0;
            $slave = 1;
            $master = 0;
            $opt_master = 0;
            close $GLOBAL_LOG if ($GLOBAL_LOG);
            open(STDOUT, ">/dev/null");
            open(STDIN, "</dev/null");
            if (!open(LOGFILE, ">$logfile")) {
                eprint "Unable to open $logfile -- $!\n";
            } else {
                $GLOBAL_LOG = \*LOGFILE;
                #system("chattr +S $logfile");  # Try to set sync on the log file, fail silently
                open(STDERR, ">&LOGFILE");
                select LOGFILE; $| = 1;
            }
	    # Reduce the package list to just one package.  Then we can proceed
	    # without having to incur the performance penalty of an exec().
            @packages = ($pkg);
            @failed_pkgs = ();
            &build_process();
            close(LOGFILE) if ($GLOBAL_LOG);
            exit (AVALON_SUCCESS);
        } elsif ($! !~ /No more processes/ && $! !~ /Resource temporarily unavailable/) {
            &fatal_error("fork() failed -- $!\n");
        }
        # Temporary failure
        dprint "Failed temporarily -- $!\n";
        sleep 5;
    } while (1);
}

# Translate abbreviated variable names into their canonical forms
sub
get_var_name
{
    my $var = $_[0];

    $var =~ tr/[a-z]/[A-Z]/;

    # Commonly shortened variables
    if ($var =~ /^REV/ || $var eq "TAG") {
        $var = "REVISION";
    } elsif ($var =~ /^REL/) {
        $var = "RELEASE";
    } elsif ($var =~ /^VER/) {
        $var = "VERSION";
    } elsif ($var =~ /^SPEC/) {
        $var = "SPECFILE";
    } elsif ($var =~ /^DIR/) {
        $var = "DIRS";
    } elsif ($var =~ /^PATCH/) {
        $var = "PATCHES";
    } elsif ($var =~ /^LOC/) {
        $var = "LOCATIONS";
    } elsif ($var =~ /^DESC/) {
        $var = "DESCRIPTION";
    } elsif ($var =~ /^SOURCE/) {
        $var = "SRCS";
    } elsif ($var =~ /^MACRO/) {
        $var = "MACROS";
    }
    return $var;
}

# Translate a package type into its default STAGES variable
sub
get_package_stages
{
    my $type = $_[0];

    if ($type eq "srpm") {
        return "scbp";
    } elsif ($type eq "tar") {
        return "sbp";
    } elsif ($type eq "rpm") {
        return "sbp";
    } elsif ($type eq "module") {
        return "scbp";
    } elsif ($type eq "image") {
        return "s";
    } else {
        return "scbp";
    }
}

# Supply the branch tag prefix
sub
branch_tag_prefix
{
    return "VA-";
}

# Convert a package name/version to a release tag
sub
pkg_to_release_tag
{
    my ($pkg_name, $pkg_version) = @_;
    my $tag;

    $tag = "$pkg_name-$pkg_version";
    $tag =~ tr/[a-z]/[A-Z]/;
    $tag =~ s/[^-A-Z0-9]/_/g;
    return $tag;
}

# Convert a package name/version to a branch tag
sub
pkg_to_branch_tag
{
    my ($pkg_name, $pkg_version) = @_;
    my $tag;

    $tag = &branch_tag_prefix() . &pkg_to_release_tag($pkg_name, $pkg_version);
    return $tag;
}

# Find the proper location within the image for an output file
sub
place_file
{
    my ($pkg, $file) = @_;
    my $found = 0;

    dprint "place_file(\"$pkg\", \"$file\") called.\n";
    return 0 if (!defined($pkgs->{$pkg}{LOCATIONS}));

    foreach $location (split(",", $pkgs->{$pkg}{LOCATIONS})) {
        my ($regex, $stop, $dest, $image, $subdir);

        # Format is:  /regexp/.path  where . is some delimiter character that
        # tells us whether to check other locations or stop once we match
	# (':' to continue looking for matches, or '=' to stop if a match is found).
        dprint "Testing location \"$location\"\n";
        if ($location !~ m/^\/([^\/]+)\/(.)(\S+)$/) {
            eprint "Location specifier \"$location\" is invalid.\n";
            next;
        }
        ($regex, $stop, $dest) = ($1, $2, $3);
        if ($stop eq "!") {
            # A negative match test.  If we get a match, don't accept it.
            next if ($file =~ $regex);
        } else {
            # No match.  Try next location.
            next if ($file !~ $regex);
        }
        dprint "Match found.\n";

	# Grab the first part of the destination path, make sure it's an image module
        ($image = $dest) =~ s/^([^\/]+)\/.*$/$1/;
        if (!defined($pkgs->{$image}{TYPE}) || ($pkgs->{$image}{TYPE} ne "image")) {
            qprint "Warning:  Destination \"$dest\" is not a package of type \"image\".\n";
        }

	# If the destination does not contain a filename, add the filename portion of
	# $file to the directory path in $dest.  The destination could be used to rename
	# a file, however; that's why this check is in place.
        if (substr($dest, -3, 3) ne substr($file, -3, 3)) {
            my $tmp;

            ($tmp = $file) =~ s/^.*\/([^\/]+)$/$1/;
            $dest = "$dest/$tmp";
        }
	# If it exists, delete it
        if (-e $dest) {
            &nuke_tree($dest);
        }
	# Then link it
        dprint "Linking $dest to $file\n";
        if (!link($file, $dest)) {
            &fail_package($pkg, "package accumulation", "Unable to hard-link to $file from $dest -- $!");
            return $found;
        }
        $found++;
	# If the stop character is '=', stop checking for matches for this package.
	# If it's ':' (actually, any other character than '='), keep looking for matches.
        last if ($stop eq "=");
        dprint "Non-exclusive match.  Continuing on....\n";
    }
    return $found;
}

# Do the initial directory/file creation stuff.  Used to be in the
# bootstrap stage, but it's not parallel-safe.
sub
initial_setup
{
    my @contents;

    # Create the build directory if it doesn't exist.  If we can't, die.
    if (! -d "$builddir") {
        if (!mkdir("$builddir", 0755)) {
            &fatal_error("Cannot create $builddir -- $!\n");
        }
    }

    # Create the RPM directories also.  Same deal as above.
    foreach $dir ("BUILD", "SRPMS", "RPMS", "SPECS", "SOURCES") {
        if (! -d "$builddir/$dir") {
            mkdir("$builddir/$dir", 0755) || &fatal_error("Cannot create $builddir/$dir -- $!\n");
        }
    }

    # If the build root exists, get rid of it, then make a new (empty) one.
    if (-d $buildroot) {
        nprint "Buildroot $buildroot exists.  I am removing it.\n";
        &nuke_tree($buildroot);
    }
    mkdir($buildroot, 0775);

    chdir("$builddir");

    # Pre-scan all the binary RPM's for future use in possibly parallel processes.  We need
    # to know what SRPM each binary came from, because some (lame) packages change the base name.
    if (! $opt_nocache) {
        nprint "Updating state information....\n";
        dprint "Scanning binary RPM's in $builddir/RPMS for their corresponding SRPM's.\n";
        @contents = glob("$builddir/RPMS/*/*.rpm");
        foreach $rpm (@contents) {
            dprint "Checking $rpm\n";
            $srpm_of_rpm{$rpm} = `rpm -qp $rpm --queryformat \"%{SOURCERPM}\"`;
        }
    }
}

# What to do if a package fails
sub
fail_package
{
    my ($pkg, $stage, $msg) = @_;

    push @failed_pkgs, $pkg;
    $failure->{$pkg}{STAGE} = $stage;
    if ($msg) {
        ($failure->{$pkg}{MESSAGE} = $msg) =~ s/\.+$//;
        eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage:  $failure->{$pkg}{MESSAGE}.\n";
    } else {
        eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage.\n";
    }
    exit(AVALON_PACKAGE_FAILED) if (! $opt_f);
    @packages = grep($_ ne $pkg, @packages);
    return 0;
}

# Locate the product file for a particular product
sub
find_product_file
{
    my ($prodname, $prodver) = @_;
    my $prod = ($prodver ? "$prodname-$prodver" : $prodname);
    my $prodfile;
    my @contents;
    local *PRODFILE;

    dprint "find_product_file($prodname, ", ($prodver ? $prodver : ""), ")\n";
    if ($prodver) {
        # If it already has the .prod extension, and it exists, return that
        if ($prod =~ /\.prod$/) {
            if (-f $prod) {
                return $prod;
            } elsif (-f "$proddir/$prod") {
                # Just needed a path
                return "$proddir/$prod";
            } else {
                $prod =~ s/\.prod$//;
            }
        } else {
            # It has no .prod extension.  Let's try just giving it one.
            if (-f "$prod.prod") {
                return "$prod.prod";
            } elsif (-f "$proddir/$prod.prod") {
                # Extension and path needed...
                return "$proddir/$prod.prod";
            }
        }
    }

    # Try just the product name
    if ($prodname =~ /\.prod$/) {
        if (-f $prodname) {
            return $prodname;
        } elsif (-f "$proddir/$prodname") {
            # Just needed a path
            return "$proddir/$prodname";
        } else {
            $prodname =~ s/\.prod$//;
        }
    } else {
        # It has no .prod extension.  Let's try just giving it one.
        if (-f "$prodname.prod") {
            return "$prodname.prod";
        } elsif (-f "$proddir/$prodname.prod") {
            # Extension and path needed...
            return "$proddir/$prodname.prod";
        }
    }

    # Well, rats.  We've eliminated the simple cases.  Time to get creative.
    # Find all the product files and search each one for a match.
    foreach $prodfile (sort(&grepdir(sub {/\.prod$/}, $proddir))) {
        my (@lines, @names, @versions);

        dprint "find_product_file():  Searching product file $prodfile for a match...\n";
        open(PRODFILE, "$proddir/$prodfile") || next;
        @lines = <PRODFILE>;
        @names = grep($_ =~ /^\s*name\s*:/i, @lines);
        @versions = grep($_ =~ /^\s*ver(sion)?\s*:/i, @lines);
        if (grep($_ =~ /$prodname/, @names) && grep($_ =~ /$prodver/, @versions)) {
            # Found it.
            dprint "find_product_file():  Match found!\n";
            return "$proddir/$prodfile";
        }
    }

    # One last chance.  Product directory with a .prod file.
    if (-s "$builddir/$prodname/.prod") {
	return "$builddir/$prodname/.prod";
    }

    # Give up.  It doesn't exist.
    return 0;
}

# Parse a product entry line from a file or the command line
sub
parse_product_entry
{
    my ($line, $prodname, $prodver) = @_;
    my ($type, $name, $arch, $module, $filename, $pkgvar, $var, $val);
    my $type_guess = 0;
    my (%pkgvars, @inp);
    my $prod;

    if ($prodname) {
        if ($prodver) {
            $prod = "$prodname-$prodver";
        } else {
            $prod = $prodname;
            $prodver = 0;
        }
    } else {
        $prod = $prodname = $prodver = 0;
    }
    dprint "parse_product_entry(\"$line\", \"$prodname\", \"$prodver\")\n";
    undef %pkgvars;
    undef $module;
    undef $type;
    # For now, the line we're passed is whitespace-delimited.
    @inp = split(/\s+/, $line);
    dprint "Input is \"", join("\" \"", @inp), "\"\n";
    if ($inp[0] =~ /^(prod|mod|s?rpm|tar|tbz|tgz|ima?ge?)[^:]*:/) {
        # Line begins with <type>:<name>, like "module:Eterm"
        ($type, $name) = split(":", $inp[0]);
        $type =~ tr/[A-Z]/[a-z]/;
        if (! $name && $inp[1]) {
            # If there's no name, but there's something after the type, they probably
            # just put in some extra whitespace.  Grab it and shift everything left.
            $name = $inp[1];
            shift @inp;
        }
        dprint "parse_product_entry():  Found type \"$type\" and name \"$name\"\n";
        if ($type =~ /^prod/) {
            $type = "product";
        } elsif ($type =~ /^mod/) {
            $type = "module";
        } elsif ($type =~ /^srpm/) {
            $type = "srpm";
        } elsif ($type =~ /^rpm/) {
            $type = "rpm";
        } elsif ($type =~ /^t(ar|bz|gz)/) {
            $type = "tar";
        } elsif ($type =~ /^image/) {
            $type = "image";
        } else {
            eprint "$type is not a valid package type.  I'll try to guess the correct one.\n";
            $type = 0;
        }
    }
    if (! $type) {
        # They didn't tell us the type, so let's guess educatedly.
        $type_guess = 1;
        ($name = $inp[0]) =~ s/^\w*://;
        dprint "Guessing type of \"$name\"\n";
        if ($name =~ /src\.rpm$/) {
            # Name ends with src.rpm.
            $type = "srpm";
        } elsif ($name =~ /\.rpm$/) {
            # Name ends with .rpm but it's not a source RPM. 
            $type = "rpm";
        } elsif ($name =~ /\.(t?gz|Z|bz2)$/) {
            # Name ends with .tgz, .Z, .bz2, etc.  Tarball.
            $type = "tar";
        } else {
            my @contents = ();

            # Check to see if there is a product file for it
            @contents = &grepdir(sub {/^$name-?.*\.prod$/}, $proddir);
            # Product files win over modules because they contain more detail
            # about the package and are more likely to succeed.
            if ($#contents >= 0) {
                $type = "product";
                ($name = $contents[0]) =~ s/\.prod$//;
            } else {
                $type = "module";
            }
        }
    }
    if ($name =~ /\/.+$/) {
	# If the name contains a / and at least *something* after it, split out the module name
	# (the part before the /) and the actual package name (the part after the /).  Otherwise,
	# assume that the module name is exactly the same as the package name.
        ($module = $name) =~ s/^([^\/]+)(.+)$/$1/;
        $name =~ s/^(.*)\/([^\/]+)$/$2/;
    } else {
        $module = $name;
    }
    # The rest of the line is whitespace-delimited sets of var=value
    shift @inp;
    dprint "Input is now \"", join("\" \"", @inp), "\"\n";
    foreach $varval (@inp) {
        ($var, $val) = split("=", $varval, 2);
        $var = &get_var_name($var);
	# Store them in %pkgvars for now; we'll move them later.
        $pkgvars{$var} = $val;
    }
    # Some package types require special treatment at this point.
    if ($type eq "product") {
        my ($pname, $pver);

        # Separate name and version
        if ($pkgvars{VERSION}) {
            ($pname, $pver) = ($name, $pkgvars{VERSION});
            $name = "$pname-$pver";
        } elsif ($name =~ /^(\S+)-((?:\d|us|a|alpha|b|beta)[^-]+)$/) {
            ($pname, $pver) = ($1, $2);
        } else {
            $pname = $name;
            $pver = 0;
        }

        # Recursively convert products into their component packages
        $prods->{$name}{PRODUCT} = $prod;
        dprint "parse_product_entry():  Parent product of $name is $prod.\n";
        if (! &parse_prod_file($pname, $pver, $prod)) {
            dprint "parse_product_entry():  parse_prod_file($pname, $pver, $prod) failed.\n";
            undef $prods->{$name}{PRODUCT};
            if ($type_guess) {
                # If this was a guess, a potential infinite loop exists if we try
                # to parse the product entry again.  So just punt at this point.
                dprint "parse_product_entry() returning 0.\n";
                return 0;
            } else {
                my $tmp;

                $line =~ s/^[^:]+://;
                $tmp = &parse_product_entry($line, $prodname, $prodver);
                dprint "parse_product_entry():  parse_product_entry(\"$line\", $prodname, $prodver) returned $tmp, so I will to.\n";
                return $tmp;
            }
        }
        dprint "parse_product_entry():  parse_prod_file($pname, $pver, $prod) succeeded, so I'm returning 1.\n";
        return 1;
    }

    dprint "parse_product_entry():  Module is $module, name is $name\n";
    # Add defaults for stuff that is required
    if ($type eq "module" || $type eq "image") {
        # Anything needed here?
    } elsif ($type eq "tar") {
        $filename = "$module/$name";
    } elsif ($type eq "srpm" || $type eq "rpm") {
        if ($name =~ /^(\S+)\.(\w+)\.rpm$/) {
            ($name, $arch) = ($1, $2);
        } else {
            $arch = ($type eq "srpm" ? "src" : "i386");
        }
        if (!defined $pkgvars{RELEASE}) {
            if ($name !~ /^\S+-[^-]+-[^-]+$/) {
                eprint "I wasn't given enough information about the $name package in $prodfile.  For RPM/SRPM\n";
                eprint "packages, the version and release information must be specified as variables or\n";
                eprint "embedded in the package name.  I'm going to have to skip that one.\n";
                return 0;
            } else {
                ($tmp = $name) =~ s/^\S+-[^-]+-//;
                $name =~ s/-[^-]+$//;
                $pkgvars{RELEASE} = $tmp;
            }
        }
        if (!defined $pkgvars{VERSION}) {
            if ($name !~ /^\S+-[^-]+$/) {
                eprint "I wasn't given enough information about the $name package in $prodfile.  For RPM/SRPM\n";
                eprint "packages, the version and release information must be specified as variables or\n";
                eprint "embedded in the package name.  I'm going to have to skip that one.\n";
                return 0;
            } else {
                ($tmp = $name) =~ s/^(\S+)-([^-]+)$/$2/;
                $name =~ s/^(\S+)-([^-]+)$/$1/;
                $pkgvars{VERSION} = $tmp;
            }
        }
        $filename = "$name-$pkgvars{VERSION}-$pkgvars{RELEASE}.$arch.rpm";
    }

    # Check for duplicate packages.
    if (grep($_ eq $name, @packages)) {
        if ($type eq "rpm" && ($pkgs->{$name}{TYPE} eq "srpm" || $pkgs->{$name}{TYPE} eq "tar")) {
            dprint "Adding $module/$filename as a binary package for $name\n";
            push(@{$pkgs->{$name}{BINS}}, "$module/$filename");
            $pkgs->{$name}{STAGES} =~ s/c//;
        } else {
            eprint "I already have $name as a $pkgs->{$name}{TYPE} package in $pkgs->{$name}{PRODUCT}.\n";
            eprint "I will ignore the duplicate entry found in $prodname $prodver\n";
        }
        return 0;
    }
    # Now that we've got the name/version/release in their final forms, set up the data structures.
    $pkgs->{$name}{TYPE} = $type;
    $pkgs->{$name}{MODULE} = $module;
    $pkgs->{$name}{FILENAME} = ($filename ? $filename : $module);
    dprint "parse_product_entry():  New package:  $name (module $pkgs->{$name}{MODULE}, "
        . "filename $pkgs->{$name}{FILENAME}) is a $pkgs->{$name}{TYPE}\n";
    foreach $pkgvar (keys %pkgvars) {
        if ($pkgvars{$pkgvar} !~ /^$/) {
            $pkgs->{$name}{$pkgvar} = $pkgvars{$pkgvar};
            dprint "parse_product_entry():  Added variable $pkgvar to package $name with value \"$pkgs->{$name}{$pkgvar}\"\n";
        }
    }
    # Go through each propogated variable.  If there is no assigned value for that
    # variable for the current package, see if it has a value for the parent product
    # of that package.  If not, try the parent product of that product, and continue
    # going back through the product hierarchy until we find a value or run out or products.
    #
    # FIXME:  Perhaps these shouldn't be hard-coded.  Perhaps we should keep a list of
    #         all package/product variables we've encountered thus far and iterate
    #         through those only, since we're guaranteed no others will have a fallback.
    foreach $pkgvar ("REVISION", "LOCATIONS", "RPMCMD", "TAR", "ZIP", "STAGES", "CVSROOT", "ARCH", "MACROS") {
        if (! $pkgs->{$name}{$pkgvar}) {
            my ($pkg, $val) = undef;

            dprint "parse_product_entry():  No value for the variable $pkgvar for $name.\n";
            for ($pkg = $prod; $pkg; $pkg = $prods->{$pkg}{PRODUCT}) {
                dprint "parse_product_entry():  Checking $pkg for $pkgvar\n";
                if ($prods->{$pkg}{$pkgvar}) {
                    $val = $prods->{$pkg}{$pkgvar};
                    dprint "parse_product_entry():  Found fallback value $val in product $pkg\n";
                    last;
                }
            }
            if ($val) {
                $pkgs->{$name}{$pkgvar} = $val;
            }
        }
    }
    # This goes here to avoid the fallback mechanism above.
    if (defined($pkgs->{$name}{REVISION}) && $pkgs->{$name}{REVISION} =~ /^head$/i) {
        undef $pkgs->{$name}{REVISION};
    }
    # If we haven't been told which stages we want, use the defaults.
    if (!defined $pkgs->{$name}{STAGES}) {
        $pkgs->{$name}{STAGES} = &get_package_stages($type);
    }
    # Add the package name to the list of packages
    push @packages, $name;
    # Set the parent product name
    $pkgs->{$name}{PRODUCT} = ($prod ? $prod : "unknown-product");
    dprint "parse_product_entry():  Parent product of $name set to $prod.  I'm done, returning 1.\n";
    return 1;
}

# Parse product definition files recursively to establish
# all the products we need to work with and what packages or
# other products compose them.
sub
parse_prod_file
{
    my ($prodname, $prodver, $parent_prod) = @_;
    my ($prodfile, $skip_to_name, $skip_to_next_ver, $found, $line);
    my $prod = $prodname;
    local *PROD;

    # First, find the product file and open it.
    dprint "parse_prod_file($prodname, ", ($prodver ? $prodver : ""), ", ", ($parent_prod ? $parent_prod : ""), ")\n";
    if (!($prodfile = &find_product_file($prodname, $prodver))) {
        dprint "parse_prod_file():  find_product_file() failed.  Returning 0.\n";
        return 0;
    }
    dprint "parse_prod_file():  Found product file \"$prodfile\"\n";
    open(PROD, "$prodfile") || return 0;

    # Ignore everything until we encounter a product name
    ($skip_to_name, $skip_to_next_ver, $found) = (1, 0, 0); 
    while (<PROD>) {
        chomp($line = $_);
        dprint "parse_prod_file():  Parsing $prodfile:  \"$line\"\n";
        $line =~ s/^\s*(.*\S)\s*$/$1/;  # Strip leading and trailing whitespace
        next if ($line =~ /^\#/ || $line !~ /\S/);
        next if ($skip_to_name && $line !~ /^name\s*:/i);
        next if ($skip_to_next_ver && $line !~ /^ver(sion)?\s*:/i);
        if ($line =~ /^name\s*:/) {
            if ($skip_to_name) {
                $line =~ s/^[^:]+:\s*//;
                if ($line eq $prodname) {
                    dprint "parse_prod_file():  Found product name match\n";
                    $skip_to_name = 0;
                    $skip_to_next_ver = 1;
                    next;
                }
            } else {
                # New product.  Time to quit.
                last;
            }
        } elsif ($line =~ /^ver(sion)?\s*:/) {
            if ($skip_to_next_ver) {
                $line =~ s/^[^:]+:\s*//;
                next if ($prodver && $line ne $prodver);
                # Found it!
                if ($prodver) {
                    dprint "parse_prod_file():  Found product version match.  Time to parse the product.\n";
                } else {
                    dprint "parse_prod_file():  No product version given.  Using first entry:  $line\n";
                    $prodver = $line;
                }
                $prod = "$prodname-$prodver";
                ($found, $skip_to_next_ver) = (1, 0);
                push @products, $prod;
                if ($parent_prod) {
                    $prods->{$prod}{PRODUCT} = $parent_prod;
                    dprint "parse_prod_file():  Parent product of $prod is $prods->{$prod}{PRODUCT}.\n";
                } elsif ($prods->{$prodname}{PRODUCT}) {
                    $prods->{$prod}{PRODUCT} = $prods->{$prodname}{PRODUCT};
                    dprint "parse_prod_file():  Parent product of $prod is $prods->{$prod}{PRODUCT}.\n";
                }
                next;
            } else {
                # New version.  Time to quit.
                last;
            }
        } else {
            dprint "parse_prod_file():  Checking \"$line\" for product variables.\n";
            if ($line !~ /^(prod|mod|s?rpm|ima?ge?)/i && $line =~ /^([^ \t:]+)\s*:\s*(\S+.*)$/) {
                my ($var, $val);

                # The regexp above should only match var:value (a product variable)
                ($var, $val) = ($1, $2);
                $var = &get_var_name($var);
                dprint "parse_prod_file():  Product variable for $prod:  $var -> $val\n";
                $prods->{$prod}{$var} = $val;
            } elsif (!($skip_to_name || $skip_to_next_ver)) {
                my $tmp;

                dprint "parse_prod_file():  Calling parse_product_entry()...\n";
                $tmp = &parse_product_entry($line, $prodname, $prodver);
                dprint "parse_prod_file():  parse_product_entry() returned $tmp\n";
            }
        }
    }
    dprint "parse_prod_file():  Closing file $prodfile and returning $found\n";
    close(PROD);
    return ($found);
}

# Use revtool to download a package from the master repository
sub
fetch_package
{
    my $cmd = $_[0];
    my ($err, $msg, $line) = undef;
    local *REVTOOL;

    dprint "About to run $cmd\n";
    if (!open(REVTOOL, "$cmd 2>&1 |")) {
        $err = AVALON_COMMAND_FAILED;
        $msg = "Execution of \"$cmd\" failed -- $!";
        last;
    }
    while (<REVTOOL>) {
        chomp($line = $_);
        nprint "$line\n";
        next if ($line =~ /^\[debug:/);
        # Check the output for errors
        if ($line =~ /^revtool:\s*Error/) {
            ($msg = $line) =~ s/^revtool:\s*Error:\s*//;
        }
    }
    close(REVTOOL);
    $err = $?;
    dprintf "\"$cmd\" returned $err (%d)\n", $err >> 8;
    return ($err >> 8, $msg);
}

# Build package files
sub
build_pkgs
{
    my ($pkg, $filename) = @_;
    my ($cmd, $prog, $line, $target, $out_files, $rpmrc);
    my ($err, $msg, $srpm) = (0, 0, 0);
    local *PKGTOOL;

    $prog = ($pkgs->{$pkg}{RPMCMD} ? $pkgs->{$pkg}{RPMCMD} : "rpm");
    if ($pkgs->{$pkg}{MACROS}) {
        my @macro_list = split(",", $pkgs->{$pkg}{MACROS});
        my $macro;

        foreach $macro (@macro_list) {
            my ($name, $value) = split(":", $macro);

            $prog .= " --define \"$name $value\"";
        }
    }
    $rpmrc = "$buildroot/$pkg-rpmrc";
    # Create the rpmrc and rpmmacros files if they don't exist
    &create_rpm_files($pkg) if (! -s $rpmrc);
    $target = ($main::target ? " --target=$main::target" : ($pkgs->{$pkg}{ARCH} ? " --target=$pkgs->{$pkg}{ARCH}" : ""));
    $prog = "-P '$prog$target'";
    $cmd = "$pkgtool $prog -b -R \"/usr/lib/rpm/rpmrc:$rpmrc\" --root \"$buildroot/$pkg-root\" ";
    if ($pkgs->{$pkg}{TYPE} eq "tar") {
        $cmd .= "-p $filename";
    } else {
        $cmd .= "-s $filename";
    }
    if ($pkgs->{$pkg}{TAGFILE}) {
        $cmd .= " --tagfile $pkgs->{$pkg}{TAGFILE}";
    }
    # Run pkgtool with above parameters to build the package
    dprint "About to run \"$cmd\"\n";
    if (!open(PKGTOOL, "$cmd </dev/null 2>&1 |")) {
        return (1, "Execution of \"$cmd\" failed -- $!", undef);
    }
    $err = 0;
    while (<PKGTOOL>) {
        chomp($line = $_);
        nprint "$line\n";
        if ($line =~ /^pkgtool:\s+Error:\s+(.*)$/) {
            $msg = $1;
        } elsif ($line =~ /^Package files generated:\s+(.*)$/) {
            $out_files = $1;
        }
    }
    close(PKGTOOL);
    dprint "pkgtool returned $?\n";
    if ($? != 0 && $err == 0) {
        $err = $?;
        $msg = "Unhandled RPM build error" if (! $msg);
    }

    # Record output files for later use
    if ($out_files) {
        $pkgs->{$pkg}{OUTFILES} = $out_files;
        if ($out_files =~ /src\.rpm/) {
            ($srpm = $out_files) =~ s/^(.*\s+)?(\S+src\.rpm)(\s+.*)?$/$2/;
        }
    }
    dprint "build_pkgs():  Returning $err, $msg, $srpm\n";
    return ($err, $msg, $srpm);
}

# Generate source files and patches using pkgtool
sub
gen_sources
{
    my ($pkg, $specfile) = @_;
    my ($cmd, $prog, $line, $target, $srcs, $htag, $rtag, $tar, $zip, $rpmrc);
    my ($err, $msg) = (0, 0);
    local *PKGTOOL;

    # pkgtool does all the work.  Really this routine just sets up the parameters and
    # grabs the output.  There's nothing fancy going on here at all.
    $rpmrc = "$buildroot/$pkg-rpmrc";
    &create_rpm_files($pkg) if (! -s $rpmrc);
    $prog = ($pkgs->{$pkg}{RPMCMD} ? $pkgs->{$pkg}{RPMCMD} : "rpm");
    $target = ($pkgs->{$pkg}{ARCH} ? " --target=$pkgs->{$pkg}{ARCH}" : ($main::target ? $main::target : ""));
    $prog = "-P '$prog$target'";
    $srcs = ($pkgs->{$pkg}{SRCS} ? "-o '$pkgs->{$pkg}{SRCS}'" : "");
    if ($pkgs->{$pkg}{TAR}) {
        $tar = $pkgs->{$pkg}{TAR};
        $tar = "--tar '$tar'";
    } elsif ($pkgs->{$pkg}{ZIP}) {
        $zip = "--zip '$pkgs->{$pkg}{ZIP}'";
    }
    if ($pkgs->{$pkg}{REVISION}) {
        my $btp = &branch_tag_prefix();

        ($rtag, $htag) = split(":", $pkgs->{$pkg}{REVISION});
        if (! $htag && $rtag =~ /^$btp/) {
            $htag = $rtag;
            undef $rtag;
        }
    } elsif ($pkgs->{$pkg}{VERSION}) {
        $rtag = &pkg_to_release_tag($pkg, $pkgs->{$pkg}{VERSION});
        $htag = &pkg_to_branch_tag($pkg, $pkgs->{$pkg}{VERSION});
    }
    $rtag = ($rtag ? "-r $rtag" : "");
    $htag = ($htag ? "-t $htag" : "");
    $cmd = ("$pkgtool $prog -g -R \"/usr/lib/rpm/rpmrc:$rpmrc\" --root \"$buildroot/$pkg-root\""
            . " -s $specfile -D $builddir/SOURCES $srcs $htag $rtag");
    if ($pkgs->{$pkg}{TAGFILE}) {
        $cmd .= " --tagfile $pkgs->{$pkg}{TAGFILE}";
    }
    dprint "About to run \"$cmd\"\n";
    if (!open(PKGTOOL, "$cmd </dev/null 2>&1 |")) {
        return (1, "Execution of \"$cmd\" failed -- $!", undef);
    }
    $err = 0;
    while (<PKGTOOL>) {
        chomp($line = $_);
        nprint "$line\n";
        if ($line =~ /^pkgtool:\s+Error:\s+(.*)$/) {
            $msg = $1;
        }
    }
    close(PKGTOOL);
    dprint "pkgtool returned $?\n";
    if ($? != 0 && $err == 0) {
        $err = $?;
        $msg = "Unhandled RPM build error" if (! $msg);
    }
    dprint "gen_sources():  Returning $err, $msg\n";
    return ($err, $msg);
}

# Create the rpmrc and rpmmacros files for a package
sub
create_rpm_files
{
    my $pkg = $_[0];
    my ($rpmmacros, $rpmrc, $cflags);
    local *RPMMACROS;
    local *RPMRC;

    if (defined($pkgs->{$pkg}{CFLAGS})) {
        $cflags = $pkgs->{$pkg}{CFLAGS};
        $cflags =~ s/\&/ /g;
    } else {
        $cflags = $ENV{CFLAGS};
    }

    # Create basic rpmmacros
    $rpmmacros = "$buildroot/$pkg-rpmmacros";
    open(RPMMACROS, ">$rpmmacros") || &fatal_error("Cannot create $rpmmacros -- $!\n");
    print RPMMACROS "\%_topdir           $builddir\n";
    close(RPMMACROS);

    # Create basic rpmrc
    $rpmrc = "$buildroot/$pkg-rpmrc";
    open(RPMRC, ">$rpmrc") || &fatal_error("Cannot create $rpmrc -- $!\n");
    print RPMRC "optflags:   i386 $cflags\n";
    print RPMRC "optflags:   i486 $cflags\n";
    print RPMRC "optflags:   i586 $cflags\n";
    print RPMRC "optflags:   i686 $cflags\n";
    print RPMRC "macrofiles: /usr/lib/rpm/macros:/usr/lib/rpm/\%{_target}/macros:/etc/rpm/macros.specspo:",
                "/etc/rpm/macros:/etc/rpm/\%{_target}/macros:~/.rpmmacros:$rpmmacros\n";
    close(RPMRC);
}

#
# The build process stages
#
sub
do_bootstrap_stage
{
    my ($line, $err, $msg);
    my @p;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    ### The bootstrap stage is where everything gets downloaded.  The list of packages is cycled
    ### through, and each file/module is retrieved from the master repository.  Unfortunately,
    ### this process cannot be properly parallelized because CVS isn't parallel-safe for checkouts.
    qprint "$progname:  Entering the bootstrap stage.  (${\(&get_timestamp())})\n";
    foreach $pkg (@p) {
        my @flist;

        $err = 0;
        &create_rpm_files($pkg);
        if ($pkgs->{$pkg}{STAGES} !~ /s/) {
            nprint "$progname:  Skipping bootstrap stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting bootstrap stage for the \"$pkg\" package....\n";

	# Create @flist, the list of files we need to download for this package.
	# Unless it's an SRPM plus binary RPM's, there will only be one file.
        if ($pkgs->{$pkg}{FILENAME} eq $pkgs->{$pkg}{MODULE}) {
            push(@flist, $pkgs->{$pkg}{MODULE});
        } else {
            push(@flist, "$pkgs->{$pkg}{MODULE}/$pkgs->{$pkg}{FILENAME}");
        }
        if (defined($pkgs->{$pkg}{BINS})) {
            push(@flist, @{$pkgs->{$pkg}{BINS}});
        }
	# Set the proper CVSROOT and tag for the checkout.
        if ($global_tree) {
            $cvsroot = "-D $global_tree";
        } elsif ($pkgs->{$pkg}{CVSROOT}) {
            $cvsroot = "-D $pkgs->{$pkg}{CVSROOT}";
        } else {
            $cvsroot = "";
        }
        if ($global_tag) {
            $tag = "-t $global_tag";
        } elsif ($pkgs->{$pkg}{REVISION}) {
            ($tag = $pkgs->{$pkg}{REVISION}) =~ s/^([^:]+):([^:]+)$/$2/;
            $tag = "-t $tag";
        } else {
            $tag = "";
        }

	# Check out each file using revtool
        foreach $filename (@flist) {
            last if ($err);
            dprint "Checking for $filename\n";
            # If it already exists, go on.
            if ((($pkgs->{$pkg}{TYPE} eq "module" || $pkgs->{$pkg}{TYPE} eq "image") && -d $filename)
                || (($pkgs->{$pkg}{TYPE} eq "srpm" || $pkgs->{$pkg}{TYPE} eq "rpm" || $pkgs->{$pkg}{TYPE} eq "tar") && -f $filename && -s _)) {
                nprint "$progname:  $filename already exists.  I'll assume it's the right one.\n";
                next;
            }
            $cmd = "$revtool -l $cvsroot $tag -g $filename";
            ($err, $msg) = &fetch_package($cmd);
            if ($err) {
                &fail_package($pkg, "bootstrap", $msg);
                next;
            }
            if (!((($pkgs->{$pkg}{TYPE} eq "module" || $pkgs->{$pkg}{TYPE} eq "image") && -d $filename)
                  || (($pkgs->{$pkg}{TYPE} eq "srpm" || $pkgs->{$pkg}{TYPE} eq "rpm" || $pkgs->{$pkg}{TYPE} eq "tar") && -f $filename && -s _))) {
                # If it's not there, we must've missed the error.
                $err = AVALON_PACKAGE_FAILED;
                &fail_package($pkg, "bootstrap", "Unhandled error condition");
                next;
            }
        }

        nprint "$progname:  Bootstrap stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Bootstrap stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_component_stage
{
    my ($specfile, $target, $pn, $dir, $line, $src, $tarball, $rpm);
    my ($err, $msg, $srpm) = (0, 0, 0);
    my (@contents, @tmp, @dirs, @sfiles, @srcs, @manifest);
    my @p;
    local *DIR;
    local *PKGTOOL;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    ### The component stage is where all the individual package components are obtained and put
    ### into place.  For modules, this means creating source and patch files and copying them into.
    ### For source packages, it means exploding the source package.  No other packages use this stage.
    qprint "$progname:  Entering the component stage.  (${\(&get_timestamp())})\n";

    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /c/) {
            nprint "$progname:  Skipping component stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting component stage for the \"$pkg\" package....  (${\(&get_timestamp())})\n";

        if (! chdir("$builddir/$pkgs->{$pkg}{MODULE}")) {
            &fail_package($pkg, "component", "Could not chdir into $builddir/$pkgs->{$pkg}{MODULE} -- $!");
            next;
        }

        if ($pkgs->{$pkg}{TYPE} eq "module") {
            ### If there's a makefile, skip this stage.
            if (-s "$builddir/$pkgs->{$pkg}{MODULE}/.avalon.makefile") {
                nprint "$progname:  Avalon makefile exists, skipping component stage.\n";
                next;
            }

            ### Check to see if we really need to do this stage or not.
            # Find matches to pkg-*-*.src.rpm in the SRPMS directory
            @tmp = &grepdir(sub {/^$pkg-([^-]+)-([^-]+)\.(?:no)?src\.rpm$/}, "$builddir/SRPMS");
            if (scalar(@tmp) > 0) {
                # Keep the first one
                $srpm = $tmp[0];
                # If there are more, ignore them, but warn the user
                if ($#tmp > 0) {
                    nprint "$progname:  Warning:  Multiple target SRPM's found in $pkgs->{$pkg}{MODULE}.\n";
                    nprint "$progname:  Assuming that $srpm is the correct one.\n";
                }
                # The target SRPM already exists.  Skip this stage.
                nprint "$progname:  The target SRPM for \"$pkg\" already exists ($builddir/SRPMS/$srpm).\n";
                nprint "$progname:  I'll assume it's the right one.  Component stage for \"$pkg\" is complete.\n";
                # (?:) means "don't include this as a $<num> variable"
                $srpm =~ m/^(\S+)-([^-]+)-([^-]+)\.(?:no)?src\.rpm$/;
                ($pkgs->{$pkg}{VERSION}, $pkgs->{$pkg}{RELEASE}) = ($2, $3);
                $pkgs->{$pkg}{FILENAME} = "$builddir/SRPMS/$srpm";
                $pkgs->{$pkg}{STAGES} =~ s/b//;  # Don't do build stage either.
                next;
            }

	    if (-d "F") {
		### It's an SPM.  Just copy all the files into the right places.
		$specfile = &install_spm_files($builddir);
		if (! $specfile) {
		    &fail_package($pkg, "component", "Could not copy component files into $builddir");
		    next;
		}
		$pkgs->{$pkg}{SPECFILE} = $specfile;
	    } else {
		### The next step is to find the spec file.  If it's an oddball
		### case, they better have told us what it's actually called....
		opendir(DIR, ".");
		@contents = readdir(DIR);
		closedir(DIR);
		if ($pkgs->{$pkg}{SPECFILE} && -f $pkgs->{$pkg}{SPECFILE}) {
		    # If they gave us the spec file and it exists, use that.
		    $specfile = $pkgs->{$pkg}{SPECFILE};
		    dprint "User specified a spec file:  $specfile\n";
		} else {
		    # First choice:  Exactly one file named <pkg>-<distro>.spec
		    ($pn = $prodname) =~ s/^va-//;
		    @tmp = grep($_ =~ /^($pkg-)?(va-)?$pn\.spec/, @contents);
		    if ($#tmp != 0) {
			# Second choice:  Exactly one file named <pkg>.spec
			@tmp = grep($_ =~ /^$pkg\.spec/, @contents);
			if ($#tmp != 0) {
			    # Third choice:  The first match to *.spec*
			    @tmp = grep($_ =~ /\.spec/, @contents);
			}
		    }
		    $pkgs->{$pkg}{SPECFILE} = $specfile = $tmp[0];
		    if (!defined $specfile || $specfile =~ /^$/) {
			# Our attempt to guess failed.  They need to specify the spec file in the .prod file.
			&fail_package($pkg, "component", "No spec file could be located in $pkgs->{$pkg}{MODULE}");
			next;
		    }
		}

		### Next, generate the source files
		($err, $msg) = &gen_sources($pkg, $specfile);
		if ($err) {
		    &fail_package($pkg, "component", "Creation of vendor sources failed -- $msg");
		    next;
		}
	    }
        } elsif ($pkgs->{$pkg}{TYPE} eq "srpm") {
            my $rpmrc = "$buildroot/$pkg-rpmrc";

            undef @manifest;
            $rpm = ($pkgs->{$pkg}{RPMCMD} ? $pkgs->{$pkg}{RPMCMD} : "rpm");

            ### Examine the SRPM and figure out everything it contains.
            $cmd = "$pkgtool -P \"$rpm\" -R $rpmrc -cp $pkgs->{$pkg}{FILENAME}";
            dprint "About to run \"$cmd\"\n";
            if (!open(PKGTOOL, "$cmd 2>&1 |")) {
                &fail_package($pkg, "component", "Execution of \"$cmd\" failed -- $!");
                next;
            }
	    # We've got to record the spec file name for later use
            if (defined $pkgs->{$pkg}{SPECFILE}) {
                $specfile = $pkgs->{$pkg}{SPECFILE};
            } else {
                undef $specfile;
            }
            while (<PKGTOOL>) {
                chomp($line = $_);
                next if ($line =~ /^\[pkgtool\//);
                dprint "RPM contents -> $line\n";
                # Add the file to the manifest
                push @manifest, $line;
                if ($line =~ /\.spec(\.in)?$/) {
                    if (!defined $specfile) {
                        $specfile = $line;
                        dprint "Found spec file as $specfile\n";
                    } elsif ($specfile eq $line) {
                        dprint "Found spec file $specfile as predicted.\n";
                    } else {
                        qprint "$progname:  Warning:  $pkgs->{$pkg}{FILENAME} contains the spec file $line\n";
                        qprint "$progname:  which is different from the one I was told to expect ($specfile).\n";
                        qprint "$progname:  I will ignore the auto-detected one as requested, but this may be a problem.\n";
                    }
                }
            }
            close(PKGTOOL);
            dprint "\"$cmd\" returned $?\n";
            if ($? != 0) {
                # FIXME:  What to do here?
            }
            if (! $specfile) {
                &fail_package($pkg, "component", "Unable to locate spec file in SRPM");
                next;
            }
            # We'll use this later, so it MUST be defined for any
            # package we plan on actually building at some point.
            $pkgs->{$pkg}{SPECFILE} = "$builddir/SPECS/$specfile";

            ### Check to make sure each file in the manifest is in the proper place.
            $err = 0;
            foreach $piece (@manifest) {
                # FIXME:  Need to handle _topdir for people who did their own rpm* files.
                if (($piece =~ /\.spec(\.in)?$/ && -f "$builddir/SPECS/$piece")
                    || (-f "$builddir/SOURCES/$piece")) {
                    next;
                }
                $err = 1;  # Something is missing.  We must explode this SRPM.
                last;
            }
            ### If everything is there, skip this stage for this package.
            if (! $err) {
                nprint "$progname:  SRPM has already been completely exploded.\n";
                nprint "$progname:  Explode stage for \"$pkg\" is complete.\n";
                next;
            }

            ### Explode the SRPM into its components
            $cmd = "$pkgtool -P \"$rpm\" -R $rpmrc -ip $pkgs->{$pkg}{FILENAME}";
            dprint "About to run \"$cmd\"\n";
            if (!open(PKGTOOL, "$cmd 2>&1 |")) {
                &fail_package($pkg, "component", "Execution of \"$cmd\" failed -- $!");
                next;
            }
            $err = 0;
            while (<PKGTOOL>) {
                chomp($line = $_);
                next if ($line =~ /^\[pkgtool\//);
                nprint "$line\n";
                if ($line !~ /successfully installed\.?$/) {
                    # Any otheroutput from this command is an error.
                    $err = 1;
                    ($msg = $line) =~ s/^pkgtool:\s+Error:\s+//;;
                    last;
                }
            }
            close(PKGTOOL);
            dprint "pkgtool returned $?\n";
            if ($? != 0) {
                # FIXME:  What to do here?
            }
            if ($err) {
                &fail_package($pkg, "component", $msg);
                next;
            }
        }

        nprint "$progname:  Component stage for \"$pkg\" is complete.  (${\(&get_timestamp())})\n";
    }
    chdir($builddir);
    qprint "$progname:  Component stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_build_stage
{
    my ($cmd, $line, $specfile, $rpm, $tmp, $target) = undef;
    my ($target_age, $orig_age, $spec_age);
    my ($err, $msg, $srpm) = (0, 0, 0);
    my @p;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    ### The build stage is where module, SRPM, and tar packages are built from sources.  Also,
    ### binary packages (and source packages with binaries) are copied into the RPM directories.
    qprint "$progname:  Entering the build stage.  (${\(&get_timestamp())})\n";

    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /b/) {
            nprint "$progname:  Skipping build stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting build stage for the \"$pkg\" package....  (${\(&get_timestamp())})\n";

        if (! chdir("$builddir/$pkgs->{$pkg}{MODULE}")) {
            return (AVALON_PACKAGE_FAILED, "Could not chdir into $builddir/$pkgs->{$pkg}{MODULE} -- $!", 0);
        }
        if (defined($pkgs->{$pkg}{BINS})) {
            my ($arch, $rpm);

            # Source and binaries.
            dprint "Copying $pkgs->{$pkg}{FILENAME} to $builddir/SRPMS/\n";
            &mkdirhier("$builddir/SRPMS");
            system("cp $pkgs->{$pkg}{FILENAME} $builddir/SRPMS/");
            $rpm = $pkgs->{$pkg}{FILENAME};
            $rpm =~ s/^.*\/([^\/]+)$/$1/;
            $pkgs->{$pkg}{OUTFILES} = "$builddir/SRPMS/$rpm";
            foreach $rpm (@{$pkgs->{$pkg}{BINS}}) {
                my $bin;

                $rpm =~ m/^.*\/([^\/]+)\.(\w+)\.rpm$/;
                $arch = $2;
                $bin = "$builddir/RPMS/$arch/$1.$arch.rpm";
                $pkgs->{$pkg}{OUTFILES} .= " $bin";
                dprint "Copying $rpm to $builddir/RPMS/$arch\n";
                &mkdirhier("$builddir/RPMS/$arch");
                system("cp $builddir/$rpm $builddir/RPMS/$arch/");
            }
        } elsif ($pkgs->{$pkg}{TYPE} eq "rpm") {
            my $arch;

            # Binary package.  Just move it into place.
            $pkgs->{$pkg}{FILENAME} =~ m/\.(\w+)\.rpm/;
            $arch = $1;
            dprint "Copying $pkgs->{$pkg}{FILENAME} to $builddir/RPMS/$arch\n";
            &mkdirhier("$builddir/RPMS/$arch");
            system("cp $pkgs->{$pkg}{FILENAME} $builddir/RPMS/$arch/");
        } elsif ($pkgs->{$pkg}{TYPE} eq "tar") {
            # Rebuild from the tarball
            ($err, $msg, $srpm) = &build_pkgs($pkg, $pkgs->{$pkg}{FILENAME});
            dprint "do_build_stage():  build_pkgs($pkg, $specfile) returned $err, $msg, $srpm\n";
            if ($err) {
                &fail_package($pkg, "build", $msg);
            } else {
                $srpm =~ m/^(\S+)-([^-]+)-([^-]+)\.(?:no)?src\.rpm$/;
                ($pkgs->{$pkg}{VERSION}, $pkgs->{$pkg}{RELEASE}) = ($2, $3);
                dprint "Filename is $pkgs->{$pkg}{FILENAME}, version is $pkgs->{$pkg}{VERSION}, release is $pkgs->{$pkg}{RELEASE}\n";
            }
        } elsif ($pkgs->{$pkg}{TYPE} eq "module") {
            ### If there's a makefile, use special_build() to build it.
            if (-s "$builddir/$pkgs->{$pkg}{MODULE}/.avalon.makefile") {
                ($err, $msg, $srpm) = &special_build($pkg);
                dprint "do_build_stage():  special_build($pkg) returned $err, $msg, $srpm\n";
            } else {
                # Build the module into an SRPM
                $specfile = $pkgs->{$pkg}{SPECFILE};
                ($err, $msg, $srpm) = &build_pkgs($pkg, $specfile);
                dprint "do_build_stage():  build_pkgs($pkg, $specfile) returned $err, $msg, $srpm\n";
            }
            if ($err) {
                &fail_package($pkg, "build", $msg);
            }

            # Update the values for FILENAME, VERSION, and RELEASE
            $pkgs->{$pkg}{FILENAME} = $srpm;
            $srpm =~ s/^(\S+)\/([^\/]+src\.rpm)$/$2/;
            $srpm =~ m/^(\S+)-([^-]+)-([^-]+)\.(?:no)?src\.rpm$/;
            ($pkgs->{$pkg}{VERSION}, $pkgs->{$pkg}{RELEASE}) = ($2, $3);
            dprint "Filename is $pkgs->{$pkg}{FILENAME}, version is $pkgs->{$pkg}{VERSION}, release is $pkgs->{$pkg}{RELEASE}\n";
        } else {  # SRPM
            # Check for a target SRPM that is newer than the original SRPM and the
            # spec file.  If such an SRPM exists, skip the build stage for this package.
            $target = "$builddir/SRPMS/$pkg" . "-"
                       . "$pkgs->{$pkg}{VERSION}" . "-" . "$pkgs->{$pkg}{RELEASE}.src.rpm";
            $specfile = $pkgs->{$pkg}{SPECFILE};
            dprint "Target SRPM is $target\n";
            if (-f $target) {
                $target_age = -M _;
                $orig_age = -M $pkgs->{$pkg}{FILENAME};
                $spec_age = -M $specfile;
                dprint "File ages:  $orig_age for $pkgs->{$pkg}{FILENAME}, $target_age for $target,"
                        . " and $spec_age for $specfile\n";
                if ($target_age < $spec_age && $target_age < $orig_age) {
                    nprint "$progname:  The target SRPM already exists.\n";
                    nprint "$progname:  Build stage for \"$pkg\" is complete.\n";
                    next;
                }
            }

            # Rebuild from the spec file
            ($err, $msg, $srpm) = &build_pkgs($pkg, $specfile);
            dprint "do_build_stage():  build_pkgs($pkg, $specfile) returned $err, $msg, $srpm\n";
            if ($err) {
                &fail_package($pkg, "build", $msg);
            }
        }
        nprint "$progname:  Build stage for \"$pkg\" is complete.  (${\(&get_timestamp())})\n";
    }
    chdir($builddir);
    qprint "$progname:  Build stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_package_stage
{
    my ($path, $version, $release, $type);
    my @outfiles;
    my @contents;
    my @p;
    local *DIR;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    ### The package accumulation stage is where the output files (source and binary RPM's) from the
    ### build stage are copied (technically, linked) into their proper locations within image modules.
    qprint "$progname:  Entering the package accumulation stage.  (${\(&get_timestamp())})\n";

    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /p/) {
            nprint "$progname:  Skipping package accumulation stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting package accumulation stage for the \"$pkg\" package....\n";
        $type = $pkgs->{$pkg}{TYPE};
        $version = $pkgs->{$pkg}{VERSION};
        $release = $pkgs->{$pkg}{RELEASE};
        undef @outfiles;

	### Look for output files.  Hopefully we recorded them from earlier.  If not, hunt for them.
        dprint "Checking for output files for $pkg $version-$release\n";
        if ($pkgs->{$pkg}{OUTFILES}) {
            dprint "Output files [$pkgs->{$pkg}{OUTFILES}] saved from earlier.\n";
            @outfiles = split(" ", $pkgs->{$pkg}{OUTFILES});
        } else {
            if ($type eq "srpm" || $type eq "module" || $type eq "tar") {
                # Find all the RPM's installed by this package
                dprint "Opening directory $builddir/SRPMS to scan for output files.\n";
                foreach $rpm (&grepdir(sub {/^\Q$pkg-\E\S*\Q$version-$release\E\.(?:no)?src\.rpm$/}, "$builddir/SRPMS")) {
                    dprint "Got output file $rpm\n";
                    push @outfiles, "$builddir/SRPMS/$rpm";
                }

                dprint "Opening directory $builddir/RPMS to scan for output files.\n";
                @contents = glob("$builddir/RPMS/*/*.rpm");
                foreach $rpm (@contents) {
                    my $srpm;

                    dprint "Checking $rpm\n";
                    if (defined $srpm_of_rpm{$rpm}) {
                        $srpm = $srpm_of_rpm{$rpm};
                    } else {
                        $srpm = `rpm -qp $rpm --queryformat \"%{SOURCERPM}\"`;
                        $srpm_of_rpm{$rpm} = $srpm;
                    }
                    if ($srpm =~ /^\Q$pkg-\E\S*\Q$version-$release\E\.(?:no)?src\.rpm$/) {
                        dprint "Got output file $rpm\n";
                        push @outfiles, $rpm;
                    }
                }
            } elsif ($type eq "rpm") {
                my ($filename, $arch, $outfile);

                ($filename = $pkgs->{$pkg}{FILENAME}) =~ s/^.*\/([^\/]+)$/$1/;
                ($arch = $filename) =~ s/^.*\.(\w+)\.rpm$/$1/;
                $outfile = "$builddir/RPMS/$arch/$filename";
                dprint "Output RPM is $outfile\n";
                if (-f $outfile) {
                    push @outfiles, $outfile;
                }
            }
        }

	# If we didn't find any, something is very wrong.
        if ($#outfiles == -1) {
            &fail_package($pkg, "package accumulation", "No output RPM's were found");
            next;
        }
        dprint "Output files for $pkg:  ", join(" ", @outfiles), "\n";

        # Copy each RPM into the appropriate place
        foreach $rpm (@outfiles) {
            my $found;

            $found = &place_file($pkg, $rpm);
            if ($found == 0) {
                qprint "Warning:  No location found matching $rpm\n";
            } else {
                dprint "Found $found locations for $rpm\n";
            }
        }
        nprint "$progname:  Package accumulation stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Package accumulation stage is now complete.  (${\(&get_timestamp())})\n";
}

# Clean up the RPM build directories and the build root
sub
cleanup
{
    my $type = $_[0];
    my @dirs;

    if ($type =~ /all/i) {
        @dirs = ("$builddir/BUILD", "$builddir/SOURCES", "$builddir/SRPMS", "$builddir/RPMS", "$builddir/SPECS", $buildroot);
    } elsif ($type =~ /rpm/i) {
        @dirs = ("$builddir/BUILD", "$builddir/SOURCES", "$builddir/SRPMS", "$builddir/RPMS", "$builddir/SPECS");
    } elsif ($type =~ /(build)?root/) {
        @dirs = ($buildroot);
    } else {
        @dirs = ("$builddir/BUILD", "$builddir/SOURCES", "$builddir/SPECS", $buildroot);
    }
    foreach $f (@dirs) {
        nprint "$progname:  Cleaning up $f\n";
        &nuke_tree($f) || qprint "Warning:  Removal of $f failed -- $!\n";
    }
}

# Once we're all done, summarize any failures at the very end
# so that they're easy to find if the user is generating a log.
sub
summarize_failures
{
    my ($ns, $nf, $nt);

    # $ns is the number of successful packages.  $nf is the number of failures.
    # $nt is the total number of packages we tried to build.
    $ns = scalar(@packages);
    $nf = scalar(@failed_pkgs);
    $nt = $ns + $nf;
    qprint "Package Summary:  Out of $nt total packages,";
    if ($ns) {
        qprint(" ", ($ns == $nt ? "all" : "$ns"), " succeeded");
        if ($nf) {
            qprint " and";
        }
    }
    if ($nf) {
        qprint(" ", ($nf == $nt ? "all" : "$nf"), " failed");
    }
    qprint ".\n";

    foreach $pkg (@failed_pkgs) {
        if ($failure->{$pkg}{MESSAGE}) {
            eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage:  $failure->{$pkg}{MESSAGE}.\n";
        } else {
            eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage.\n";
        }
    }
}

# Build a package that has its own buildtool makefile
sub
special_build
{
    my $pkg = $_[0];
    my ($err, $msg, $srpm, $cmd, $make, $out_files);
    local *MAKE;

    if (! chdir("$builddir/$pkgs->{$pkg}{MODULE}")) {
        return (AVALON_PACKAGE_FAILED, "Could not chdir into $builddir/$pkgs->{$pkg}{MODULE} -- $!", 0);
    }

    $make = ($pkgs->{$pkg}{MAKE} ? $pkgs->{$pkg}{MAKE} : "make");
    $cmd = "$make BASE_DIR=$basedir BUILD_DIR=$builddir BUILD_ROOT=$buildroot RPMRC=$buildroot/$pkg-rpmrc";

    dprint "About to run \"$cmd\"\n";
    if (!open(MAKE, "$cmd </dev/null 2>&1 |")) {
        return (1, "Execution of \"$cmd\" failed -- $!", undef);
    }
    $err = 0;
    while (<MAKE>) {
        chomp($line = $_);
        nprint "$line\n";
        if ($line =~ /^make[^:]*:\s+\*\*\*\s+(.*)$/ && ! $msg) {
            $msg = $1;
        } elsif ($line =~ /^Package files generated:\s+(.*)$/) {
            $out_files = $1;
        }
    }
    close(MAKE);
    dprint "make returned $?\n";
    if ($? != 0 && $err == 0) {
        $err = $?;
        $msg = "Unhandled make error" if (! $msg);
    }

    if ($out_files) {
        $pkgs->{$pkg}{OUTFILES} = $out_files;
        if ($out_files =~ /src\.rpm/) {
            ($srpm = $out_files) =~ s/^(.*\s+)?(\S+src\.rpm)(\s+.*)?$/$2/;
        }
    } else {
        $err = AVALON_PACKAGE_FAILED;
        $msg = "No output files reported by make";
    }
    chdir($builddir);
    return ($err, $msg, $srpm);
}

# This routine handles the role of "master buildtool"
sub
parallel_build
{
    my ($pid, $err, $idx, $pkg, $logfile, $line, $nprocs, $done, $left, $failed, $bldg);
    my (@children, @vars, @p);
    my %child_pkg;
    local *ERRLOG;

    @p = ($#_ >= 0 ? @_ : @packages);
    if (! -d "$basedir/logs") {
        mkdir("$basedir/logs", 0755) || &fatal_error("Unable to mkdir $basedir/logs -- $!\n");
    }
    $idx = 0;
    # Set $nprocs equal to the index within @children that should not be exceeded.
    $nprocs = $num_cpus - 1;
    # The "!$idx || " part of the test below is required because perl's do...while construct
    # sucks.  You can't use next/last from within it.  Someone shoot whoever decided that.
    qprintf "$progname:  Beginning $num_cpus-way build of %d packages.  (${\(&get_timestamp())})\n", $#p + 1;
    while (!$idx || $#children >= 0) {
        for (; $idx <= $#p && $#children < $nprocs; $idx++) {
            # Spawn a buildtool child process to handle the next package
            $pkg = $p[$idx];
            $logfile = "$basedir/logs/$pkg.log";
            $pid = &spawn_cmd($pkg, $logfile);
            push @children, $pid;
            $child_pkg{$pid} = $pkg;
        }

        # Out of space for children for now.
        $line = "";
        foreach $pid (@children) {
            $line .= "$child_pkg{$pid} ($pid)    ";
        }
        nprint "$progname:  Currently building:  $line\n";
        $bldg = $#children + 1;
        $done = $idx - $#children - 1;
        $left = $#p + 1 - $done - $bldg;
        $failed = $#failed_pkgs + 1;
        nprint "$progname:  $done packages completed ($failed failed), $bldg building, $left in queue.\n";

        # Wait for a child to die
        $pid = waitpid(-1, 0);
        next if (! $child_pkg{$pid});
        $pkg = $child_pkg{$pid};
        $err = $? >> 8;
        if ($pid == -1) {
            # This should never happen.
            eprint "Ummm, waitpid() returned -1.  That wasn't very nice.  I'm offended.\n";
            next;
        }
        @children = grep($_ != $pid, @children);
        if ($err == AVALON_SUCCESS) {
            nprint "Child process $pid for package $pkg completed successfully.  (${\(&get_timestamp())})\n";
        } else {
            dprint "Child process $pid for package $pkg failed, returning $err.\n";
            if ($err == AVALON_SPAWN_FAILED) {
                &fail_package($pkg, "pre-build", "exec() of child failed");
            } else {
                my @tmp;

                # The last line of the logfile should give the error message
                if (!open(ERRLOG, "$basedir/logs/$pkg.log")) {
                    &fail_package($pkg, "???", "Child process returned $err but the log file is missing");
                    next;
                }
                @tmp = <ERRLOG>;
                close(ERRLOG);
                chomp($line = $tmp[$#tmp]);
                if ($line =~ /^$progname:  Error:  Package \S+ failed at the ([a-z ]+) stage:  (.*)$/) {
                    &fail_package($pkg, $1, $2);
                } else {
                    $line =~ s/^\w+:  (Error:  )?\s*//;
                    &fail_package($pkg, "???", "Child process exited with code $err -- $line");
                }
            }
        }
        # End of loop.  Time to spawn the next child.
    }
    qprint "$progname:  Parallel build complete.  (${\(&get_timestamp())})\n";
}

# This routine does the actual build process
sub
build_process
{
    # Perform the build in stages, checking after each one to see if we should stop
    &do_bootstrap_stage() if ($start_stage eq "s");
    return if ($end_stage eq "s" || $#packages == -1);

    if ($master) {
        &parallel_build();
    } else {
        &do_component_stage() if ("sc" =~ /$start_stage/);
        return if ($end_stage eq "c");

        &do_build_stage() if ("scb" =~ /$start_stage/);
        return if ($end_stage eq "b");

        &do_package_stage();
    }
}

# main() here is basically the same as main() in C
sub
main
{
    # Set up the basic variables
    $progname = "buildtool";
    $version = "2.0";

    # No input.
    open(STDIN, "</dev/null");

    # See the Getopt::Long man page for details on the syntax of this line
    @valid_opts = ("h|help", "v|version", "d|debug", "b|build=s", "p|product|package=s",
                   "q|quiet", "Q|really-quiet|silent", "D|dir=s", "f|force", "l|log=s",
                   "P|parallel:s", "t|target=s", "C|cflags=s", "B|startbuild=s", "tree=s",
                   "tag=s", "nocache", "clean:s");
    Getopt::Long::Configure("no_getopt_compat", "bundling", "no_ignore_case");
    Getopt::Long::GetOptions(@valid_opts);

    # Post-parse the options stuff
    if ($opt_v) {
        # Do not edit this variable.  It is updated automatically by CVS when you commit
        my $rcs_info = 'CVS Revision $Revision: 1.131 $ created on $Date: 2001/04/07 02:22:39 $ by $Author: mej $ ';

        $rcs_info =~ s/\$\s*Revision: (\S+) \$/$1/;
        $rcs_info =~ s/\$\s*Date: (\S+) (\S+) \$/$1 at $2/;
        $rcs_info =~ s/\$\s*Author: (\S+) \$ /$1/;
        print "\n";
	print "$progname $version by Michael Jennings <mej\@eterm.org>\n";
        print "Copyright (c) 2000, Michael Jennings and VA Linux Systems, Inc.\n";
        print "  ($rcs_info)\n";
        print "\n";
	return AVALON_SUCCESS;
    }
    if ($opt_h) {
	&print_usage_info();   # Never returns
    }
    &debug_set($opt_d);
    $revtool = "revtool" . (&debug_get() ? " --debug" : "");
    $pkgtool = "pkgtool" . (&debug_get() ? " --debug" : "");
    $GLOBAL_LOG = 0;
    open(STDERR, ">&STDOUT");
    if ($opt_l) {
        if (!open(LOGFILE, ">$opt_l")) {
            eprint "Unable to open $opt_l -- $!\n";
        } else {
            $GLOBAL_LOG = \*LOGFILE;
            #system("chattr +S $opt_l");  # Try to set sync on the log file, fail silently
            open(STDOUT, ">&LOGFILE");
            select LOGFILE; $| = 1;
        }
    }
    select STDOUT; $| = 1;
    $verbosity = ($opt_Q ? 0 : ($opt_q ? 1 : 2));
    $target = $opt_t;
    $global_tree = $opt_tree;
    $global_tag = $opt_tag;

    # Set up the start/end stage identifiers
    $start_stage = ($opt_B ? $opt_B : "s");
    if (index("Zscbp", $start_stage) == -1) {
        eprint "Bad start stage \"$start_stage\".  Assuming \"s\".\n";
        $start_stage = "s";
    }
    $end_stage = ($opt_b ? $opt_b : "p");
    if ($end_stage ne "Z") {
        if (index("scbp", $end_stage) == -1) {
            eprint "Bad end stage \"$end_stage\".  Assuming \"p\".\n";
            $end_stage = "p";
        } elsif (index("scbp", $start_stage) > index("scbp", $end_stage)) {
            eprint "End stage \"$end_stage\" comes before start stage \"$start_stage\".\n";
            $start_stage = "s";
            $end_stage = "p";
        }
        dprint "Building stages \"$start_stage\" through \"$end_stage\"\n";
    }

    # Figure out parallelization stuff
    if ($opt_master) {
        $slave = 1;
        $master = 0;
    } elsif (defined($opt_P)) {
        $master = 1;
        $slave = 0;
        $num_cpus = &count_cpus();
        if ($opt_P) {
            my ($mult, $add);

            $opt_P =~ m/^(?:[Xx]([\d.]+))?([-+][\d.]+)?$/;
            ($mult, $add) = ($1, $2);
            dprint "Modifying \$num_cpus:  $opt_P   $mult   $add\n";
            $num_cpus = $num_cpus * ($mult ? $mult : 1) + ($add ? $add : 0);
        }
    } else {
        $master = 0;
        $slave = 0;
        $num_cpus = 1;
    }
    dprint "Using $num_cpus parallel processes.\n";

    # Try to parse the product name we were given into a name or a name-version combo
    if ($opt_p) {
        $prod = $opt_p;
        if ($prod =~ /^(\S+)-((?:\d|us|a|alpha|b|beta)[^-]+)$/) {
            ($prodname, $prodver) = ($1, $2);
        } else {
            ($prodname, $prodver) = ($prod, 0);
        }
        if ($opt_D && -d $opt_D) {
            $basedir = $opt_D;
        } elsif ($ENV{BASE_DIR} && $ENV{BASE_DIR} =~ /^\// && -d $ENV{BASE_DIR}) {
            $basedir = $ENV{BASE_DIR};
        } else {
            chomp($basedir = `pwd`);
        }
	if (-d "$basedir/$prod") {
	    $builddir = $basedir;
	} elsif ($ENV{BUILD_DIR}) {
	    $builddir = $ENV{BUILD_DIR};
	} else {
	    $builddir = "$basedir/build";
	}
    } else {
        my $cwd = &getcwd();

        $prod = $prodname = &basename($cwd);
        $basedir = $builddir = &dirname($cwd);
    }
    $buildroot = ($ENV{BUILDROOT} ? $ENV{BUILDROOT} : "/var/tmp/buildtool.$$");
    qprint "$progname:  Building product:  $prodname", ($prodver ? " $prodver" : ""), "\n";

    # Try to find the products directory
    foreach $dir (($ENV{PROD_DIR} ? $ENV{PROD_DIR} : 0), "$basedir/products", "$basedir/../products") {
	if ($dir && -d $dir) {
	    $proddir = $dir;
	    last;
	}
    }

    # If we don't have a products directory, try to download one.
    if (!defined $proddir) {
        my ($err, $msg);

        ($err, $msg) = &fetch_package("$revtool -g products");
        if ($err) {
            eprint "Unable to find/download products directory -- $msg.  This could be bad.\n";
        }
    }

    # Signal handling
    $SIG{HUP} = 'IGNORE';
    $SIG{INT} = \&handle_signal;
    $SIG{TERM} = \&handle_signal;
    $SIG{QUIT} = \&handle_fatal_signal;
    $SIG{ILL} = \&handle_fatal_signal;
    $SIG{ABRT} = \&handle_fatal_signal;
    $SIG{FPE} = \&handle_fatal_signal;
    $SIG{SEGV} = \&handle_fatal_signal;
    $SIG{BUS} = \&handle_fatal_signal;
    $SIG{TSTP} = 'IGNORE';
    $SIG{TTIN} = 'IGNORE';
    $SIG{TTOU} = 'IGNORE';

    # Environment modifications
    $ENV{MAKE} = "make";  # Make sure we don't parallel build, because it doesn't work.
    $ENV{CFLAGS} = ($opt_C ? $opt_C : "-O2 -march=pentium");
    delete $ENV{LD_RUN_PATH};  # Don't hard code any RPATH's into binaries
    delete $ENV{LD_LIBRARY_PATH};  # Make glibc happy
    $ENV{PATH} = "/usr/build/bin:/usr/local/build/bin:/usr/lib/qt-1.45/bin:/usr/lib/qt-2.1.0/bin"
                  . ":/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/kerberos/sbin"
                  . ":/usr/kerberos/bin:.";

    # Parse the product definition files to figure out what the heck we need to build. :)
    # If we're a slave process, we know it's going to be a straight product entry.
    if ($slave || ! &parse_prod_file($prodname, $prodver, 0)) {
        if (! &parse_product_entry($prod)) {
            eprint "$prod does not seem to be a valid product or product entry.\n";
            eprint "Perhaps you made a typo?\n";
            return AVALON_BAD_PRODUCT;
        }
    }
    dprint "Products to be built:  ", join(" ", @products), "\n";

    if ($end_stage ne "Z") {  # -dbZ, a.k.a. How To Debug the Parser :-)
        &initial_setup();
        &build_process();
        &cleanup($opt_clean) if (defined($opt_clean));
    } else {
        # This way we can just do cleanup. :-)
        &cleanup($opt_clean) if (defined($opt_clean));
    }
    return (defined(@failed_pkgs) && $#failed_pkgs != -1) ? AVALON_PACKAGE_FAILED : AVALON_SUCCESS;
}

exit &main();

END {
    &summarize_failures() if (scalar(@failed_pkgs) && ! $slave);
    close($GLOBAL_LOG) if ($GLOBAL_LOG);
}
