#!/usr/bin/perl -w
#
# buildtool -- Product Build Management Tool
# 
# Copyright (C) 2000-2001, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: buildtool,v 1.146 2001/07/20 20:29:35 mej Exp $
#

# Include the Perl Modules we need
require POSIX;
require Getopt::Long;
use Cwd;
use Avalon::Util;
use Avalon::Src;
use Avalon::Pkg;
#use Avalon::Build;
use Avalon::Prod;

# Print usage information
sub
print_usage_info
{
    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   buildtool [ options ]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -q --quiet                       Be somewhat quiet.  Simply gives basic progress info\n";
    print "    -Q --really-quiet --silent       Be very quiet.  Only errors are reported\n";
    print "    -D --dir <directory>             Specify the repository to use (overrides all product files)\n";
    print "    -l --log <logfile>               Specify a log file to send informational output to\n";
    print "    -P --parallel [expr]             Parallelize the build process based on the number of CPU's\n";
    print "    -t --target <arch>               Tell rpm to build for a particular target architecture\n";
    print "    -C --cflags <flags>              Specify the \$CFLAGS variable to use for building\n";
    print "    -U --user <userid>               Specify a userid for the repository (overrides product files)\n";
    print "    -T --tag <tag>                   Specify a tag to use (overrides all product files)\n";
    print "       --nocache                     Do not scan the cache (use with care)\n";
    print "       --clean                       Clean up RPM and buildroot directories when done\n";
    print "\n";
    exit(AVALON_SUCCESS);
}

# Normal print (i.e., don't print this in -q or -Q mode)
sub nprintf    {printf @_ if ($GLOBAL_LOG || $verbosity >= 2);}
sub nprint     {print  @_ if ($GLOBAL_LOG || $verbosity >= 2);}
# Quiet print (i.e., print in -q mode but not in -Q mode)
sub qprintf    {printf @_ if ($GLOBAL_LOG || $verbosity >= 1);}
sub qprint     {print  @_ if ($GLOBAL_LOG || $verbosity >= 1);}

# Spawn a child buildtool
sub
spawn_cmd
{
    my ($pkg, $logfile) = @_;
    my $pid;

    do {
        if ($pid = fork()) {
            # Parent -- return PID
            nprint "Spawned child process $pid to build $pkg (log file is $logfile)\n";
            return $pid;
        } elsif (defined $pid) {
            # Child -- reset state as needed and jump to build process
            $opt_f = 0;
            $verbosity = 0;
            $slave = 1;
            $master = 0;
            close $GLOBAL_LOG if ($GLOBAL_LOG);
            open(STDOUT, ">/dev/null");
            open(STDIN, "</dev/null");
            if (!open(LOGFILE, ">$logfile")) {
                eprint "Unable to open $logfile -- $!\n";
            } else {
                $GLOBAL_LOG = \*LOGFILE;
                #system("chattr +S $logfile");  # Try to set sync on the log file, fail silently
                open(STDERR, ">&LOGFILE");
                select LOGFILE; $| = 1;
            }
	    # Reduce the package list to just one package.  Then we can proceed
	    # without having to incur the performance penalty of an exec().
            @packages = ($pkg);
            @failed_pkgs = ();
            &build_process();
            close(LOGFILE) if ($GLOBAL_LOG);
            exit (AVALON_SUCCESS);
        } elsif ($! !~ /No more processes/ && $! !~ /Resource temporarily unavailable/) {
            &fatal_error("fork() failed -- $!\n");
        }
        # Temporary failure
        dprint "Failed temporarily -- $!\n";
        sleep 5;
    } while (1);
}

# Download packages from the repository
sub
download_packages
{
    my @packages = @_;
    my ($line, $err, $msg);

    nprint "Downloading packages, please wait..." if (! &debug_get());
    foreach $pkg (@packages) {
        my ($module, $filename) = ($pkgs->{$pkg}{MODULE}, $pkgs->{$pkg}{FILENAME});
        my ($files, $tag, $cvsroot);

        $err = 0;
        if ($filename eq $module) {
            dprint "\"$filename\" vs. \"$module\" == 1\n";
            $files = $module;
        } else {
            dprint "\"$filename\" vs. \"$module\" == 0\n";
            $files = "$module/$filename";
        }
        if (defined($pkgs->{$pkg}{BINS})) {
            foreach my $bin (@{$pkgs->{$pkg}{BINS}}) {
                $files .= " $bin";
            }
        }
	# Set the proper CVSROOT and tag for the checkout.
        if ($global_tree) {
            $cvsroot = $global_tree;
        } elsif ($pkgs->{$pkg}{CVSROOT}) {
            $cvsroot = $pkgs->{$pkg}{CVSROOT};
        } else {
            $cvsroot = "";
        }
        if ($global_user) {
            $cvsroot =~ s/\w+\@/$global_user\@/;
        }
        if ($global_tag) {
            $tag = $global_tag;
        } elsif ($pkgs->{$pkg}{TAG}) {
            ($tag = $pkgs->{$pkg}{TAG}) =~ s/^([^:]+):([^:]+)$/$2/;
        } else {
            $tag = "";
        }

        nprint "$pkg..." if (! &debug_get());
        ($err, $msg) = &fetch_package("", $files, $tag, $cvsroot);
        if ($err) {
            &fail_package($pkg, $msg);
            next;
        }
    }
    nprint "done.\n\n" if (! &debug_get());
}

sub
do_package_stage
{
    my ($path, $version, $release, $type);
    my @outfiles;
    my @contents;
    my @p;
    local *DIR;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    ### The package accumulation stage is where the output files (source and binary RPM's) from the
    ### build stage are copied (technically, linked) into their proper locations within image modules.
    qprint "$progname:  Entering the package accumulation stage.  (${\(&get_timestamp())})\n";

    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /p/) {
            nprint "$progname:  Skipping package accumulation stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting package accumulation stage for the \"$pkg\" package....\n";
        $type = $pkgs->{$pkg}{TYPE};
        $version = $pkgs->{$pkg}{VERSION};
        $release = $pkgs->{$pkg}{RELEASE};
        undef @outfiles;

	### Look for output files.  Hopefully we recorded them from earlier.  If not, hunt for them.
        dprint "Checking for output files for $pkg $version-$release\n";
        if ($pkgs->{$pkg}{OUTFILES}) {
            dprint "Output files [$pkgs->{$pkg}{OUTFILES}] saved from earlier.\n";
            @outfiles = split(" ", $pkgs->{$pkg}{OUTFILES});
        } else {
            if ($type eq "srpm" || $type eq "module" || $type eq "tar") {
                # Find all the RPM's installed by this package
                dprint "Opening directory $builddir/SRPMS to scan for output files.\n";
                foreach $rpm (&grepdir(sub {/^\Q$pkg-\E\S*\Q$version-$release\E\.(?:no)?src\.rpm$/}, "$builddir/SRPMS")) {
                    dprint "Got output file $rpm\n";
                    push @outfiles, "$builddir/SRPMS/$rpm";
                }

                dprint "Opening directory $builddir/RPMS to scan for output files.\n";
                @contents = glob("$builddir/RPMS/*/*.rpm");
                foreach $rpm (@contents) {
                    my $srpm;

                    dprint "Checking $rpm\n";
                    if (defined $srpm_of_rpm{$rpm}) {
                        $srpm = $srpm_of_rpm{$rpm};
                    } else {
                        $srpm = `rpm -qp $rpm --queryformat \"%{SOURCERPM}\"`;
                        $srpm_of_rpm{$rpm} = $srpm;
                    }
                    if ($srpm =~ /^\Q$pkg-\E\S*\Q$version-$release\E\.(?:no)?src\.rpm$/) {
                        dprint "Got output file $rpm\n";
                        push @outfiles, $rpm;
                    }
                }
            } elsif ($type eq "rpm") {
                my ($filename, $arch, $outfile);

                ($filename = $pkgs->{$pkg}{FILENAME}) =~ s/^.*\/([^\/]+)$/$1/;
                ($arch = $filename) =~ s/^.*\.(\w+)\.rpm$/$1/;
                $outfile = "$builddir/RPMS/$arch/$filename";
                dprint "Output RPM is $outfile\n";
                if (-f $outfile) {
                    push @outfiles, $outfile;
                }
            }
        }

	# If we didn't find any, something is very wrong.
        if ($#outfiles == -1) {
            &fail_package($pkg, "package accumulation", "No output RPM's were found");
            next;
        }
        dprint "Output files for $pkg:  ", join(" ", @outfiles), "\n";

        # Copy each RPM into the appropriate place
        foreach $rpm (@outfiles) {
            my $found;

            $found = &place_file($pkg, $rpm);
            if ($found == 0) {
                qprint "Warning:  No location found matching $rpm\n";
            } else {
                dprint "Found $found locations for $rpm\n";
            }
        }
        nprint "$progname:  Package accumulation stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Package accumulation stage is now complete.  (${\(&get_timestamp())})\n";
}

# Once we're all done, summarize any failures at the very end
# so that they're easy to find if the user is generating a log.
sub
summarize_failures
{
    my ($ns, $nf, $nt);

    # $ns is the number of successful packages.  $nf is the number of failures.
    # $nt is the total number of packages we tried to build.
    $ns = scalar(@packages);
    $nf = scalar(@failed_pkgs);
    $nt = $ns + $nf;
    dprint "Successful:  $ns    Failed:  $nf    Total:  $nt\n";

    qprint "Package Summary:  Out of $nt total packages,";
    if ($ns) {
        qprint(" ", ($ns == $nt ? "all" : "$ns"), " succeeded");
        if ($nf) {
            qprint " and";
        }
    }
    if ($nf) {
        qprint(" ", ($nf == $nt ? "all" : "$nf"), " failed");
    }
    qprint ".\n";

    if ($nf) {
        foreach $pkg (@failed_pkgs) {
            if ($failure->{$pkg}{MESSAGE}) {
                eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage:  $failure->{$pkg}{MESSAGE}.\n";
            } else {
                eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage.\n";
            }
        }
    }
}

# This routine handles the role of "master buildtool"
sub
parallel_build
{
    my ($pid, $err, $idx, $pkg, $logfile, $line, $nprocs, $done, $left, $failed, $bldg);
    my (@children, @vars, @p);
    my %child_pkg;
    local *ERRLOG;

    @p = ($#_ >= 0 ? @_ : @packages);
    if (! -d "$basedir/logs") {
        mkdir("$basedir/logs", 0755) || &fatal_error("Unable to mkdir $basedir/logs -- $!\n");
    }
    $idx = 0;
    # Set $nprocs equal to the index within @children that should not be exceeded.
    $nprocs = $num_cpus - 1;
    # The "!$idx || " part of the test below is required because perl's do...while construct
    # sucks.  You can't use next/last from within it.  Someone shoot whoever decided that.
    qprintf "$progname:  Beginning $num_cpus-way build of %d packages.  (${\(&get_timestamp())})\n", $#p + 1;
    while (!$idx || $#children >= 0) {
        for (; $idx <= $#p && $#children < $nprocs; $idx++) {
            # Spawn a buildtool child process to handle the next package
            $pkg = $p[$idx];
            $logfile = "$basedir/logs/$pkg.log";
            $pid = &spawn_cmd($pkg, $logfile);
            push @children, $pid;
            $child_pkg{$pid} = $pkg;
        }

        # Out of space for children for now.
        $line = "";
        foreach $pid (@children) {
            $line .= "$child_pkg{$pid} ($pid)    ";
        }
        nprint "$progname:  Currently building:  $line\n";
        $bldg = $#children + 1;
        $done = $idx - $#children - 1;
        $left = $#p + 1 - $done - $bldg;
        $failed = $#failed_pkgs + 1;
        nprint "$progname:  $done packages completed ($failed failed), $bldg building, $left in queue.\n";

        # Wait for a child to die
        $pid = waitpid(-1, 0);
        next if (! $child_pkg{$pid});
        $pkg = $child_pkg{$pid};
        $err = $? >> 8;
        if ($pid == -1) {
            # This should never happen.
            eprint "Ummm, waitpid() returned -1.  That wasn't very nice.  I'm offended.\n";
            next;
        }
        @children = grep($_ != $pid, @children);
        if ($err == AVALON_SUCCESS) {
            nprint "Child process $pid for package $pkg completed successfully.  (${\(&get_timestamp())})\n";
        } else {
            dprint "Child process $pid for package $pkg failed, returning $err.\n";
            if ($err == AVALON_SPAWN_FAILED) {
                &fail_package($pkg, "pre-build", "exec() of child failed");
            } else {
                my @tmp;

                # The last line of the logfile should give the error message
                if (!open(ERRLOG, "$basedir/logs/$pkg.log")) {
                    &fail_package($pkg, "???", "Child process returned $err but the log file is missing");
                    next;
                }
                @tmp = <ERRLOG>;
                close(ERRLOG);
                chomp($line = $tmp[$#tmp]);
                if ($line =~ /^$progname:  Error:  Package \S+ failed at the ([a-z ]+) stage:  (.*)$/) {
                    &fail_package($pkg, $1, $2);
                } else {
                    $line =~ s/^\w+:  (Error:  )?\s*//;
                    &fail_package($pkg, "???", "Child process exited with code $err -- $line");
                }
            }
        }
        # End of loop.  Time to spawn the next child.
    }
    qprint "$progname:  Parallel build complete.  (${\(&get_timestamp())})\n";
}

# This routine does the actual build process
sub
build_process
{
    # Perform the build in stages, checking after each one to see if we should stop
    &do_bootstrap_stage() if ($start_stage eq "s");
    return if ($end_stage eq "s" || $#packages == -1);

    if ($master) {
        &parallel_build();
    } else {
        &do_component_stage() if ("sc" =~ /$start_stage/);
        return if ($end_stage eq "c");

        &do_build_stage() if ("scb" =~ /$start_stage/);
        return if ($end_stage eq "b");

        &do_package_stage();
    }
}

# main() here is basically the same as main() in C
sub
main
{
    # Set up the basic variables
    $progname = "buildtool";
    $version = "2.1";
    umask 022;

    # No input.
    open(STDIN, "</dev/null");

    # See the Getopt::Long man page for details on the syntax of this line
    @valid_opts = ("h|help", "v|version", "d|debug", "q|quiet", "Q|really-quiet|silent", "D|dir|tree=s",
                   "l|log=s", "P|parallel:s", "t|target=s", "p|prod|product|prodfile=s", "C|cflags=s",
                   "T|tag=s", "nocache", "clean:s", "U|user=s");
    Getopt::Long::Configure("no_getopt_compat", "bundling", "no_ignore_case");
    Getopt::Long::GetOptions(@valid_opts);

    #
    # Options Handling
    #
    if ($opt_v) {
        # Do not edit this variable.  It is updated automatically by CVS when you commit
        my $rcs_info = 'CVS Revision $Revision: 1.146 $ created on $Date: 2001/07/20 20:29:35 $ by $Author: mej $ ';

        $rcs_info =~ s/\$\s*Revision: (\S+) \$/$1/;
        $rcs_info =~ s/\$\s*Date: (\S+) (\S+) \$/$1 at $2/;
        $rcs_info =~ s/\$\s*Author: (\S+) \$ /$1/;
        print "\n";
	print "$progname $version by Michael Jennings <mej\@eterm.org>\n";
        print "Copyright (c) 2000, Michael Jennings and VA Linux Systems, Inc.\n";
        print "  ($rcs_info)\n";
        print "\n";
	return AVALON_SUCCESS;
    }
    if ($opt_h) {
	&print_usage_info();   # Never returns
    }
    &debug_set($opt_d);
    $GLOBAL_LOG = 0;
    open(STDERR, ">&STDOUT");
    if ($opt_l) {
        if (!open(LOGFILE, ">$opt_l")) {
            eprint "Unable to open $opt_l -- $!\n";
        } else {
            $GLOBAL_LOG = \*LOGFILE;
            #system("chattr +S $opt_l");  # Try to set sync on the log file, fail silently
            open(STDOUT, ">&LOGFILE");
            select LOGFILE; $| = 1;
        }
    }
    select STDOUT; $| = 1;
    $verbosity = ($opt_Q ? 0 : ($opt_q ? 1 : 2));
    $target = $opt_t;
    $global_user = $opt_U;
    $global_tree = $opt_D;
    $global_tag = $opt_T;

    # Figure out parallelization stuff
    if (defined($opt_P)) {
        $num_cpus = &count_cpus();
        if ($opt_P) {
            my ($mult, $add);

            $opt_P =~ m/^(?:[Xx]([\d.]+))?([-+][\d.]+)?$/;
            ($mult, $add) = ($1, $2);
            dprint "Modifying \$num_cpus:  $opt_P   $mult   $add\n";
            $num_cpus = $num_cpus * ($mult ? $mult : 1) + ($add ? $add : 0);
        }
    } else {
        $num_cpus = 1;
    }
    dprint "Using $num_cpus parallel process(es).\n";

    # Try to parse the product name we were given into a name or a name-version combo
    if ($opt_p) {
        $prod = $opt_p;
    } else {
        $prod = $prodname = &basename(&getcwd());
    }
    $buildroot = ($ENV{BUILDROOT} ? $ENV{BUILDROOT} : "/var/tmp/buildtool.$$");

    if (! $opt_clean) {
        if (scalar(@packages) > 1) {
            $opt_clean = "root";
        } else {
            $opt_clean = "all";
        }
    }
    dprint "Cleaning:  $opt_clean\n";

    #
    # Signal handling
    #
    $SIG{HUP} = 'IGNORE';
    $SIG{INT} = \&handle_signal;
    $SIG{TERM} = \&handle_signal;
    $SIG{QUIT} = \&handle_fatal_signal;
    $SIG{ILL} = \&handle_fatal_signal;
    $SIG{ABRT} = \&handle_fatal_signal;
    $SIG{FPE} = \&handle_fatal_signal;
    $SIG{SEGV} = \&handle_fatal_signal;
    $SIG{BUS} = \&handle_fatal_signal;
    $SIG{TSTP} = 'IGNORE';
    $SIG{TTIN} = 'IGNORE';
    $SIG{TTOU} = 'IGNORE';

    #
    # Environment modifications
    #
    $ENV{MAKE} = "make";  # Make sure we don't parallel build, because it doesn't work.
    $ENV{CFLAGS} = ($opt_C ? $opt_C : "-O2 -march=pentiumpro");
    delete $ENV{LD_RUN_PATH};  # Don't hard code any RPATH's into binaries
    delete $ENV{LD_LIBRARY_PATH};  # Make glibc happy
    $ENV{PATH} = "/usr/build/bin:/usr/local/build/bin:/usr/lib/qt-1.45/bin:/usr/lib/qt-2.1.0/bin"
                  . ":/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/kerberos/sbin"
                  . ":/usr/kerberos/bin:.";

    # Parse the product definition files to figure out what the heck we need to build. :)
    if (! &parse_prod_file($prod, 0, 0)) {
        if (! &parse_product_entry($prod)) {
            eprint "$prod does not seem to be a valid product or product entry.\n";
            eprint "Perhaps you made a typo?\n";
            return AVALON_BAD_PRODUCT;
        }
    }
    return AVALON_BAD_PRODUCT if (!scalar(@packages));

    dprint "Products to be built (", scalar(@packages), " packages):  ", join(" ", @products), "\n";
    &download_packages(@packages);
#    &cleanup($opt_clean);
    return (scalar(@failed_pkgs)) ? AVALON_PACKAGE_FAILED : AVALON_SUCCESS;
}

exit &main();

END {
    &summarize_failures() if (! $slave);
    close($GLOBAL_LOG) if ($GLOBAL_LOG);
}
