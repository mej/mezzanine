#!/usr/bin/perl -w
#
# buildtool -- Product Build Management Tool
# 
# Copyright (C) 2000, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: buildtool,v 1.65 2000/06/16 19:00:35 mej Exp $
#

# Include the Perl Modules we need
use POSIX;
use Getopt::Mixed;

# Constants
#
# Keep these in sync with the ones in revtool, or
# talk perl into using headers and #define's.
#
# 1-20 are generic errors
sub REVTOOL_NO_SERVER()           {1;}
sub REVTOOL_SERVER_CRASH()        {2;}
sub REVTOOL_BAD_LOGIN()           {3;}
sub REVTOOL_COMMAND_FAILED()      {4;}
sub REVTOOL_ACCESS_DENIED()       {5;}

# 21-40 are retrieval/update errors
sub REVTOOL_FILE_NOT_FOUND()      {21;}
sub REVTOOL_FILE_REMOVED()        {22;}
sub REVTOOL_CONFLICT_FOUND()      {23;}
sub REVTOOL_INVALID_TAG()         {24;}

# 41-60 are add/remove errors
sub REVTOOL_BAD_ADDITION()        {41;}
sub REVTOOL_BAD_REMOVAL()         {42;}

# 61-80 are commit errors
sub REVTOOL_NEED_UPDATE()         {61;}

# 127 is a catch-all
sub REVTOOL_UNSPECIFIED_ERROR()   {127;}


# Return codes for buildtool
sub BUILDTOOL_SUCCESS()           {0;}
sub BUILDTOOL_PACKAGE_FAILED()    {1;}
sub BUILDTOOL_BAD_PRODUCT()       {2;}
sub BUILDTOOL_FATAL_ERROR()       {3;}
sub BUILDTOOL_CHILD_EXEC_FAILED() {4;}
sub BUILDTOOL_TERMINATED()        {50;}
sub BUILDTOOL_CRASHED()           {60;}

# Print usage information
sub
print_usage_info
{
    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   buildtool [ options ]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -b --build <stage>               Stop building after a particular stage (see below)\n";
    print "    -p --product --package <name>    Specify the product or package to build\n";
    print "    -q --quiet                       Be somewhat quiet.  Simply gives basic progress info\n";
    print "    -Q --really-quiet --silent       Be very quiet.  Only errors are reported\n";
    print "    -D --dir <directory>             Specify \"directory\" as the base directory for the build\n";
    print "    -f --force                       Ignore errors, build as much as possible\n";
    print "    -l --log <logfile>               Specify a log file to send informational output to\n";
    print "    -P --parallel                    Parallelize the build process based on the number of CPU's\n";
    print "    -t --target <arch>               Tell rpm to build for a particular target architecture\n";
    print "\n";
    print "The stages and their abbreviations (for use with the -b option) are:\n";
    print "  bootstrap (s), compose (c), explode (e), build (b), package accumulation (p), ISO image (i), cleanup (a)\n\n";
    print "The default is \"-bp\" if you do not specify otherwise.\n\n";
    exit(BUILDTOOL_SUCCESS);
}

# Generate timestamp for debugging/log file
sub
get_timestamp
{
    $ts = POSIX::strftime("%A, %d %B %Y %H:%M:%S %Z", localtime);
    return $ts;
}

# Report a fatal error
sub
fatal_error
{
    my $msg = "$progname:  FATAL:  $_[0]";

    print STDERR $msg;
    print $GLOBAL_LOG $msg if ($GLOBAL_LOG);
    exit(BUILDTOOL_FATAL_ERROR);
}

# Debugging output
sub
dprintf
{
    return if (! $debug);
    print "[debug:$progname] " if (! $slave);
    printf @_ if (! $slave);
    if ($GLOBAL_LOG) {
        print $GLOBAL_LOG "[debug:$progname] ";
        printf $GLOBAL_LOG @_;
    }
}
sub
dprint
{
    return if (! $debug);
    if (! $slave) {
        print "[debug:$progname] ", @_;
    }
    if ($GLOBAL_LOG) {
        print $GLOBAL_LOG "[debug:$progname] ", @_;
    }
}

# Print an error
sub
eprintf
{
    print "$progname:  Error:  ";
    printf @_;
    if ($GLOBAL_LOG) {
        print $GLOBAL_LOG "$progname:  Error:  ";
        printf $GLOBAL_LOG @_;
    }
}
sub
eprint
{
    print "$progname:  Error:  ", @_;
    if ($GLOBAL_LOG) {
        print $GLOBAL_LOG "$progname:  Error:  ", @_;
    }
}

# Normal print (i.e., don't print this in -q or -Q mode)
sub
nprintf
{
    if ($GLOBAL_LOG) {
        printf $GLOBAL_LOG @_;
    }
    return if ($verbosity < 2);
    printf @_;
}
sub
nprint
{
    if ($GLOBAL_LOG) {
        print $GLOBAL_LOG @_;
    }
    return if ($verbosity < 2);
    print @_;
}

# Quiet print (i.e., print in -q mode but not in -Q mode)
sub
qprintf
{
    if ($GLOBAL_LOG) {
        printf $GLOBAL_LOG @_;
    }
    return if ($verbosity < 1);
    printf @_;
}
sub
qprint
{
    if ($GLOBAL_LOG) {
        print $GLOBAL_LOG @_;
    }
    return if ($verbosity < 1);
    print @_;
}

# Handle a terminate signal
sub
handle_signal
{
    my $sig = $_[0];

    &summarize_failures() if ($#failed_pkgs >= 0);
    eprint "Someone sent me a SIG$sig asking me to exit, so I shall.\n";
    close($GLOBAL_LOG) if ($GLOBAL_LOG);
    exit BUILDTOOL_TERMINATED;
}

# Handle a fatal signal
sub
handle_fatal_signal
{
    my $sig = $_[0];

    eprint "Caught fatal signal SIG$sig.  Cleaning up and aborting...\n";
    close($GLOBAL_LOG) if ($GLOBAL_LOG);
    exit BUILDTOOL_CRASHED;
}

# Handle a perl warning
sub
handle_warning
{
    dprint @_;
}

# Count CPU's
sub
count_cpus
{
    my $cpus;
    my @lines;
    local *CPU;

    open(CPU, "/proc/cpuinfo") || return 1;
    @lines = <CPU>;
    close(CPU);
    @lines = grep(/^processor/, @lines);
    $cpus = $#lines + 1;
    dprint "Found $cpus processors.\n";
    return ($cpus >= 1 ? $cpus : 1);
}

# Make a directory hierarchy
sub
mkdirhier
{
    my $dir = $_[0];
    my @dirs = split("/", $dir);
    my $path = "";

    dprint "mkdirhier($dir) called.\n";
    foreach $dir (@dirs) {
        $path .= "$dir/";
        if (! -d $path) {
            dprint "mkdirhier() creating \"$path\"\n";
            mkdir($path, 0755) || eprint("Unable to create $path -- $!\n");
        }
    }
    dprint "Something went wrong in mkdirhier()!\n" if (! -d $_[0]);
}

# Spawn a child, return its PID to the parent and exec the child
sub
spawn_cmd
{
    my ($pkg, $logfile) = @_;
    my $pid;

    do {
        if ($pid = fork()) {
            # Parent -- return PID
            nprint "Spawned child process $pid to build $pkg (log file is $logfile)\n";
            return $pid;
        } elsif (defined $pid) {
            # Child -- reset state as needed and jump to build process
            $opt_f = 0;
            $verbosity = 0;
            $slave = 1;
            $master = 0;
            $opt_master = 0;
            $end_stage = "p" if ($end_stage eq "i" || $end_stage eq "a");
            close $GLOBAL_LOG if ($GLOBAL_LOG);
            open(STDOUT, ">/dev/null");
            open(STDIN, "</dev/null");
            if (!open(LOGFILE, ">$logfile")) {
                eprint "Unable to open $logfile -- $!\n";
            } else {
                $GLOBAL_LOG = \*LOGFILE;
                #system("chattr +S $logfile");  # Try to set sync on the log file, fail silently
                open(STDERR, ">&LOGFILE");
                select LOGFILE; $| = 1;
                select STDOUT; $| = 0;
            }
            @packages = ($pkg);
            @failed_pkgs = ();
            &build_process();
            close(LOGFILE) if ($GLOBAL_LOG);
            exit (BUILDTOOL_SUCCESS);
        } elsif ($! !~ /No more processes/ && $! !~ /Resource temporarily unavailable/) {
            &fatal_error("fork() failed -- $!\n");
        }
        # Temporary failure
        dprint "Failed temporarily -- $!\n";
        sleep 5;
    } while (1);
}

# Translate abbreviated variable names into their canonical forms
sub
get_var_name
{
    my $var = $_[0];

    $var =~ tr/[a-z]/[A-Z]/;

    # Commonly shortened variables
    if ($var =~ /^REV/ || $var =~ /^TAG/) {
        $var = "REVISION";
    } elsif ($var =~ /^REL/) {
        $var = "RELEASE";
    } elsif ($var =~ /^VER/) {
        $var = "VERSION";
    } elsif ($var =~ /^SPEC/) {
        $var = "SPECFILE";
    } elsif ($var =~ /^DIR/) {
        $var = "DIRS";
    } elsif ($var =~ /^PATCH/) {
        $var = "PATCHES";
    } elsif ($var =~ /^LOC/) {
        $var = "LOCATIONS";
    } elsif ($var =~ /^DESC/) {
        $var = "DESCRIPTION";
    }
    return $var;
}

# Translate a package type into its default STAGES variable
sub
get_package_stages
{
    my $type = $_[0];

    if ($type eq "srpm") {
        return "sebpa";
    } elsif ($type eq "rpm") {
        return "sbpa";
    } elsif ($type eq "module") {
        return "scpa";
    } elsif ($type eq "image") {
        return "sia";
    } else {
        return "scebpia";
    }
}

# Find the proper location within the image for an output file
sub
place_file
{
    my ($pkg, $file) = @_;
    my $found = 0;

    dprint "place_file(\"$pkg\", \"$file\") called.\n";
    foreach $location (split(",", $pkgs->{$pkg}{LOCATIONS})) {
        my ($regex, $stop, $dest, $image, $subdir);

        # Format is:  /regexp/.path  where . is some delimiter character that
        # tells us whether to check other locations or stop once we match.
        dprint "Testing location \"$location\"\n";
        if ($location !~ m/^\/([^\/]+)\/(.)(\S+)$/) {
            eprint "Location specifier \"$location\" is invalid.\n";
            next;
        }
        ($regex, $stop, $dest) = ($1, $2, $3);
        if ($stop eq "!") {
            # A negative match test.  If we get a match, don't accept it.
            next if ($file =~ $regex);
        } else {
            # No match.  Try next location.
            next if ($file !~ $regex);
        }
        dprint "Match found.\n";
        ($image = $dest) =~ s/^([^\/]+)\/.*$/$1/;
        if (!defined($pkgs->{$image}{TYPE}) || ($pkgs->{$image}{TYPE} ne "image")) {
            qprint "Warning:  Destination \"$dest\" is not a package of type \"image\".\n";
        }
        if (substr($dest, -3, 3) ne substr($file, -3, 3)) {
            my $tmp;

            ($tmp = $file) =~ s/^.*\/([^\/]+)$/$1/;
            $dest = "$dest/$tmp";
        }
        if (-e $dest) {
            &nuke_tree($dest);
        }
        dprint "Linking $dest to $file\n";
        if (!link($file, $dest)) {
            &fail_package($pkg, "package accumulation", "Unable to hard-link to $file from $dest -- $!");
            return $found;
        }
        $found++;
        last if ($stop eq "=");
        dprint "Non-exclusive match.  Continuing on....\n";
    }
    return $found;
}

# Do the initial directory/file creation stuff.  Used to be in the
# bootstrap stage, but it's not parallel-safe.
sub
initial_setup
{
    if (! -d "$builddir") {
        if (!mkdir("$builddir", 0755)) {
            &fatal_error("Cannot create $builddir -- $!\n");
        }
    }
    foreach $dir ("BUILD", "SRPMS", "RPMS", "SPECS", "SOURCES") {
        if (! -d "$builddir/$dir") {
            mkdir("$builddir/$dir", 0755) || &fatal_error("Cannot create $builddir/$dir -- $!\n");
        }
    }
    if (-d $buildroot) {
        nprint "Buildroot $buildroot exists.  I am removing it.\n";
        &nuke_tree($buildroot);
    }
    mkdir($buildroot, 0775);
    if (-f "$ENV{HOME}/.rpmmacros" && -s _) {
        $rpmmacros = "$ENV{HOME}/.rpmmacros";
    } else {
        $rpmmacros = "$basedir/rpmmacros";
        if (!(-f "$basedir/rpmmacros" && -s _)) {
            my $rel_ver = $prodver;

            # Create basic rpmmacros
            $rel_ver =~ s/\.\d+$//;
            open(RPMMACROS, ">$rpmmacros") || &fatal_error("Cannot create $rpmmacros -- $!\n");
            print RPMMACROS "\%_topdir           $builddir\n";
            print RPMMACROS "\%distribution      $prods->{$prod}{DISTRIBUTION}\n" if ($prods->{$prod}{DISTRIBUTION});
            print RPMMACROS "\%packager          $prods->{$prod}{PACKAGER}\n" if ($prods->{$prod}{PACKAGER});
            print RPMMACROS "\%vendor            $prods->{$prod}{VENDOR}\n" if ($prods->{$prod}{VENDOR});
            print RPMMACROS "\%release_version   $rel_ver\n";
            close(RPMMACROS);
        }
    }
    if (-f "$ENV{HOME}/.rpmrc" && -s _) {
        $rpmrc = "$ENV{HOME}/.rpmrc";
    } else {
        $rpmrc = "$basedir/rpmrc";
        if (!(-f "$basedir/rpmrc" && -s _)) {
            # Create basic rpmrc
            open(RPMRC, ">$rpmrc") || &fatal_error("Cannot create $rpmrc -- $!\n");
            print RPMRC "optflags:   i386 $ENV{CFLAGS}\n";
            print RPMRC "optflags:   i486 $ENV{CFLAGS}\n";
            print RPMRC "optflags:   i586 $ENV{CFLAGS}\n";
            print RPMRC "optflags:   i686 $ENV{CFLAGS}\n";
            print RPMRC "macrofiles: /usr/lib/rpm/macros:/usr/lib/rpm/%{_target}/macros:/etc/rpm/macros.specspo:",
                         "/etc/rpm/macros:/etc/rpm/%{_target}/macros:~/.rpmmacros:$rpmmacros\n";
            close(RPMRC);
        }
    }
    chdir("$builddir");
}

# Emulate rm -rf
sub
nuke_tree
{
    my $path = $_[0];
    my @files;
    local *DIR;

    if ((-d $path) && !(-l $path)) {
        opendir(DIR, $path) || return 0;
        @files = readdir(DIR);
        closedir(DIR);
        foreach $f (@files) {
            if ($f ne "." && $f ne "..") {
                &nuke_tree("$path/$f");
            }
        }
        dprint "Removing directory $path\n";
        rmdir $path || return 0;
    } else {
        dprint "Unlinking $path\n";
        unlink($path) || return 0;
    }
    return 1;
}

# Locate the product file for a particular product
sub
find_product_file
{
    my ($prodname, $prodver) = @_;
    my $prod = "$prodname-$prodver";
    my $prodfile;
    my @contents;
    local *PRODFILE;

    dprint "find_product_file($prodname, $prodver)\n";
    if ($prodver) {
        # If it already has the .prod extension, and it exists, return that
        if ($prod =~ /\.prod$/) {
            if (-f $prod) {
                return $prod;
            } elsif (-f "$proddir/$prod") {
                # Just needed a path
                return "$proddir/$prod";
            } else {
                $prod =~ s/\.prod$//;
            }
        } else {
            # It has no .prod extension.  Let's try just giving it one.
            if (-f "$prod.prod") {
                return "$prod.prod";
            } elsif (-f "$proddir/$prod.prod") {
                # Extension and path needed...
                return "$proddir/$prod.prod";
            }
        }
    }

    # Try just the product name
    if ($prodname =~ /\.prod$/) {
        if (-f $prodname) {
            return $prodname;
        } elsif (-f "$proddir/$prodname") {
            # Just needed a path
            return "$proddir/$prodname";
        } else {
            $prodname =~ s/\.prod$//;
        }
    } else {
        # It has no .prod extension.  Let's try just giving it one.
        if (-f "$prodname.prod") {
            return "$prodname.prod";
        } elsif (-f "$proddir/$prodname.prod") {
            # Extension and path needed...
            return "$proddir/$prodname.prod";
        }
    }

    # Well, rats.  We've eliminated the simple cases.  Time to get creative.
    # Find all the product files and search for one that matches
    opendir(DIR, "$proddir");
    @contents = sort(grep($_ =~ /\.prod$/, readdir(DIR)));
    closedir(DIR);
    foreach $prodfile (@contents) {
        my (@lines, @names, @versions);

        dprint "find_product_file():  Searching product file $prodfile for a match...\n";
        open(PRODFILE, "$proddir/$prodfile") || next;
        @lines = <PRODFILE>;
        @names = grep($_ =~ /^\s*name\s*:/i, @lines);
        @versions = grep($_ =~ /^\s*ver(sion)?\s*:/i, @lines);
        if (grep($_ =~ /$prodname/, @names) && grep($_ =~ /$prodver/, @versions)) {
            # Found it.
            dprint "find_product_file():  Match found!\n";
            return "$proddir/$prodfile";
        }
    }
    # Give up.  It doesn't exist.
    return 0;
}

# Parse a product entry line from a file or the command line
sub
parse_product_entry
{
    my ($line, $prodname, $prodver) = @_;
    my ($type, $name, $arch, $module, $filename, $pkgvar, $var, $val);
    my $type_guess = 0;
    my (%pkgvars, @inp);
    my $prod;

    if ($prodname) {
        if ($prodver) {
            $prod = "$prodname-$prodver";
        } else {
            $prod = $prodname;
            $prodver = 0;
        }
    } else {
        $prod = $prodname = $prodver = 0;
    }
    dprint "parse_product_entry(\"$line\", \"$prodname\", \"$prodver\")\n";
    undef %pkgvars;
    undef $module;
    undef $type;
    #@inp = split(/\s+/, $line);
    @inp = ($line =~ m/\s*((?:\S*(?:\"[^\"]+\")?\S*)+)\s*/g);
    pop @inp;  # There will always be an empty value at the end.  Get rid of it.
    dprint "Input is \"", join("\" \"", @inp), "\"\n";
    if ($inp[0] =~ /^(prod|mod|s?rpm|ima?ge?)[^:]*:/) {
        # Line begins with <type>:<name>, like "module:Eterm"
        ($type, $name) = split(":", $inp[0]);
        $type =~ tr/[A-Z]/[a-z]/;
        dprint "parse_product_entry():  Found type \"$type\" and name \"$name\"\n";
        if ($type =~ /^prod/) {
            $type = "product";
        } elsif ($type =~ /^mod/) {
            $type = "module";
        } elsif ($type =~ /^srpm/) {
            $type = "srpm";
        } elsif ($type =~ /^rpm/) {
            $type = "rpm";
        } elsif ($type =~ /^image/) {
            $type = "image";
        } else {
            eprint "$type is not a valid package type.  I'll try to guess the correct one.\n";
            $type = 0;
        }
    }
    if (! $type) {
        # They didn't tell us the type, so let's guess educatedly.
        $type_guess = 1;
        ($name = $inp[0]) =~ s/^\w*://;
        dprint "Guessing type of \"$name\"\n";
        if ($name =~ /src\.rpm/) {
            # Name ends with src.rpm.  That's an easy one.
            $type = "srpm";
        } elsif ($name =~ /\.rpm/) {
            # Name ends with .rpm but it's not a source RPM.  That's easy too.
            $type = "rpm";
        } else {
            my @contents = ();

            # Check to see if there is a product file for it
            if (opendir(DIR, "$proddir")) {
                @contents = readdir(DIR);
                closedir(DIR);
            }
            @contents = grep($_ =~ /^$name-?/ && $_ =~ /\.prod$/, @contents);
            # Product files win over modules because they contain more detail
            # about the package and are more likely to succeed.
            if ($#contents >= 0) {
                $type = "product";
                ($name = $contents[0]) =~ s/\.prod$//;
            } else {
                $type = "module";
            }
        }
    }
    if ($type_guess) {
        nprint "$progname:  Note:  Since you didn't specify, I have guessed that \"$name\" is a $type.\n";
    }
    if ($name =~ /\/.+$/) {
        ($module = $name) =~ s/^([^\/]+)(.+)$/$1/;
        $name =~ s/^(.*)\/([^\/]+)$/$2/;
    } else {
        $module = $name;
    }
    # The rest of the line is whitespace-delimited sets of var=value
    shift @inp;
    dprint "Input is now \"", join("\" \"", @inp), "\"\n";
    foreach $varval (@inp) {
        ($var, $val) = split("=", $varval);
        $var = &get_var_name($var);
        $pkgvars{$var} = $val;
    }
    if ($type eq "product") {
        my ($pname, $pver);

        # Separate name and version
        if ($pkgvars{VERSION}) {
            ($pname, $pver) = ($name, $pkgvars{VERSION});
            $name = "$pname-$pver";
        } elsif ($name =~ /^(\S+)-((?:\d|us|a|alpha|b|beta)[^-]+)$/) {
            ($pname, $pver) = ($1, $2);
        } else {
            $pver = 0;
        }

        # Recursively convert products into their component packages
        $prods->{$name}{PRODUCT} = $prod;
        dprint "parse_product_entry():  Parent product of $name is $prod.\n";
        if (! &parse_prod_file($pname, $pver)) {
            dprint "parse_product_entry():  parse_prod_file($pname, $pver) failed.\n";
            undef $prods->{$name}{PRODUCT};
            if ($type_guess) {
                # If this was a guess, a potential infinite loop exists if we try
                # to parse the product entry again.  So just punt at this point.
                dprint "parse_product_entry() returning 0.\n";
                return 0;
            } else {
                my $tmp;

                $line =~ s/^[^:]+://;
                $tmp = &parse_product_entry($line, $prodname, $prodver);
                dprint "parse_product_entry():  parse_product_entry(\"$line\", $prodname, $prodver) returned $tmp, so I will to.\n";
                return $tmp;
            }
        }
        dprint "parse_product_entry():  parse_prod_file($pname, $pver) succeeded, so I'm returning 1.\n";
        return 1;
    }

    dprint "parse_product_entry():  Module is $module, name is $name\n";
    # Add defaults for stuff that is required
    if ($type eq "module" || $type eq "image") {
        # Anything needed here?
    } elsif ($type eq "srpm" || $type eq "rpm") {
        if ($name =~ /^(\S+)\.(\w+)\.rpm$/) {
            ($name, $arch) = ($1, $2);
        } else {
            $arch = ($type eq "srpm" ? "src" : "i386");
        }
        if (!defined $pkgvars{RELEASE}) {
            if ($name !~ /^\S+-[^-]+-[^-]+$/) {
                eprint "I wasn't given enough information about the $name package in $prodfile.  For RPM/SRPM\n";
                eprint "packages, the version and release information must be specified as variables or\n";
                eprint "embedded in the package name.  I'm going to have to skip that one.\n";
                return 0;
            } else {
                ($tmp = $name) =~ s/^\S+-[^-]+-//;
                $name =~ s/-[^-]+$//;
                $pkgvars{RELEASE} = $tmp;
            }
        }
        if (!defined $pkgvars{VERSION}) {
            if ($name !~ /^\S+-[^-]+$/) {
                eprint "I wasn't given enough information about the $name package in $prodfile.  For RPM/SRPM\n";
                eprint "packages, the version and release information must be specified as variables or\n";
                eprint "embedded in the package name.  I'm going to have to skip that one.\n";
                return 0;
            } else {
                ($tmp = $name) =~ s/^(\S+)-([^-]+)$/$2/;
                $name =~ s/^(\S+)-([^-]+)$/$1/;
                $pkgvars{VERSION} = $tmp;
            }
        }
        $filename = sprintf("%s$name-$pkgvars{VERSION}-$pkgvars{RELEASE}.$arch.rpm", ($module ? "$module/" : ""));
    }

    # Check for duplicates
    if (grep($_ eq $name, @packages)) {
        eprint "I already have $name as a $pkgs->{$name}{TYPE} package in $pkgs->{$name}{PRODUCT}.\n";
        eprint "I will ignore the duplicate entry found in $prodname $prodver\n";
        return 0;
    }
    # Now that we've got the name/version/release in their final forms, set up the data structures.
    $pkgs->{$name}{TYPE} = $type;
    $pkgs->{$name}{MODULE} = $module;
    $pkgs->{$name}{FILENAME} = ($filename ? $filename : $module);
    dprint "parse_product_entry():  New package:  $name (module $pkgs->{$name}{MODULE}, "
            . "filename $pkgs->{$name}{FILENAME}) is a $pkgs->{$name}{TYPE}\n";
    foreach $pkgvar (keys %pkgvars) {
        if ($pkgvars{$pkgvar} !~ /^$/) {
            $pkgs->{$name}{$pkgvar} = $pkgvars{$pkgvar};
            dprint "parse_product_entry():  Added variable $pkgvar to package $name with value \"$pkgs->{$name}{$pkgvar}\"\n";
        }
    }
    # Go through each propogated variable.  If there is no assigned value for that
    # variable for the current package, see if it has a value for the parent product
    # of that package.  If not, try the parent product of that product, and continue
    # going back through the product hierarchy until we find a value or run out.
    foreach $pkgvar ("REVISION", "LOCATIONS", "RPMCMD", "TAR", "ZIP", "STAGES", "CVSROOT", "ARCH") {
        if (! $pkgs->{$name}{$pkgvar}) {
            my ($pkg, $val) = undef;

            dprint "parse_product_entry():  No value for the variable $pkgvar for $name.\n";
            for ($pkg = $prod; $pkg; $pkg = $prods->{$pkg}{PRODUCT}) {
                dprint "parse_product_entry():  Checking $pkg for $pkgvar\n";
                if ($prods->{$pkg}{$pkgvar}) {
                    $val = $prods->{$pkg}{$pkgvar};
                    dprint "parse_product_entry():  Found fallback value $val in product $pkg\n";
                    last;
                }
            }
            if ($val) {
                $pkgs->{$name}{$pkgvar} = $val;
            }
        }
    }
    if (defined($pkgs->{$name}{REVISION}) && $pkgs->{$name}{REVISION} =~ /^head$/i) {
        # This goes here to avoid the fallback mechanism above.
        undef $pkgs->{$name}{REVISION};
    }
    if (!defined $pkgs->{$name}{STAGES}) {
        $pkgs->{$name}{STAGES} = &get_package_stages($type);
    }
    push @packages, $name;
    $pkgs->{$name}{PRODUCT} = ($prod ? $prod : "unknown-product");
    dprint "parse_product_entry():  Parent product of $name set to $prod.  I'm done, returning 1.\n";
    return 1;
}

# Parse product definition files recursively to establish
# all the products we need to work with and what packages or
# other products compose them.
sub
parse_prod_file
{
    my ($prodname, $prodver) = @_;
    my ($prodfile, $skip_to_name, $skip_to_next_ver, $found, $line);
    my $prod = "$prodname-$prodver";
    local *PROD;

    dprint "parse_prod_file($prodname, $prodver)\n";
    if (!($prodfile = &find_product_file($prodname, $prodver))) {
        dprint "parse_prod_file():  find_product_file() failed.  Returning 0.\n";
        return 0;
    }
    dprint "parse_prod_file():  Found product file \"$prodfile\"\n";
    open(PROD, "$prodfile") || return 0;

    ($skip_to_name, $skip_to_next_ver, $found) = (1, 0, 0); 
    while (<PROD>) {
        chomp($line = $_);
        dprint "parse_prod_file():  Parsing $prodfile:  \"$line\"\n";
        $line =~ s/^\s*(.*\S)\s*$/$1/;  # Strip leading and trailing whitespace
        next if ($line =~ /^\#/ || $line !~ /\S/);
        next if ($skip_to_name && $line !~ /^name\s*:/i);
        next if ($skip_to_next_ver && $line !~ /^ver(sion)?\s*:/i);
        if ($skip_to_name) {
            $line =~ s/^[^:]+:\s*//;
            if ($line eq $prodname) {
                dprint "parse_prod_file():  Found product name match\n";
                $skip_to_name = 0;
                $skip_to_next_ver = 1;
                next;
            }
        } elsif ($line =~ /^name\s*:/) {
            # New product.  Time to quit.
            last;
        } elsif ($skip_to_next_ver) {
            $line =~ s/^[^:]+:\s*//;
            next if ($line ne $prodver && $prodver);
            # Found it!
            if ($line eq $prodver) {
                dprint "parse_prod_file():  Found product version match.  Time to parse the product.\n";
            } else {
                dprint "parse_prod_file():  No product version given.  Using first entry:  $line\n";
                $prodver = $line;
                $prod = "$prodname-$prodver";
            }
            ($found, $skip_to_next_ver) = (1, 0);
            push @products, $prod;
            next;
        } elsif ($line =~ /^ver(sion)?\s*:/) {
            # New version.  Time to quit.
            last;
        } else {
            dprint "parse_prod_file():  Checking \"$line\" for product variables.\n";
            if ($line !~ /^(prod|mod|s?rpm|ima?ge?)/i && $line =~ /^([^ \t:]+)\s*:\s*(\S+.*)$/) {
                my ($var, $val);

                # The regexp above should only match var:value (a product variable)
                ($var, $val) = ($1, $2);
                $var = &get_var_name($var);
                dprint "parse_prod_file():  Product variable for $prod:  $var -> $val\n";
                $prods->{$prod}{$var} = $val;
#                if ($prods->{$prod}{VARS} !~ /$var/) {
#                    $prods->{$prod}{VARS} .= "$var ";
#                }
            } else {
                my $tmp;

                dprint "parse_prod_file():  Calling parse_product_entry()...\n";
                $tmp = &parse_product_entry($line, $prodname, $prodver);
                dprint "parse_prod_file():  parse_product_entry() returned $tmp\n";
            }
        }
    }
    dprint "parse_prod_file():  Closing file $prodfile and returning $found\n";
    close(PROD);
    return ($found);
}

# What to do if a package fails
sub
fail_package
{
    my ($pkg, $stage, $msg) = @_;

    push @failed_pkgs, $pkg;
    $failure->{$pkg}{STAGE} = $stage;
    if ($msg) {
        $failure->{$pkg}{MESSAGE} = $msg;
        eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage:  $failure->{$pkg}{MESSAGE}.\n";
    } else {
        eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage.\n";
    }
    exit(BUILDTOOL_PACKAGE_FAILED) if (! $opt_f);
    @packages = grep($_ ne $pkg, @packages);
    return 0;
}

sub
fetch_package
{
    my $cmd = $_[0];
    my ($err, $msg, $line) = undef;
    local *REVTOOL;

    dprint "About to run $cmd\n";
    if (!open(REVTOOL, "$cmd 2>&1 |")) {
        $err = REVTOOL_COMMAND_FAILED;
        $msg = "Execution of \"$cmd\" failed -- $!";
        last;
    }
    while (<REVTOOL>) {
        chomp($line = $_);
        if ($debug) {
            nprint "From revtool -> $line\n";
        } else {
            nprint "$line\n";
        }
        next if ($line =~ /^\[debug:/);
        # Check the output for errors
        if ($line =~ /^revtool:\s*Error/) {
            ($msg = $line) =~ s/^revtool:\s*Error:\s*//;
        }
    }
    close(REVTOOL);
    $err = $?;
    dprintf "\"$cmd\" returned $err (%d)\n", $err >> 8;
    return ($err >> 8, $msg);
}

# Build RPMS from the spec file
sub
build_rpms
{
    my ($pkg, $specfile) = @_;
    my ($cmd, $rpm, $line, $target);
    my ($err, $msg, $srpm) = (0, 0, 0);
    my (@failed_deps, @not_found, @spec_errors, @out_files);
    local *RPM;

    $rpm = ($pkgs->{$pkg}{RPMCMD} ? $pkgs->{$pkg}{RPMCMD} : "rpm");
    $target = ($pkgs->{$pkg}{ARCH} ? "--target=$pkgs->{$pkg}{ARCH}" : ($main::target ? $main::target : ""));
    $cmd = "$rpm --rcfile \"/usr/lib/rpm/rpmrc:$rpmrc\" --buildroot=\"$buildroot/$pkg-root\" $target -ba $specfile";
    dprint "About to run \"$cmd\"\n";
    if (!open(RPM, "$cmd </dev/null 2>&1 |")) {
        return (1, "Execution of \"$cmd\" failed -- $!", undef);
    }
    $err = 0;
    while (<RPM>) {
        chomp($line = $_);
        nprint "$line\n";
        if ($line =~ /^Wrote:\s+(\S+\.\w+\.rpm)$/) {
            push @out_files, $1;
            if ($line =~ /src\.rpm$/) {
                ($srpm = $line) =~ s/^Wrote:\s+//;
            }
        } elsif ($line =~ /^line \d+: [^:]+: /
                 || $line =~ /^Failed to find \w+:/
                 || $line =~ /^Symlink points to BuildRoot: /) {
            $err = 1;
            push @spec_errors, $line;
        } elsif ($line =~ /^Bad exit status from/) {
            $err = 1;
            $line =~ s/^Bad exit status from \S+ \((%\w+)\)/$1/;
            $msg = "The RPM $line stage exited abnormally";
            last;
        } elsif ($line =~ /^error: failed build dependencies:/) {
            $err = 1;
            while (<RPM>) {
                chomp($line = $_);
                last if ($line !~ /is needed by/);
                $line =~ s/^\s+(\S+)\s+is needed by .*$/$1/;
                push @failed_deps, $line;
            }
            $msg = sprintf("Building this SRPM requires the following packages:  %s", join(" ", @failed_deps));
            last;
        } elsif ($line =~ /^Architecture is not included:/) {
            $err = 1;
            $line =~ s/^Architecture is not included:\s+//;
            $msg = "This SRPM does not build on the $line architecture";
        } elsif ($line =~ /^File (.*): No such file or directory$/
                 || $line =~ /^Bad file: (.*): No such file or directory$/
                 || $line =~ /^File is not a regular file: (.*)$/
                 || $line =~ /^Unable to open icon (\S+):$/
                 || $line =~ /^No (patch number \d+)$/
                 || $line =~ /^Could not open \%files file (\S+): No such file or directory$/
                 || $line =~ /^File not found(?: by glob)?: (.*)$/) {
            $err = 1;
            push @not_found, $1;
        }
    }
    close(RPM);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0 && $err == 0) {
        $err = 1;
        $msg = "Unhandled RPM build error";
    } elsif ($#not_found != -1) {
        $msg = sprintf("The following were expected by rpm, but no matching files were found:  \"%s\"",
                       join("\", \"", @not_found));
    } elsif ($#spec_errors != -1) {
        $msg = sprintf("The spec file contains the following errors:  \"%s\"", join("\", \"", @spec_errors));
    }

    if ($#out_files >= 0) {
        $pkgs->{$pkg}{OUTFILES} = join(" ", @out_files);
    }
    dprint "build_rpms():  Returning $err, $msg, $srpm\n";
    return ($err, $msg, $srpm);
}

#
# The build process stages
#
sub
do_bootstrap_stage
{
    my ($line, $err, $msg);
    my @p;
    local *RPMMACROS;
    local *RPMRC;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    qprint "$progname:  Entering the bootstrap stage.  (${\(&get_timestamp())})\n";
    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /s/) {
            nprint "$progname:  Skipping bootstrap stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting bootstrap stage for the \"$pkg\" package....\n";
        $filename = $pkgs->{$pkg}{FILENAME};
        if ($pkgs->{$pkg}{CVSROOT}) {
            $cvsroot = "-D $pkgs->{$pkg}{CVSROOT}";
        } else {
            $cvsroot = "";
        }
        if ($pkgs->{$pkg}{REVISION}) {
            $tag = "-t $pkgs->{$pkg}{REVISION}";
        } else {
            $tag = "";
        }
        dprint "Checking for $filename\n";
        # If it already exists , go on.
        if ((($pkgs->{$pkg}{TYPE} eq "module" || $pkgs->{$pkg}{TYPE} eq "image") && -d $filename)
            || (($pkgs->{$pkg}{TYPE} eq "srpm" || $pkgs->{$pkg}{TYPE} eq "rpm") && -f $filename && -s _)) {
            nprint "$progname:  $filename already exists.  I'll assume it's the right one.\n";
            nprint "$progname:  Bootstrap stage for \"$pkg\" is complete.\n";
            next;
        }
        $cmd = "$revtool $cvsroot $tag -g $filename";
        ($err, $msg) = &fetch_package($cmd);  # Download the package using revtool
        if ($err) {
            &fail_package($pkg, "bootstrap", $msg);
            next;
        }
        if (!((($pkgs->{$pkg}{TYPE} eq "module" || $pkgs->{$pkg}{TYPE} eq "image") && -d $filename)
            || (($pkgs->{$pkg}{TYPE} eq "srpm" || $pkgs->{$pkg}{TYPE} eq "rpm") && -f $filename && -s _))) {
            # If it's not there, we must've missed the error.
            &fail_package($pkg, "bootstrap", "Unhandled error condition");
            next;
        }

        # Note:  The following exists solely because CVS is too lame to handle symlinks.
        if (-d $filename && -f "$filename/.buildtool.symlinks") {
            local *SL;

            if (open(SL, "$filename/.buildtool.symlinks")) {
                while (<SL>) {
                    my ($link_from, $link_to, $line);

                    chomp($line = $_);
                    next if ($line =~ /^\s*\#/ || $line !~ / -> /);
                    ($link_from, $link_to) = split(" -> ", $line);
                    dprint "Creating symlink:  $link_from -> $link_to\n";
                    if (!symlink($link_to, "$filename/$link_from")) {
                        qprint "Warning:  Unable to symlink $link_from to $link_to -- $!\n";
                    }
                }
                close(SL);
            }
        }

        nprint "$progname:  Bootstrap stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Bootstrap stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_compose_stage
{
    my ($specfile, $target, $pn, $dir, $line, $src, $tarball, $cwd);
    my ($err, $msg, $srpm) = (0, 0, 0);
    my (@contents, @tmp, @dirs, @sfiles, @srcs);
    my @p;
    local *DIR;
    local *CMD;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    qprint "$progname:  Entering the compose stage.  (${\(&get_timestamp())})\n";
    chomp($cwd = `pwd`);

    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /c/) {
            nprint "$progname:  Skipping compose stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting compose stage for the \"$pkg\" package....  (${\(&get_timestamp())})\n";

        # The first step is to examine the module directory to find
        # the names of the vendor source files/directories and the spec file.
        if (! chdir("$cwd/$pkgs->{$pkg}{MODULE}")) {
            &fail_package($pkg, "compose", "Could not chdir into $cwd/$pkgs->{$pkg}{MODULE} -- $!");
            next;
        }
        opendir(DIR, "$builddir/SRPMS");
        @contents = readdir(DIR);
        closedir(DIR);
        @tmp = grep($_ =~ /^$pkg-([^-]+)-([^-]+)\.(?:no)?src\.rpm$/, @contents);
        if ($#tmp >= 0) {
            $srpm = $tmp[0];
            if ($#tmp > 0) {
                nprint "$progname:  Warning:  Multiple target SRPM's found in $pkgs->{$pkg}{MODULE}.\n";
                nprint "$progname:  Assuming that $srpm is the correct one.\n";
            }
        } else {
            $srpm = 0;
        }
        if ($srpm) {
            # The target SRPM already exists.  Skip this stage.
            nprint "$progname:  The target SRPM for \"$pkg\" already exists in $cwd/$pkgs->{$pkg}{MODULE}.\n";
            nprint "$progname:  I'll assume it's the right one.  Compose stage for \"$pkg\" is complete.\n";
            # (?:) means "don't include this as a $<num> variable"
            $srpm =~ m/^(\S+)-([^-]+)-([^-]+)\.(?:no)?src\.rpm$/;
            ($pkgs->{$pkg}{VERSION}, $pkgs->{$pkg}{RELEASE}) = ($2, $3);
            $pkgs->{$pkg}{FILENAME} = "$builddir/SRPMS/$srpm";
            next;
        }

        opendir(DIR, ".");
        @contents = readdir(DIR);
        closedir(DIR);
        if ($pkgs->{$pkg}{SPECFILE} && -f $pkgs->{$pkg}{SPECFILE}) {
            # If they gave us the spec file and it exists, use that.
            $specfile = $pkgs->{$pkg}{SPECFILE};
            dprint "User specified a spec file:  $specfile\n";
        } else {
            # First choice:  Exactly one file named <pkg>-<distro>.spec
            ($pn = $prodname) =~ s/^va-//;
            @tmp = grep($_ =~ /^($pkg-)?(va-)?$pn\.spec/, @contents);
            if ($#tmp != 0) {
                # Second choice:  Exactly one file named <pkg>.spec
                @tmp = grep($_ =~ /^$pkg\.spec/, @contents);
                if ($#tmp != 0) {
                    # Third choice:  The first match to *.spec*
                    @tmp = grep($_ =~ /\.spec/, @contents);
                }
            }
            $specfile = $tmp[0];
            if (!defined $specfile || $specfile =~ /^$/) {
                # Our attempt to guess failed.  They need to specify the spec file in the .prod file.
                &fail_package($pkg, "compose", "No spec file could be located in $pkgs->{$pkg}{MODULE}");
                next;
            }
        }

        undef @srcs;
        if ($pkgs->{$pkg}{SRCS}) {
            @srcs = split(",", $pkgs->{$pkg}{SRCS});
        } else {
            my $fname;

            foreach $fname (@contents) {
                next if ($fname =~ /^(CVS|SCCS|RCS|BitKeeper)$/);
                next if ($fname =~ /^\./);
                next if ($fname =~ /\.spec(\.in)?$/);
                if (-d $fname) {
                    push @srcs, "$fname:$fname.tar.gz";
                } else {
                    push @srcs, $fname;
                }
            }
        }

        foreach $src (@srcs) {
            my ($src_files, $tarball) = split(":", $src);

            $src_files =~ s/\&/ /g;
            if ($tarball) {
                my $zip;

                if ($pkgs->{$pkg}{TAR}) {
                    $cmd = $pkgs->{$pkg}{TAR};
                    $cmd =~ s/\%f/$src_files/;
                    $cmd =~ s/\%t/$builddir\/SOURCES\/$tarball/;
                } else {
                    if ($pkgs->{$pkg}{ZIP}) {
                        $zip = "--use-compress-program=\"$pkgs->{$pkg}{ZIP}\"";
                    } elsif ($src =~ /(gz|Z)$/) {
                        $zip = "--use-compress-program=gzip";
                    } elsif ($src =~ /\.bz2$/) {
                        $zip = "--use-compress-program=bzip2";
                    }
                    $cmd = "tar --exclude CVS --exclude RCS --exclude BitKeeper --exclude SCCS --exclude .cvsignore"
                            . " $zip -cf $builddir/SOURCES/$tarball $src_files";
                }
                dprint "Creating $tarball:  $cmd\n";
                unlink($tarball);
                if (!open(CMD, "$cmd 2>&1 |")) {
                    &fail_package($pkg, "compose", "Execution of \"$cmd\" failed -- $!");
                    $err = 1;
                    last;
                }
                $err = 0;
                while (<CMD>) {
                    chomp($line = $_);
                    nprint "tar output -> $line\n";
                }
                close(CMD);
                dprint "\"$cmd\" returned $?\n";
                if ($?) {
                    &fail_package($pkg, "compose", "Creation of vendor source tarball $tarball from failed");
                    $err = 1;
                    last;
                }
            } else {
                my $rc;

                $src_files =~ s/\&/ /g;
                dprint "Copying \"$src_files\" to $builddir/SOURCES/\n";
                $rc = system("cp -f $src_files $builddir/SOURCES/") >> 8;
                if ($rc) {
                    &fail_package($pkg, "compose", "Unable to copy $src_files to $builddir/SOURCES/ -- $!");
                    $err = 1;
                    last;
                }
            }
        }
        if ($err) {
            next;
        }

        # Now build the new SRPM from the new vendor source tarball and the spec file.
        ($err, $msg, $srpm) = &build_rpms($pkg, $specfile);
        dprint "do_compose_stage():  build_rpms($pkg, $specfile) returned $err, $msg, $srpm\n";
        if ($err) {
            &fail_package($pkg, "compose", $msg);
            next;
        }
        dprint "Module apparently just built its SRPM as $srpm\n";

        # Update the values for FILENAME, VERSION, and RELEASE
        $pkgs->{$pkg}{FILENAME} = $srpm;
        $srpm =~ s/^(\S+)\/([^\/]+src\.rpm)$/$2/;
        $srpm =~ m/^(\S+)-([^-]+)-([^-]+)\.(?:no)?src\.rpm$/;
        ($pkgs->{$pkg}{VERSION}, $pkgs->{$pkg}{RELEASE}) = ($2, $3);
        dprint "Filename is $pkgs->{$pkg}{FILENAME}, version is $pkgs->{$pkg}{VERSION}, release is $pkgs->{$pkg}{RELEASE}\n";

        nprint "$progname:  Compose stage for \"$pkg\" is complete.  (${\(&get_timestamp())})\n";
    }
    chdir($cwd);
    qprint "$progname:  Compose stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_explode_stage
{
    my ($cmd, $err, $msg, $line, $specfile, $rpm) = undef;
    my @manifest;
    my @p;
    local *RPM;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    qprint "$progname:  Entering the explode stage.  (${\(&get_timestamp())})\n";

    foreach $pkg (@p) {
        undef @manifest;
        if ($pkgs->{$pkg}{STAGES} !~ /e/ && $pkgs->{$pkg}{STAGES} !~ /x/) {
            nprint "$progname:  Skipping explode stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting explode stage for the \"$pkg\" package....\n";
        $rpm = ($pkgs->{$pkg}{RPMCMD} ? $pkgs->{$pkg}{RPMCMD} : "rpm");

        # Examine the SRPM and figure out everything it contains.
        $cmd = "$rpm --rcfile $rpmrc -qlp $pkgs->{$pkg}{FILENAME}";
        dprint "About to run \"$cmd\"\n";
        if (!open(RPM, "$cmd 2>&1 |")) {
            &fail_package($pkg, "explode", "Execution of \"$cmd\" failed -- $!");
            next;
        }
        if (defined $pkgs->{$pkg}{SPECFILE}) {
            $specfile = $pkgs->{$pkg}{SPECFILE};
        } else {
            undef $specfile;
        }
        while (<RPM>) {
            chomp($line = $_);
            dprint "RPM contents -> $line\n";
            push @manifest, $line;  # Add the file to the manifest
            if ($line =~ /\.spec(\.in)?$/) {
                if (!defined $specfile) {
                    $specfile = $line;
                    dprint "Found spec file as $specfile\n";
                } elsif ($specfile eq $line) {
                    dprint "Found spec file $specfile as predicted.\n";
                } else {
                    qprint "$progname:  Warning:  $pkgs->{$pkg}{FILENAME} contains the spec file $line\n";
                    qprint "$progname:  which is different from the one I was told to expect ($specfile).\n";
                    qprint "$progname:  I will ignore the auto-detected one as requested, but this may be a problem.\n";
                }
            }
        }
        close(RPM);
        dprint "\"$cmd\" returned $?\n";
        if ($? != 0) {
            # FIXME:  What to do here?
        }
        if (! $specfile) {
            &fail_package($pkg, "explode", "Unable to locate spec file in SRPM");
            next;
        }
        # We'll use these later, so they MUST be defined for
        # any package we plan on actually building later.
        $pkgs->{$pkg}{SPECFILE} = "$builddir/SPECS/$specfile";
        $pkgs->{$pkg}{MANIFEST} = join(" ", @manifest);

        # Check for each of those files.
        $err = 0;
        foreach $piece (@manifest) {
            # FIXME:  Need to handle _topdir for people who did their own rpm* files.
            if (($piece =~ /\.spec(\.in)?$/ && -f "$builddir/SPECS/$piece")
                || (-f "$builddir/SOURCES/$piece")) {
                next;
            }
            $err = 1;  # Something is missing.  We must explode this SRPM.
            last;
        }
        # If everything is there, go on.
        if (! $err) {
            nprint "$progname:  SRPM has already been completely exploded.\n";
            nprint "$progname:  Explode stage for \"$pkg\" is complete.\n";
            next;
        }

        # Explode the SRPM into its components
        $cmd = "rpm --rcfile $rpmrc -U $pkgs->{$pkg}{FILENAME}";
        dprint "About to run \"$cmd\"\n";
        if (!open(RPM, "$cmd 2>&1 |")) {
            &fail_package($pkg, "explode", "Execution of \"$cmd\" failed -- $!");
            next;
        }
        $err = 0;
        while (<RPM>) {
            chomp($line = $_);
            nprint "$line\n";
            if ($line !~ /^$/) {
                # Any output from this command is an error.
                $err = 1;
                $msg = "$line";
                last;
            }
        }
        close(RPM);
        dprint "\"$cmd\" returned $?\n";
        if ($? != 0) {
            # FIXME:  What to do here?
        }
        if ($err) {
            &fail_package($pkg, "explode", $msg);
            next;
        }
        nprint "$progname:  Explode stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Explode stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_build_stage
{
    my ($cmd, $line, $specfile, $rpm, $tmp, $target) = undef;
    my ($target_age, $orig_age, $spec_age);
    my ($err, $msg, $srpm) = (0, 0, 0);
    my @p;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    qprint "$progname:  Entering the build stage.  (${\(&get_timestamp())})\n";

    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /b/) {
            nprint "$progname:  Skipping build stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting build stage for the \"$pkg\" package....  (${\(&get_timestamp())})\n";

        if ($pkgs->{$pkg}{TYPE} eq "rpm") {
            my $arch;

            # Binary package.  Just move it into place.
            $pkgs->{$pkg}{FILENAME} =~ m/\.(\w+)\.rpm/;
            $arch = $1;
            dprint "Copying $pkgs->{$pkg}{FILENAME} to $builddir/RPMS/$arch\n";
            &mkdirhier("$builddir/RPMS/$arch");
            system("cp $pkgs->{$pkg}{FILENAME} $builddir/RPMS/$arch/");
        } else {
            # Check for a target SRPM that is newer than the original SRPM and the
            # spec file.  If such an SRPM exists, skip the build stage for this package.
            $target = "$builddir/SRPMS/$pkg" . "-"
                       . "$pkgs->{$pkg}{VERSION}" . "-" . "$pkgs->{$pkg}{RELEASE}.src.rpm";
            $specfile = $pkgs->{$pkg}{SPECFILE};
            dprint "Target SRPM is $target\n";
            if (-f $target) {
                $target_age = -M _;
                $orig_age = -M $pkgs->{$pkg}{FILENAME};
                $spec_age = -M $specfile;
                dprint "File ages:  $orig_age for $pkgs->{$pkg}{FILENAME}, $target_age for $target,"
                        . " and $spec_age for $specfile\n";
                if ($target_age < $spec_age && $target_age < $orig_age) {
                    nprint "$progname:  The target SRPM already exists.\n";
                    nprint "$progname:  Build stage for \"$pkg\" is complete.\n";
                    next;
                }
            }

            # Rebuild from the spec file
            ($err, $msg, $srpm) = &build_rpms($pkg, $specfile);
            dprint "do_build_stage():  build_rpms($pkg, $specfile) returned $err, $msg, $srpm\n";
            if ($err) {
                &fail_package($pkg, "build", $msg);
            }
        }
        nprint "$progname:  Build stage for \"$pkg\" is complete.  (${\(&get_timestamp())})\n";
    }
    qprint "$progname:  Build stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_package_stage
{
    my ($path, $version, $release, $type);
    my @outfiles;
    my @contents;
    my @p;
    local *DIR;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    qprint "$progname:  Entering the package accumulation stage.  (${\(&get_timestamp())})\n";

    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /p/) {
            nprint "$progname:  Skipping package accumulation stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting package accumulation stage for the \"$pkg\" package....\n";
        $type = $pkgs->{$pkg}{TYPE};
        $version = $pkgs->{$pkg}{VERSION};
        $release = $pkgs->{$pkg}{RELEASE};
        undef @outfiles;

        dprint "Checking for output files for $pkg $version-$release\n";
        if ($pkgs->{$pkg}{OUTFILES}) {
            dprint "Output files [$pkgs->{$pkg}{OUTFILES}] saved from earlier.\n";
            @outfiles = split(" ", $pkgs->{$pkg}{OUTFILES});
        } else {
            if ($type eq "srpm" || $type eq "module") {
                # Find all the RPM's installed by this package
                dprint "Opening directory $builddir/SRPMS to scan for output files.\n";
                opendir(DIR, "$builddir/SRPMS") || &fatal_error("Cannot open directory $builddir/SRPMS -- $!\n");
                @contents = readdir(DIR);
                foreach $rpm (@contents) {
                    if ($rpm =~ /^\Q$pkg-\E\S*\Q$version-$release\E\.(?:no)?src\.rpm$/) {
                        dprint "Got output file $rpm\n";
                        push @outfiles, "$builddir/SRPMS/$rpm";
                    }
                }
                closedir(DIR);

                dprint "Opening directory $builddir/RPMS to scan for output files.\n";
                @contents = glob("$builddir/RPMS/*/*-$version-$release.*.rpm");
                foreach $rpm (@contents) {
                    my $srpm;

                    dprint "Checking $rpm\n";
                    if (defined $srpm_of_rpm{$rpm}) {
                        $srpm = $srpm_of_rpm{$rpm};
                    } else {
                        $srpm = `rpm -qp $rpm --queryformat \"%{SOURCERPM}\"`;
                        if ($? != 0) {
                            # FIXME:  What to do here?
                        }
                        $srpm_of_rpm{$rpm} = $srpm;
                    }
                    if ($srpm =~ /^\Q$pkg-\E\S*\Q$version-$release\E\.(?:no)?src\.rpm$/) {
                        dprint "Got output file $rpm\n";
                        push @outfiles, $rpm;
                    }
                }
            } elsif ($type eq "rpm") {
                my ($filename, $arch, $outfile);

                ($filename = $pkgs->{$pkg}{FILENAME}) =~ s/^.*\/([^\/]+)$/$1/;
                ($arch = $filename) =~ s/^.*\.(\w+)\.rpm$/$1/;
                $outfile = "$builddir/RPMS/$arch/$filename";
                dprint "Output RPM is $outfile\n";
                if (-f $outfile) {
                    push @outfiles, $outfile;
                }
            }
        }

        if ($#outfiles == -1) {
            &fail_package($pkg, "package accumulation", "No output RPM's were found");
            next;
        }
        dprint "Output files for $pkg:  ", join(" ", @outfiles), "\n";

        # Move each RPM into the appropriate place
        foreach $rpm (@outfiles) {
            my $found;

            $found = &place_file($pkg, $rpm);
            if ($found == 0) {
                qprint "Warning:  No location found matching $rpm\n";
            } else {
                dprint "Found $found locations for $rpm\n";
            }
        }
        nprint "$progname:  Package accumulation stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Package accumulation stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_iso_stage
{
    my @p;
    my ($cmd, $desc, $label, $iso, $bootimg, $ignore, $prod, $line, $err);
    local *MKHYBRID;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    qprint "$progname:  Entering the ISO image stage.  (${\(&get_timestamp())})\n";
    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /i/) {
            nprint "$progname:  Skipping ISO image stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting ISO image stage for the \"$pkg\" package....\n";

        $prod = $pkgs->{$pkg}{PRODUCT};
        if ($pkgs->{$pkg}{DESCRIPTION}) {
            $desc = $pkgs->{$pkg}{DESCRIPTION};
        } else {
            $desc = $prod;
        }
        if ($pkgs->{$pkg}{LABEL}) {
            $label = $pkgs->{$pkg}{LABEL};
        } else {
            ($label = $prod) =~ s/-/_/g;
        }
        if ($pkgs->{$pkg}{ISO}) {
            $iso = $pkgs->{$pkg}{ISO};
        } else {
            my $ver;

            $ver = ($pkgs->{$pkg}{VERSION} ? "-$pkgs->{$pkg}{VERSION}" : "");
            $iso = "$pkg$ver.iso";
        }
        $bootimg = ($pkgs->{$pkg}{BOOTIMG} ? "-b $pkgs->{$pkg}{BOOTIMG} -c boot.cat" : "");
        $ignore = "-m CVS -m RCS -m BitKeeper -m SCCS -m .cvsignore";
        $cmd = "mkhybrid -o $iso -a -A \"$desc\" -V \"$label\" $ignore $bootimg -T -r -J -v $pkg";
        dprint "About to run \"$cmd\"\n";
        if (!open(MKHYBRID, "$cmd </dev/null 2>&1 |")) {
            &fail_package($pkg, "iso", "Execution of \"$cmd\" failed -- $!");
            next;
        }
        $err = 0;
        while (<MKHYBRID>) {
            chomp($line = $_);
            nprint "$line\n";
        }
        close(MKHYBRID);
        dprint "\"$cmd\" returned $?\n";
        if ($? != 0 && $err == 0) {
            &fail_package($pkg, "iso", "Unhandled error from mkhybrid");
        }

        nprint "$progname:  ISO image stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  ISO image stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_cleanup_stage
{
    qprint "$progname:  Entering the cleanup stage.  (${\(&get_timestamp())})\n";
    foreach $pkg (@packages) {
        if ($pkgs->{$pkg}{STAGES} !~ /a/) {
            nprint "$progname:  Skipping cleanup stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting cleanup stage for the \"$pkg\" package....\n";

        # Cleanup time.  First the module directory if it still exists.
        if (-d $pkgs->{$pkg}{MODULE}) {
            &nuke_tree($pkgs->{$pkg}{MODULE}) || qprint "Warning:  Cleanup of $pkg failed -- $!\n";
        }
        nprint "$progname:  Cleanup stage for \"$pkg\" is complete.\n";
    }
    foreach $f ("$builddir/BUILD", "$builddir/SOURCES", "$builddir/SPECS", "$basedir/rpmrc", "$basedir/rpmmacros", $buildroot) {
        &nuke_tree($f) || qprint "Warning:  Removal of $f failed -- $!\n";
    }

    qprint "$progname:  Cleanup stage is now complete.  (${\(&get_timestamp())})\n";
}

# Once we're all done, summarize any failures at the very end
# so that they're easy to find if the user is generating a log.
sub
summarize_failures
{
    my ($ns, $nf, $nt);

    $ns = $#packages + 1;
    $nf = $#failed_pkgs + 1;
    $nt = $ns + $nf;
    qprintf "Package Summary:  Out of %d total packages, %d succeeded and %d failed.\n", $nt, $ns, $nf;

    foreach $pkg (@failed_pkgs) {
        if ($failure->{$pkg}{MESSAGE}) {
            eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage:  $failure->{$pkg}{MESSAGE}.\n";
        } else {
            eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage.\n";
        }
    }
}

# This routine handles the role of "master buildtool"
sub
parallel_build
{
    my ($pid, $err, $idx, $pkg, $logfile, $line, $nprocs, $done, $left, $failed, $bldg);
    my (@children, @vars, @p);
    my %child_pkg;
    local *ERRLOG;

    @p = ($#_ >= 0 ? @_ : @packages);
    if (! -d "$basedir/logs") {
        mkdir("$basedir/logs", 0755) || &fatal_error("Unable to mkdir $basedir/logs -- $!\n");
    }
    $idx = 0;
    # Set $nprocs equal to the index within @children that should not be exceeded.
    $nprocs = $num_cpus - 1;
    # The "!$idx || " part of the test below is required because perl's do...while construct
    # sucks.  You can't use next/last from within it.  Someone shoot whoever decided that.
    qprintf "$progname:  Beginning $num_cpus-way build of %d packages.  (${\(&get_timestamp())})\n", $#p + 1;
    while (!$idx || $#children >= 0) {
        for (; $idx <= $#p && $#children < $nprocs; $idx++) {
            # Spawn a buildtool child process to handle the next package
            $pkg = $p[$idx];
            $logfile = "$basedir/logs/$pkg.log";
            $pid = &spawn_cmd($pkg, $logfile);
            push @children, $pid;
            $child_pkg{$pid} = $pkg;
        }

        # Out of space for children for now.
        $line = "";
        foreach $pid (@children) {
            $line .= "$child_pkg{$pid} ($pid)    ";
        }
        nprint "$progname:  Currently building:  $line\n";
        $bldg = $#children + 1;
        $done = $idx - $#children - 1;
        $left = $#p + 1 - $done - $bldg;
        $failed = $#failed_pkgs + 1;
        nprint "$progname:  $done packages completed ($failed failed), $bldg building, $left in queue.\n";

        # Wait for a child to die
        $pid = waitpid(-1, 0);
        next if (! $child_pkg{$pid});
        $pkg = $child_pkg{$pid};
        $err = $? >> 8;
        if ($pid == -1) {
            # This should never happen.
            eprint "Ummm, waitpid() returned -1.  That wasn't very nice.  I'm offended.\n";
            next;
        }
        @children = grep($_ != $pid, @children);
        if ($err == BUILDTOOL_SUCCESS) {
            nprint "Child process $pid for package $pkg completed successfully.  (${\(&get_timestamp())})\n";
        } else {
            dprint "Child process $pid for package $pkg failed, returning $err.\n";
            if ($err == BUILDTOOL_CHILD_EXEC_FAILED) {
                &fail_package($pkg, "pre-build", "exec() of child failed");
            } else {
                my @tmp;

                # The last line of the logfile should give the error message
                if (!open(ERRLOG, "$basedir/logs/$pkg.log")) {
                    &fail_package($pkg, "???", "Child process returned $err but the log file is missing");
                    next;
                }
                @tmp = <ERRLOG>;
                close(ERRLOG);
                chomp($line = $tmp[$#tmp]);
                if ($line =~ /^$progname:  Error:  Package \S+ failed at the ([a-z ]+) stage:  (.*)$/) {
                    &fail_package($pkg, $1, $2);
                } else {
                    $line =~ s/^\w+:  (Error:  )?\s*//;
                    &fail_package($pkg, "???", "Child process exited with code $err -- $line");
                }
            }
        }
        # End of loop.  Time to spawn the next child.
    }
    qprint "$progname:  Parallel build complete.  (${\(&get_timestamp())})\n";
}

# This routine does the actual build process
sub
build_process
{
    # Perform the build in stages, checking after each one to see if we should stop
    &do_bootstrap_stage() if ($start_stage eq "s");
    return if ($end_stage eq "s");

    if ($master) {
        &parallel_build();
        return if ($end_stage eq "p");
    } else {
        &do_compose_stage() if ("sc" =~ /$start_stage/);
        return if ($end_stage eq "c");

        &do_explode_stage() if ("scex" =~ /$start_stage/);
        return if ($end_stage eq "e" || $end_stage eq "x");

        &do_build_stage() if ("scexb" =~ /$start_stage/);
        return if ($end_stage eq "b");

        &do_package_stage() if ("scexbp" =~ /$start_stage/);
        return if ($end_stage eq "p");
    }

    &do_iso_stage() if ("scexbpi" =~ /$start_stage/);
    return if ($end_stage eq "i");

    return;  # This is only temporary.  I'm trying to fix a bug.

    &do_cleanup_stage();
}

# main() here is basically the same as main() in C
sub
main
{
    # Set up the basic variables
    $progname = "buildtool";
    $version = "0.1.0";

    # No input.
    open(STDIN, "</dev/null");

    # See the Getopt::Mixed man page for details on the syntax of this line
    $valid_opts = "h help>h v version>v d debug>d b=s build>b p=s product>p package>p"
                   . " q quiet>q Q really-quiet>Q silent>Q D=s dir>D f force>f l=s log>l"
                   . " P parallel>P t=s target>t B=s startbuild>B";
    Getopt::Mixed::getOptions($valid_opts);

    # Post-parse the options stuff
    if ($opt_v) {
        # Do not edit this variable.  It is updated automatically by CVS when you commit
        my $rcs_info = 'CVS Revision $Revision: 1.65 $ created on $Date: 2000/06/16 19:00:35 $ by $Author: mej $ ';

        $rcs_info =~ s/\$\s*Revision: (\S+) \$/$1/;
        $rcs_info =~ s/\$\s*Date: (\S+) (\S+) \$/$1 at $2/;
        $rcs_info =~ s/\$\s*Author: (\S+) \$ /$1/;
        print "\n";
	print "$progname $version by Michael Jennings <mej\@eterm.org>\n";
        print "Copyright (c) 2000, Michael Jennings and VA Linux Systems, Inc.\n";
        print "  ($rcs_info)\n";
        print "\n";
	return BUILDTOOL_SUCCESS;
    }
    if ($opt_h) {
	&print_usage_info();   # Never returns
        # This is a really silly way to shut up the "used only once" warnings.
        $opt_h = $opt_P = $opt_Q = $opt_p = $opt_q = $opt_v = 0;
    }
    $debug = $opt_d;
    $GLOBAL_LOG = 0;
    if ($opt_l) {
        if (!open(LOGFILE, ">$opt_l")) {
            eprint "Unable to open $opt_l -- $!\n";
        } else {
            $GLOBAL_LOG = \*LOGFILE;
            #system("chattr +S $opt_l");  # Try to set sync on the log file, fail silently
            open(STDERR, ">&LOGFILE");
            select LOGFILE; $| = 1;
        }
    }
    select STDOUT; $| = 1;
    $verbosity = ($opt_Q ? 0 : ($opt_q ? 1 : 2));
    $target = ($opt_t ? $opt_t : 0);
    $start_stage = ($opt_B ? $opt_B : "s");
    if (index("scexbpia", $start_stage) == -1) {
        eprint "Bad start stage \"$start_stage\".  Assuming \"s\".\n";
        $start_stage = "s";
    }
    $end_stage = ($opt_b ? $opt_b : "p");
    if (index("scexbpia", $end_stage) == -1) {
        eprint "Bad end stage \"$end_stage\".  Assuming \"p\".\n";
        $end_stage = "p";
    } elsif (index("scexbpia", $start_stage) > index("scexbpia", $end_stage)) {
        # FIXME:  This means people couldn't use, say, -Bx -be.  Oh well.
        eprint "End stage \"$end_stage\" comes before start stage \"$start_stage\".\n";
        $start_stage = "s";
        $end_stage = "p";
    }
    dprint "Building stages \"$start_stage\" through \"$end_stage\"\n";
    if ($opt_master) {
        $slave = 1;
        $master = 0;
    } elsif ($opt_P) {
        $master = 1;
        $slave = 0;
        $num_cpus = &count_cpus();
    } else {
        $master = 0;
        $slave = 0;
        $num_cpus = 1;
    }
    if ($opt_D) {
        $basedir = $opt_D;
    } elsif ($ENV{BASE_DIR} && $ENV{BASE_DIR} =~ /^\//) {
        $basedir = $ENV{BASE_DIR};
    } else {
        chomp($basedir = `pwd`);
    }
    $builddir = ($ENV{BUILD_DIR} ? $ENV{BUILD_DIR} : "$basedir/build");
    $proddir = ($ENV{PROD_DIR} ? $ENV{PROD_DIR} : "$basedir/products");
    $buildroot = ($ENV{BUILDROOT} ? $ENV{BUILDROOT} : "/var/tmp/buildtool.$$");
    $revtool = sprintf("revtool%s", ($opt_d ? " --debug" : ""));

    # Signal handling
    $SIG{HUP} = 'IGNORE';
    $SIG{INT} = \&handle_signal;
    $SIG{TERM} = \&handle_signal;
    $SIG{QUIT} = \&handle_fatal_signal;
    $SIG{ILL} = \&handle_fatal_signal;
    $SIG{ABRT} = \&handle_fatal_signal;
    $SIG{FPE} = \&handle_fatal_signal;
    $SIG{SEGV} = \&handle_fatal_signal;
    $SIG{BUS} = \&handle_fatal_signal;
    $SIG{TSTP} = 'IGNORE';
    $SIG{TTIN} = 'IGNORE';
    $SIG{TTOU} = 'IGNORE';
    $SIG{__WARN__} = \&handle_warning;

    # Environment modifications
    $ENV{MAKE} = "make";  # Make sure we don't parallel build, because it doesn't work.
    $ENV{CFLAGS} = "-O2 -march=pentium";  # A bit of optimization, but not much.
    $ENV{LD_LIBRARY_PATH} = "";  # Make glibc happy
    $ENV{PATH} = "/usr/build/bin:/usr/local/build/bin:/usr/lib/qt-1.45/bin:/usr/lib/qt-2.1.0/bin"
                  . ":/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/kerberos/sbin"
                  . ":/usr/kerberos/bin:.";

    # Try to parse the product name we were given into a name or a name-version combo
    $prod = $opt_p;
    if ($prod =~ /^(\S+)-((?:\d|us|a|alpha|b|beta)[^-]+)$/) {
        ($prodname, $prodver) = ($1, $2);
    } else {
        ($prodname, $prodver) = ($prod, 0);
    }
    if ($prod) {
        qprint "$progname:  Building product:  $prodname $prodver\n";
    } else {
        eprint "You didn't tell me what to build, so I'm not quite sure what to do.\n";
        eprint "If you aren't familiar with how to use $progname, try $progname --help.\n";
        return BUILDTOOL_BAD_PRODUCT;
    }

    # Parse the product definition files to figure out what the heck we need to build. :)
    # If we're a slave process, we know it's going to be a straight product entry.
    if ($slave || ! &parse_prod_file($prodname, $prodver)) {
        if (! &parse_product_entry($prod)) {
            eprint "$prod does not seem to be a valid product or product entry.\n";
            eprint "Perhaps you made a typo?\n";
            return BUILDTOOL_BAD_PRODUCT;
        }
    }
    dprint "Products to be built:  ", join(" ", @products), "\n";

    if ($end_stage ne "Z") {  # -dbZ, a.k.a. How To Debug the Parser :-)
        &initial_setup();
        &build_process();
        &summarize_failures();
    }
    close(LOGFILE) if ($GLOBAL_LOG);
    return (defined(@failed_pkgs) && $#failed_pkgs != -1) ? BUILDTOOL_PACKAGE_FAILED : BUILDTOOL_SUCCESS;
}

exit &main();
