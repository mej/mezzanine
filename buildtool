#!/usr/bin/perl -w
#
# buildtool -- Product Build Management Tool
# 
# Copyright (C) 2000-2001, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: buildtool,v 1.178 2004/03/31 02:22:23 mej Exp $
#

# Include the Perl Modules we need
use POSIX;
use Getopt::Long;
use File::Find;
use Mezzanine::Util;
use Mezzanine::RevCtl;
use Mezzanine::PkgVars;
use Mezzanine::Src;
use Mezzanine::Pkg;
use Mezzanine::Build;
use Mezzanine::Prod;

# Options variables
our ($opt_h, $opt_d, $opt_v, $opt_q, $opt_Q, $opt_D, $opt_l, $opt_P,
     $opt_t, $opt_C, $opt_U, $opt_T, $opt_L, $opt_s, $opt_i, $opt_H,
     $opt_u, $opt_b, $opt_hi, $opt_ii, $opt_ir, $opt_ic, $opt_nocache,
     $opt_clean);
my @valid_opts = ("h|help", "v|version", "d|debug", "q|quiet",
                  "Q|really-quiet|silent", "s|srcdir=s@",
                  "p|prod|product|prodfile=s", "D|dir|tree=s",
                  "l|log=s", "P|parallel:s", "t|target=s",
                  "C|cflags=s", "T|tag=s", "nocache", "clean:s",
                  "U|user=s", "L|location=s", "i|instroot|jail=s",
                  "H|hints=s", "hi|hint-installer=s",
                  "ii|instroot-init=s", "ir|instroot-reset=s",
                  "ic|instroot-copy=s", "u|user=s", "b|buildtree=s");

# Program variables
my ($progname, $version, $author, $ret) = ("buildtool", "3.0", "Michael Jennings <mej\@eterm.org>", MEZZANINE_SUCCESS);

my $GLOBAL_LOG = 0;  # Overall log file for product build
my $verbosity = 2;  # Logging verbosity
my $global_user;  # Build user
my $global_tree;  # Repository to use
my $global_tag;  # Tag to get packages with
my $buildtree_layout = "mej";  # The layout style to use for the build tree.


# Print usage information
sub
print_usage_info
{
    my ($leader, $underbar);

    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   buildtool [ options ]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -q --quiet                       Be somewhat quiet.  Simply gives basic progress info\n";
    print "    -Q --really-quiet --silent       Be very quiet.  Only errors are reported\n";
    print "    -D --dir <directory>             Specify the repository to use (overrides all product files)\n";
    print "    -l --log <logfile>               Specify a log file to send informational output to\n";
    print "    -P --parallel [expr]             Parallelize the build process based on the number of CPU's\n";
    print "    -t --target <arch>               Tell rpm to build for a particular target architecture\n";
    print "    -C --cflags <flags>              Specify the \$CFLAGS variable to use for building\n";
    print "    -U --user <userid>               Specify a userid for the repository (overrides product files)\n";
    print "    -T --tag <tag>                   Specify a tag to use (overrides all product files)\n";
    print "    -L --location <location_spec>    Specify where packages should be placed (as in product file)\n";
    print "    -s --srcdir <dir>                (Re)build all packages under <dir>\n";
    print "    -i --instroot --jail <dir>       Specify chroot jail to build in\n";
    print "    -H --hints <file_or_dir>         Specify location of pre-build hints or hint files\n";
    print "    -u --user <userid>               Build packages as <userid> instead of current user\n";
    print "    -b --buildtree <style>           Use the specified layout for the build tree\n";
    print "       --hi --hint-installer <prog>  Specify the mechanism used to install the hints\n";
    print "       --ii --instroot-init <cmd>    Command used to initialize chroot jail\n";
    print "       --ir --instroot-reset <cmd>   Command used to reset chroot jail\n";
    print "       --ic --instroot-copy <cmd>    Command used to copy chroot jail\n";
    print "       --nocache                     Do not scan the cache (use with care)\n";
    print "       --clean                       Clean up RPM and buildroot directories when done\n";
    print "\n";
    exit(MEZZANINE_SUCCESS);
}

# Normal print (i.e., don't print this in -q or -Q mode)
sub nprintf    {printf @_ if ($GLOBAL_LOG || $verbosity >= 2);}
sub nprint     {print  @_ if ($GLOBAL_LOG || $verbosity >= 2);}
# Quiet print (i.e., print in -q mode but not in -Q mode)
sub qprintf    {printf @_ if ($GLOBAL_LOG || $verbosity >= 1);}
sub qprint     {print  @_ if ($GLOBAL_LOG || $verbosity >= 1);}

# What to do if a package completes successfully
sub
complete_package
{
    my $pkg = $_[0];

    push @completed_pkgs, $pkg;
    nprint "Package build for $pkg completed successfully.  (${\(&get_timestamp())})\n";
}

# What to do if a package fails
sub
fail_package
{
    my ($pkg, $msg) = @_;

    push @failed_pkgs, $pkg;
    if ($msg) {
        $msg =~ s/\.+$//;
        $failure->{$pkg}{MESSAGE} = $msg;
        eprint "Package \"$pkg\" failed:  $msg.\n";
    } else {
        eprint "Package \"$pkg\" failed with an unknown error.\n";
    }
}

# Remove failed packages and packages we don't build from the list
sub
update_package_list
{
    my $parray = shift;
    my @p = @{$parray};

    @{$parray} = ();
    foreach my $pkg (@p) {
        next if ($pkgs->{$pkg}{TYPE} eq "image");
        if (!grep($_ eq $pkg, @failed_pkgs)) {
            push @{$parray}, $pkg;
        }
    }
    return (@{$parray});
}

# Check to see if we actually need to rebuild this package.
sub
is_build_needed
{
    my ($pkg, $pkgfile, $srpm_dir);
    my @stat1;

    $pkg = &pkgvar_name();
    if (!$pkg) {
        dprint "Doh!  is_build_needed() called with no package name set.  I suck!\n";
        return -1;
    }

    $pkgfile = &pkgvar_filename();
    if (!$pkgfile) {
        dprint "Doh!  is_build_needed() called for $pkg with no filename set.  I suck!\n";
        return -1;
    }

    # If the file/module does not exist, we definitely need to build it.
    if (! -e $pkgfile) {
        dprint "Doh!  $pkgfile doesn't exist.  It must be built.\n";
    }
    @stat1 = stat($pkgfile);

    # If there is no SRPMS directory, then there are surely no SRPMS to be checked.
    $srpm_dir = &pkgvar_topdir() . "/SRPMS";
    return 1 if (! -d $srpm_dir);

    # For each SRPM that matches the package name, see if it's newer than the directory.
    # If so, we do not need to rebuild that package.
    foreach my $srpm (&grepdir(sub {&basename($_) =~ /^\Q$pkg\E\.(no)?src\.rpm$/}, $srpm_dir)) {
        my @stat2;

        dprint "Checking $srpm...\n";
        @stat2 = stat($srpm);
        if ($stat2[9] >= $stat1[9]) {
            # SRPM is newer than (or the same age as) the file/module.  Skip it.
            dprint "$srpm is newer than $pkgfile; no need to rebuild.\n";
            &pkgvar_filename($srpm);
            return 0;
        }
    }
    # Doh, gotta rebuild this one.
    return 1;
}

# Scan the binary RPM directories to see which binaries belong to which SRPM's.
sub
scan_rpm_dirs
{
    my $topdir;
    my @contents;

    $topdir = &pkgvar_topdir();

    # Pre-scan all the binary RPM's for future use We need to know what SRPM
    # each binary came from, because some (lame) packages change the base name.
    nprint "Updating state information....\n";
    dprint "Scanning binary RPM's in $topdir for their corresponding SRPM's.\n";
    #@contents = glob("$topdir/RPMS/*/*.rpm");
    find({ "wanted" => sub { ! -d $_ && $_ =~ /\.rpm$/ && $_ !~ /src\.rpm$/ && push @contents, $_ }, "no_chdir" => 1 }, $topdir);
    foreach my $rpm (@contents) {
        my $srpm;

        $srpm = `rpm -qp $rpm --queryformat \"%{SOURCERPM}\"`;
        dprint "$rpm -> $srpm\n";
        $srpm_of_rpm{$rpm} = $srpm;
        if (!defined($rpms_of_srpm{$srpm})) {
            @{$rpms_of_srpm{$srpm}} = ($rpm);
        } else {
            push @{$rpms_of_srpm{$srpm}}, $rpm;
        }
        dprint "RPM's for $srpm:  ", join(' ', @{$rpms_of_srpm{$srpm}}), "\n";
    }
}

# Build a single package from source (if needed) and place the resulting files where they go.
sub
build_single_package
{
    my $pkg = shift;
    my ($pkgfile, $err, $msg, $outfiles);

    # Binaries or not, we need to know the full path and name of the source package.
    dprintf("Building $pkg in %s.\n", &pkgvar_topdir());
    &pkgvar_name($pkg);
    if (! ($pkgfile = &pkgvar_filename($pkgs->{$pkg}{MODULE}, $pkgs->{$pkg}{FILENAME}))) {
        &fail_package($pkg, "I don't know what file/module to build from!");
        return MEZZANINE_NO_SOURCES;
    }

    # If there are binaries, no point in trying to build source.
    if ($pkgs->{$pkg}{BINS}) {
        $outfiles = join(' ', &pkgvar_filename(), @{$pkgs->{$pkg}{BINS}});
    } elsif ($pkgs->{$pkg}{TYPE} eq "rpm") {
        $outfiles = &pkgvar_filename();
    } elsif (&is_build_needed()) {
        # Build the source
        &pkgvar_target($target);
        if ($pkgs->{$pkg}{"INSTROOT"}) {
            $ENV{"HOME"} = &pkgvar_buildroot();
            &pkgvar_instroot($pkgs->{$pkg}{"INSTROOT"});
            if (! -e $pkgs->{$pkg}{"INSTROOT"} && $pkgs->{$pkg}{"INSTROOT_INIT"}) {
                my @output;

                nprint "Initializing chroot jail, please wait.\n";
                @output = &run_cmd($pkgs->{$pkg}{"INSTROOT_INIT"}, $pkgs->{$pkg}{"INSTROOT"}, "instroot-init:  ");
                if ($output[0] != MEZZANINE_SUCCESS) {
                    wprint "Initialization of install root failed.\n";
                }
            } elsif (-e $pkgs->{$pkg}{"INSTROOT"} && $pkgs->{$pkg}{"INSTROOT_RESET"}) {
                my @output;

                nprint "Resetting chroot jail, please wait.\n";
                @output = &run_cmd($pkgs->{$pkg}{"INSTROOT_RESET"}, $pkgs->{$pkg}{"INSTROOT"}, "instroot-reset:  ");
                if ($output[0] != MEZZANINE_SUCCESS) {
                    wprint "Reset of install root failed.\n";
                }
            }
            if ($pkgs->{$pkg}{"BUILDUSER"}) {
                &pkgvar_set("builduser", $pkgs->{$pkg}{"BUILDUSER"});
                &file_owner($pkgs->{$pkg}{"BUILDUSER"}, "", $pkgs->{$pkg}{"INSTROOT"});
                dprintf("Building as %s (%lu:%lu)\n", &pkgvar_get("builduser"), $mz_uid, $mz_gid);
            }
        } else {
            &pkgvar_instroot("");
            if ($pkgs->{$pkg}{"BUILDUSER"}) {
                &pkgvar_set("builduser", $pkgs->{$pkg}{"BUILDUSER"});
                &file_owner($pkgs->{$pkg}{"BUILDUSER"});
                dprintf("Building as %s (%lu:%lu)\n", &pkgvar_get("builduser"), $mz_uid, $mz_gid);
            }
        }
        dprint "Build tree layout style:  $buildtree_layout\n";
        ($err, $msg, $outfiles) = &build_package();
        if ($err != MEZZANINE_SUCCESS) {
            &fail_package($pkg, $msg);
            return $err;
        }
    } else {
        my $srpm;

        # No build needed.  Just get the list of output files.
        $srpm = &basename(&pkgvar_filename());
        $outfiles = join(' ', &pkgvar_filename(), @{$rpms_of_srpm{$srpm}});
        dprint "Got cached output files:  $outfiles\n";
    }
    $err = &place_package_files($pkg, $outfiles, $pkgs->{$pkg}{LOCATIONS});
    return $err if ($err != MEZZANINE_SUCCESS);
    &complete_package($pkg);
    return MEZZANINE_SUCCESS;
}

# Spawn a child buildtool
sub
build_package_forked
{
    my ($pkg, $logfile) = @_;
    my $pid;

    do {
        if ($pid = fork()) {
            # Parent -- return PID
            nprint "Spawned child process $pid to build $pkg (log file is $logfile)\n";
            return $pid;
        } elsif (defined $pid) {
            my ($err, $buildroot);

            # Child -- reset state as needed and jump to build process
            close $GLOBAL_LOG if ($GLOBAL_LOG);
            open(STDOUT, ">/dev/null");
            open(STDIN, "</dev/null");
            &nuke_tree($logfile) if (-e $logfile);
            if (!open(LOGFILE, ">$logfile")) {
                eprint "Unable to open $logfile -- $!\n";
            } else {
                $GLOBAL_LOG = \*LOGFILE;
                #system("chattr +S $logfile");  # Try to set sync on the log file, fail silently
                open(STDERR, ">&LOGFILE");
                select LOGFILE; $| = 1;
                chown($mz_uid, $mz_gid, $logfile);
            }
            qprintf("Package build of $pkg started.  (%s)\n", &get_timestamp());
            $buildroot = &pkgvar_buildroot();
            if ($buildroot) {
                &pkgvar_buildroot("$buildroot/$pkg.$$");
            } else {
                &pkgvar_buildroot("/var/tmp/mezzanine-buildroot.$$");
            }
            if ($pkgs->{$pkg}{"INSTROOT"}) {
                # This package build is chrooted.
                &pkgvar_instroot(&pkgvar_buildroot() . "/instroot");
                &mkdirhier(&pkgvar_instroot());

                if ($pkgs->{$pkg}{"INSTROOT_COPY"}) {
                    # Copy COPY command to INIT so that we only use it if the build is needed.
                    $pkgs->{$pkg}{"INSTROOT_INIT"} = $pkgs->{$pkg}{"INSTROOT_COPY"} . ' ' . $pkgs->{$pkg}{"INSTROOT"};
                    $pkgs->{$pkg}{"INSTROOT"} = &pkgvar_instroot();
                }
            } else {
                &pkgvar_instroot("");
            }
            $err = &build_single_package($pkg);
            &cleanup_build_tree();
            if (&pkgvar_instroot() && -d &pkgvar_instroot()) {
                &nuke_tree(&pkgvar_instroot());
            }
            if (&pkgvar_buildroot() && -d &pkgvar_buildroot()) {
                &nuke_tree(&pkgvar_buildroot());
            }
            close(LOGFILE) if ($GLOBAL_LOG);
            exit ($err);
        } elsif ($! !~ /No more processes/ && $! !~ /Resource temporarily unavailable/) {
            &fatal_error("fork() failed -- $!\n");
        }
        # Temporary failure
        dprint "Failed temporarily -- $!\n";
        sleep 5;
    } while (1);
}

# Download packages from the repository
sub
download_packages
{
    my @packages = @_;
    my ($line, $err, $msg);

    nprint "Downloading packages, please wait..." if (! &debug_get());
    foreach $pkg (@packages) {
        my ($files, $tag);

        $err = 0;
        $files = &pkgvar_filename($pkgs->{$pkg}{MODULE}, $pkgs->{$pkg}{FILENAME});
        if (defined($pkgs->{$pkg}{BINS})) {
            $files = join(' ', $files, @{$pkgs->{$pkg}{BINS}});
        }
        &pkgvar_filename($files);

	# Set the proper REPOSITORY and tag for the checkout.
        
        if ($global_tree) {
            &revctl_repository($global_tree);
        } elsif ($pkgs->{$pkg}{REPOSITORY}) {
            &revctl_repository($pkgs->{$pkg}{REPOSITORY});
        } else {
            &revctl_repository("");
        }
        if ($global_user) {
            my $repository;

            $repository = &revctl_repository();
            $repository =~ s/\w+\@/$global_user\@/;
            &revctl_repository($repository);
        }
        if ($global_tag) {
            &revctl_tag(($global_tag eq "head") ? "" : $global_tag);
        } elsif ($pkgs->{$pkg}{TAG}) {
            &revctl_tag(($pkgs->{$pkg}{TAG} eq "head") ? "" : $pkgs->{$pkg}{TAG});
        } else {
            &revctl_tag("");
        }

        nprint "$pkg..." if (! &debug_get());
        ($err, $msg) = &fetch_package();
        if ($err != MEZZANINE_SUCCESS && $err != MEZZANINE_DUPLICATE) {
            &fail_package($pkg, $msg);
            next;
        }
    }
    nprint "done.\n\n" if (! &debug_get());
}

sub
place_package_files
{
    my ($pkg, $outfiles, $locations) = @_;
    my $instroot;
    my @outfiles;
    my @contents;

    # If we didn't find any, something is very wrong.
    if (! $outfiles) {
        &fail_package($pkg, "No output packages were found");
        return MEZZANINE_PACKAGE_FAILED;
    }
    if (! $locations) {
        wprint "No locations specified for $pkg.\n";
        $locations = "/.*/=.";
    }
    dprint "Output files for $pkg:  $outfiles\n";

    $instroot = $pkgs->{$pkg}{"INSTROOT"};
    if ($instroot) {
        foreach my $file (split(' ', $outfiles)) {
            if (-e "$instroot$file") {
                &move_files("$instroot$file", "$file");
            }
        }
    }

    # Copy each package into the appropriate place
    foreach my $file (split(' ', $outfiles)) {
        foreach my $loc (split(",", $locations)) {
            my ($regex, $stop, $dest);

            # Format is:  /regexp/.path  where . is some delimiter character that
            # tells us whether to check other locations or stop once we match
            # (':' to continue looking for matches, or '=' to stop if a match is found).
            dprint "Testing location \"$loc\"\n";
            if ($loc !~ m/^\/([^\/]+)\/(.)(\S+)?$/) {
                eprint "Location specifier \"$loc\" is invalid.\n";
                next;
            }
            ($regex, $stop, $dest) = ($1, $2, $3);
            if ($stop eq "!") {
                # A negative match test.  If we get a match, don't accept it.
                next if ($file =~ $regex);
            } else {
                # No match.  Try next location.
                next if ($file !~ $regex);
            }
            dprint "Match found.\n";

            if ($dest) {
                # If the destination does not contain a filename, add the filename portion of
                # $file to the directory path in $dest.  The destination could be used to rename
                # a file, however; that's why this check is in place.
                if (substr($dest, -3, 3) ne substr($file, -3, 3)) {
                    my $tmp;

                    ($tmp = $file) =~ s/^.*\/([^\/]+)$/$1/;
                    $dest = "$dest/$tmp";
                }
                # If it exists, delete it
                if (-e $dest) {
                    &nuke_tree($dest);
                }
                # Then link it
                dprint "ln -f $file $dest\n";
                if (!link($file, $dest)) {
                    if (exists($!{EXDEV}) && ($!{EXDEV})) {
                        # Cross-device link attempt.  Copy instead.
                        if (&copy_files($file, $dest) != 1) {
                            &fail_package($pkg, "Unable to create $dest as a link to $file -- $!");
                            return MEZZANINE_SYSTEM_ERROR;
                        } else {
                            dprint "Can't link across devices; had to copy.\n";
                        }
                    } else {
                        &fail_package($pkg, "Unable to create $dest as a link to $file -- $!");
                        return MEZZANINE_SYSTEM_ERROR;
                    }
                }
            }

            # If the stop character is '=', stop checking for matches for this package.
            # If it's ':' (actually, any other character than '='), keep looking for matches.
            last if ($stop eq "=");
            dprint "Non-exclusive match.  Continuing on....\n";
        }
    }
    return MEZZANINE_SUCCESS;
}

# This routine parallelizes the product build so that each package is built by an individual buildtool process.
sub
parallel_build
{
    my @packages = @_;
    my ($pwd, $builddir, $logdir, $buildroot, $dummy);
    my (@children, @vars);
    my %child_pkg;

    # Create the directories for building this product
    if ($buildtree_layout eq "orc") {
        $builddir = (($ENV{"MEZZANINE_BUILDDIR"}) ?
                     ($ENV{"MEZZANINE_BUILDDIR"}) :
                     (&getcwd() . "/build.mezz"));
        $logdir = $builddir;
        &pkgvar_topdir($builddir);
    } else {
        $builddir = &make_build_dir((($ENV{"MEZZANINE_BUILDDIR"}) ?
                                     ($ENV{"MEZZANINE_BUILDDIR"}) :
                                     (&getcwd() . "/build.mezz")));
        $logdir = &make_log_dir((($ENV{"MEZZANINE_LOGDIR"}) ?
                                 ($ENV{"MEZZANINE_LOGDIR"}) : ("$builddir/logs")));
        &pkgvar_topdir($builddir);

        # Need to do this here for parallel builds because it's not parallel-safe.  Race condition. :(
        &prepare_build_tree();
    }


    if (! $opt_nocache) {
        &scan_rpm_dirs();
    }

    # Download all the packages.
    &download_packages(@packages);
    &update_package_list(\@packages);

    qprint "$progname:  Beginning $num_cpus-way build of ${\(scalar(@packages))} packages.  (${\(&get_timestamp())})\n";
    for (; scalar(@packages) || scalar(@children);) {
        my ($pid, $line, $left, $failed, $bldg, $err);

        # As long as there are packages left to build or children left to wait on, we loop.
        for (; scalar(@packages) && (scalar(@children) < $num_cpus);) {
            my ($pkg, $logfile, $save_builddir);

            # Spawn child processes until we fill up our allotment ($num_cpus)
            $pkg = shift @packages;
            if ($pkgs->{$pkg}{"BUILDUSER"}) {
                &file_owner($pkgs->{$pkg}{"BUILDUSER"}, "", "");
            }
            if ($buildtree_layout eq "orc") {
                my $dirname = $pkg;

                #$dirname = sprintf("/%s-%s-%s", $pkg, $pkgs->{$pkg}{"VERSION"}, $pkgs->{$pkg}{"RELEASE"});
                $save_builddir = $builddir;
                $builddir .= ((substr($builddir, -1, 1) eq '/') ? ("") : ('/')) . $dirname;
                &make_build_dir($builddir);
                $logdir = $builddir;
                &pkgvar_topdir($builddir);
                &pkgvar_set("buildpkglist_filename", "$logdir/$pkg.pkglist");
            } 
            $logfile = "$logdir/$pkg.log";
            $pid = &build_package_forked($pkg, $logfile);
            push @children, $pid;
            $child_pkg{$pid} = $pkg;
            if ($save_builddir) {
                $builddir = $save_builddir;
            }
        }

        # Okay, we can't build anything more right now.  Print some status info.
        $line = "";
        foreach my $pid (@children) {
            $line .= "$child_pkg{$pid} ($pid)    ";
        }
        nprint "$progname:  Currently building:  $line\n";
        nprint "$progname:  ${\(scalar(@completed_pkgs))} packages completed (${\(scalar(@failed_pkgs))} failed), "
            . "${\(scalar(@children))} building, ${\(scalar(@packages))} in queue.\n";

        # This loop waits until one of our immediate children dies before continuing.
        do {
            $pid = waitpid(-1, 0);
        } while (! ($pkg = $child_pkg{$pid}));
        $err = $? >> 8;
        if ($pid == -1) {
            # This should never happen.
            eprint "Ummm, waitpid() returned -1.  That wasn't very nice.  I'm offended.\n";
            next;
        }

        # Remove the child from our PID list
        @children = grep($_ != $pid, @children);

        # Check to see how it existed
        if ($err == MEZZANINE_SUCCESS) {
            # Yay! :-)
            &complete_package($pkg);
        } else {
            my $logfile;
            my @tmp;
            local *ERRLOG;

            # Doh, it failed.  Look through the log file to try and find the problem.
            if ($buildtree_layout eq "orc") {
                my $dirname = $pkg;

                #$dirname = sprintf("/%s-%s-%s", $pkg, $pkgs->{$pkg}{"VERSION"}, $pkgs->{$pkg}{"RELEASE"});
                $logfile = "$builddir/$dirname/$pkg.log";
            } else {
                $logfile = "$logdir/$pkg.log";
            }
            if (!open(ERRLOG, $logfile)) {
                &fail_package($pkg, "Child process returned $err but log file $logfile is missing");
                next;
            }
            @tmp = <ERRLOG>;
            close(ERRLOG);
            # If the last line doesn't match, take the last line out of all the lines that do.
            if (scalar(@tmp)) {
                if ($tmp[$#tmp] !~ /error: /i) {
                    @tmp = grep($_ =~ /error: /i, @tmp);
                }
                chomp($line = $tmp[$#tmp]);

                # Record that the package failed.
                if ($line =~ /^$progname:  Error:  Package \S+ failed:  (.*)$/) {
                    &fail_package($pkg, $1);
                } else {
                    $line = "Couldn't find error in log" if (! $line);
                    $line =~ s/^\w+:\s*Error:\s*//;
                    &fail_package($pkg, "Child process exited with code $err -- $line");
                }
            } else {
                &fail_package($pkg, "Child process returned $err but log file $logfile is empty");
            }
        }
        # End of loop.  Time to spawn the next child.
    }
    &cleanup_build_tree();
    return (scalar(@failed_pkgs) ? MEZZANINE_PACKAGE_FAILED : MEZZANINE_SUCCESS);
}

sub
build_product
{
    my @packages = @_;
    my $builddir;

    # Create the directories for building this product
    if ($buildtree_layout eq "orc") {
        $builddir = (($ENV{"MEZZANINE_BUILDDIR"}) ?
                     ($ENV{"MEZZANINE_BUILDDIR"}) :
                     (&getcwd() . "/build.mezz"));
        $logdir = $builddir;
        &pkgvar_topdir($builddir);
    } else {
        $builddir = &make_build_dir((($ENV{"MEZZANINE_BUILDDIR"}) ?
                                     ($ENV{"MEZZANINE_BUILDDIR"}) :
                                     (&getcwd() . "/build.mezz")));
        $logdir = &make_log_dir((($ENV{"MEZZANINE_LOGDIR"}) ?
                                 ($ENV{"MEZZANINE_LOGDIR"}) : ("$builddir/logs")));
        &pkgvar_topdir($builddir);
    }

    if (! $opt_nocache) {
        &scan_rpm_dirs();
    }

    # Download all the packages.
    &download_packages(@packages);
    &update_package_list(\@packages);

    # Call build_single_package() for each package; we don't care how that works as long as it does. :-)
    foreach my $pkg (@packages) {
        my %preserve_pkg_vars = &pkgvar_get_all();

        if ($buildtree_layout eq "orc") {
            my $dirname = $pkg;

            #$dirname = sprintf("/%s-%s-%s", $pkg, $pkgs->{$pkg}{"VERSION"}, $pkgs->{$pkg}{"RELEASE"});
            $builddir = &pkgvar_topdir();
            $builddir .= ((substr($builddir, -1, 1) eq '/') ? ("") : ('/')) . $dirname;
            &make_build_dir($builddir);
            $logdir = $builddir;
            &pkgvar_topdir($builddir);
            &pkgvar_set("buildpkglist_filename", "$logdir/$pkg.pkglist");
        }
        &build_single_package($pkg);
        &pkgvar_reset(%preserve_pkg_vars);
    }

    # Now we clean up.
    &cleanup_build_tree();
    return (scalar(@failed_pkgs) ? MEZZANINE_PACKAGE_FAILED : MEZZANINE_SUCCESS);
}

# Once we're all done, summarize any failures at the very end
# so that they're easy to find if the user is generating a log.
sub
summarize_failures
{
    my ($ns, $nf, $nt, $nb, $face);

    # $ns is the number of successful packages.  $nf is the number of failures.
    # $nt is the total number of packages we tried to build.
    $ns = scalar(@completed_pkgs);
    $nf = scalar(@failed_pkgs);
    $nt = scalar(@packages);
    $nb = $nt - $ns - $nf;

    if ($nf == 0) {
        $face = ":-)";
    } elsif ($ns == 0) {
        $face = ":-(";
    } elsif ($ns > $nf) {
        $face = ":-}";
    } elsif ($nf > $ns) {
        $face = ":-{";
    } else {
        $face = ":-|";
    }

    qprint "Build Summary:  $ns Successful    $nf Failed    $nb Not Built    $nt Total    $face\n";
    if ($nf) {
        foreach $pkg (@failed_pkgs) {
            if ($failure->{$pkg}{MESSAGE}) {
                eprint "Package \"$pkg\" failed:  $failure->{$pkg}{MESSAGE}.\n";
            } else {
                eprint "Package \"$pkg\" failed; reason unknown.  Check the log to see what went wrong.\n";
            }
        }
    }
}

# main() here is basically the same as main() in C
sub
main
{
    my $srcdir;

    #
    # Initialization
    #
    umask 022;
    open(STDIN, "</dev/null");
    open(STDERR, ">&STDOUT");
    Getopt::Long::Configure("no_getopt_compat", "bundling", "no_ignore_case");
    Getopt::Long::GetOptions(@valid_opts);

    #
    # Options Handling
    #
    if ($opt_v) {
        &print_version($progname, $version, $author,
                       'CVS Revision $Revision: 1.178 $ created on $Date: 2004/03/31 02:22:23 $ by $Author: mej $ ');
        # Never returns
    }
    if ($opt_h) {
	&print_usage_info();   # Never returns
    }

    # Set basic options
    &debug_set($opt_d);
    if ($opt_Q) {
        $verbosity = 0;
    } elsif ($opt_q) {
        $verbosity = 1;
    }
    $global_user = $opt_U;
    $global_tree = $opt_D;
    $global_tag = $opt_T;
    $buildtree_layout = (($opt_b) ? ($opt_b) : ("mej"));
    &pkgvar_cleanup((($opt_clean) ? ($opt_clean) : ("temp")));
    &pkgvar_target($opt_t);

    # Open log file, if any.
    if ($opt_l) {
        my $log_filename = $opt_l;

        if (-e $log_filename) {
            rename($log_filename, "$log_filename.prev");
        }
        if (!open(LOGFILE, ">$log_filename")) {
            eprint "Unable to open $log_filename -- $!\n";
        } else {
            $GLOBAL_LOG = \*LOGFILE;
            #system("chattr +S $log_filename");  # Try to set sync on the log file, fail silently
            open(STDOUT, ">&LOGFILE");
            select LOGFILE; $| = 1;
        }
    }
    select STDOUT; $| = 1;

    # Handle hint file/directory specification
    if ($opt_H) {
        $ENV{"MEZZANINE_HINTS"} = $opt_H;
    }
    &set_hints_info($ENV{"MEZZANINE_HINTS"});
    if ($opt_hi) {
        # Override installer from command line.
        &set_hints_info("$opt_hi\%");
    }

    # Figure out parallelization stuff
    if (defined($opt_P)) {
        $num_cpus = &count_cpus();
        if ($opt_P) {
            my ($mult, $add) = (1, 0);

            $opt_P =~ m/^(?:[Xx]([\d.]+))?([-+][\d.]+)?$/;
            ($mult, $add) = ($1, $2);
            $num_cpus = $num_cpus * ($mult ? $mult : 1) + ($add ? $add : 0);
        }
    } else {
        $num_cpus = 1;
    }
    dprint "Using $num_cpus parallel process(es).\n";

    # Try to parse the product name we were given into a name or a name-version combo
    if ($opt_p) {
        $prod = $opt_p;
    } elsif (!scalar(@opt_s)) {
        $prod = $prodname = &basename(&getcwd());
    }
    if (scalar(@opt_s) && ! $prod) {
        # If we don't have a product name, but we do have one or more
        # SRPM directories to look at, we need to auto-generated the
        # prod file.  NOTE:  This must happen *before* the instroot
        # stuff below. 
        $prod = "autoprod-1.0";
    }

    # Handle specification of a global value for the LOCATIONS product
    # variable.  This must happen after $prod is set but before $opt_s
    # is handled.
    if ($opt_L) {
        my $locations = $opt_L;

        if (-d $locations) {
            $locations = '/.*/=' . $locations;
            dprint "Got global location \"$locations\".\n";
        } elsif ($locations !~ m,/[^/]+/[\@=],) {
            if (&mkdirhier($locations, 0775)) {
                dprint "Created location $locations.\n";
                $locations = "/.*/=$locations";
            } else {
                eprint "Bad location $locations, can't mkdir -- $!\n";
                $locations = "/.*/=.";
            }
        }
        &assign_product_variable($prod, "LOCATIONS", $locations);
    }

    # Set the build user if needed.  This must happen after $prod is
    # set but before $opt_s is handled.
    if ($opt_u) {
        &assign_product_variable($prod, "BUILDUSER", $opt_u);
    }

    # Figure out the installroot stuff.
    if ($opt_i) {
        my ($instroot, $instroot_init, $instroot_reset, $instroot_copy) = ($opt_i, $opt_ii, $opt_ir, $opt_ic);

        # If we have $MEZZANINE_INSTROOT_SOURCE_RSYNC and we don't have the options,
        # automagically fill the commands in appropriately.  If needed, authentication
        # info and other flags can be added to $MEZZANINE_INSTROOT_SOURCE_RSYNC.
        if ($ENV{"MEZZANINE_INSTROOT_SOURCE_RSYNC"}) {
            if (! $instroot_init) {
                $instroot_init = "rsync -Haz --delete --delete-after --exclude=/proc $ENV{MEZZANINE_INSTROOT_SOURCE_RSYNC}";
            }
            if (! $instroot_reset) {
                $instroot_reset = "rsync -Haz --delete --delete-after --exclude=/proc $ENV{MEZZANINE_INSTROOT_SOURCE_RSYNC}";
            }
            if (! $instroot_copy) {
                $instroot_copy = "rsync -Ha --delete --delete-after";
            }
        }

        # Now set all the variables using fallbacks.
        ($instroot, $instroot_init, $instroot_reset, $instroot_copy)
            = &set_instroot_info($instroot, $instroot_init, $instroot_reset, $instroot_copy);
        &assign_product_variable($prod, "INSTROOT", $instroot);

        # If we have $instroot_init, the other two are guaranteed to be set by fallbacks.
        if ($instroot_init) {
            &assign_product_variable($prod, "INSTROOT_INIT", $instroot_init);
            &assign_product_variable($prod, "INSTROOT_RESET", $instroot_reset);
            &assign_product_variable($prod, "INSTROOT_COPY", $instroot_copy);
        }
    }

    # *Now* we can look at our SRPM directories.
    if (scalar(@opt_s)) {
        # This must happen *after* the instroot stuff above.
        foreach my $srcdir (@opt_s) {
            my @pkg_list;

            @pkg_list = &grepdir(sub {((-f $_ || -d $_) && (&basename($_) !~ /^\./))}, $srcdir);
            foreach my $pkg (sort(@pkg_list)) {
                my $prodfile_line;

                #$prodfile_line = sprintf("%s NAME=%s-%04d", $pkg, &basename($pkg), int(rand(10000)));
                $prodfile_line = $pkg;
                &parse_product_entry($prodfile_line, $prod);
            }
        }
    }

    # Set the buildroot for the overall build.
    &pkgvar_buildroot($ENV{"MEZZANINE_BUILDROOT"});

    #
    # Signal handling
    #
    $SIG{HUP} = 'IGNORE';
    $SIG{INT} = \&handle_signal;
    $SIG{TERM} = \&handle_signal;
    $SIG{QUIT} = \&handle_fatal_signal;
    $SIG{ILL} = \&handle_fatal_signal;
    $SIG{ABRT} = \&handle_fatal_signal;
    $SIG{FPE} = \&handle_fatal_signal;
    $SIG{SEGV} = \&handle_fatal_signal;
    $SIG{BUS} = \&handle_fatal_signal;
    $SIG{TSTP} = 'IGNORE';
    $SIG{TTIN} = 'IGNORE';
    $SIG{TTOU} = 'IGNORE';

    #
    # Environment modifications
    #
    $ENV{"LANG"} = "C" if (! $ENV{"LANG"});
    if ($ENV{"MEZZANINE_MAKE"}) {
        $ENV{"MAKE"} = $ENV{"MEZZANINE_MAKE"};
    } else {
        # Parallel product builds and make -jN don't get along well.
        $ENV{"MAKE"} = "make";
    }
    if ($opt_C) {
        $ENV{"CFLAGS"} = $opt_C;
    } elsif ($ENV{"MEZZANINE_CFLAGS"}) {
        $ENV{"CFLAGS"} = $ENV{"MEZZANINE_CFLAGS"};
    } else {
        $ENV{"CFLAGS"} = "-O2 -march=pentium";
    }
    if ($ENV{"MEZZANINE_PATH"}) {
        $ENV{"PATH"} = $ENV{"MEZZANINE_PATH"};
    } else {
        $ENV{"PATH"} = "/usr/build/bin:/usr/local/build/bin:/usr/lib/qt-1.45/bin:/usr/lib/qt-2.1.0/bin"
            . ":/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/kerberos/sbin"
            . ":/usr/kerberos/bin:.";
    }
    delete $ENV{LD_RUN_PATH};  # Don't hard code any RPATH's into binaries
    delete $ENV{LD_LIBRARY_PATH};  # Make glibc happy

    # Parse the product definition files to figure out what the heck we need to build. :)
    if ((substr($prod, 0, 8) ne "autoprod") && !&parse_prod_file($prod, 0, 0)) {
        if (! &parse_product_entry($prod)) {
            if (!scalar(@packages)) {
                eprint "$prod does not seem to be a valid product or product entry.\n";
                eprint "Perhaps you made a typo?\n";
                return MEZZANINE_BAD_PRODUCT;
            }
        }
    }
    return MEZZANINE_BAD_PRODUCT if (!scalar(@packages));

    dprint "Products to be built (", scalar(@packages), " packages):  ", join(" ", @products), "\n";

    if ($num_cpus > 1) {
        $ret = &parallel_build(@packages);
    } else {
        $ret = &build_product(@packages);
    }
    &summarize_failures();
    qprint "Build completed.  (${\(&get_timestamp())})\n";
    close($GLOBAL_LOG) if ($GLOBAL_LOG);
    return $ret;
}

exit &main();
