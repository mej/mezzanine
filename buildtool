#!/usr/bin/perl
#
# buildtool -- Product Build Management Tool
# 
# Copyright (C) 2000, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: buildtool,v 1.12 2000/05/17 00:14:18 mej Exp $
#

# Include the Perl Modules we need
use POSIX;
use Getopt::Mixed;

# Constants
#
# Keep these in sync with the ones in revtool, or
# talk perl into using headers and #define's.
#
# 1-20 are generic errors
sub REVTOOL_NO_SERVER()           {1;}
sub REVTOOL_SERVER_CRASH()        {2;}
sub REVTOOL_BAD_LOGIN()           {3;}
sub REVTOOL_COMMAND_FAILED()      {4;}
sub REVTOOL_ACCESS_DENIED()       {5;}

# 21-40 are retrieval/update errors
sub REVTOOL_FILE_NOT_FOUND()      {21;}
sub REVTOOL_FILE_REMOVED()        {22;}
sub REVTOOL_CONFLICT_FOUND()      {23;}

# 41-60 are add/remove errors
sub REVTOOL_BAD_ADDITION()        {41;}
sub REVTOOL_BAD_REMOVAL()         {42;}

# 61-80 are commit errors
sub REVTOOL_NEED_UPDATE()         {61;}

# 127 is a catch-all
sub REVTOOL_UNSPECIFIED_ERROR()   {127;}

# Print usage information
sub
print_usage_info
{
    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   buildtool [ options ]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -b --build [stage]               Stop building after a particular stage (see below)\n";
    print "    -p --product --package [name]    Specify the product or package to build\n";
    print "    -q --quiet                       Be somewhat quiet.  Simply gives basic progress info\n";
    print "    -Q --really-quiet --silent       Be very quiet.  Only errors are reported\n";
    print "    -D --dir [directory]             Specify \"directory\" as the location of your .prod files\n";
    print "    -f --force                       Ignore errors, build as much as possible\n";
    print "\n";
    exit(0);
}

# Generate timestamp for debugging/log file
sub
get_timestamp
{
    $ts = POSIX::strftime("%A, %d %B %Y %H:%M:%S %Z", localtime);
    return $ts;
}

# Debugging output
sub
dprintf
{
    return if (! $debug);
    print "[debug:$progname] ";
    printf @_;
}
sub
dprint
{
    print "[debug:$progname] ", @_ if ($debug);
}

# Print an error
sub
eprintf
{
    print STDERR "$progname:  Error:  ";
    printf STDERR @_;
}
sub
eprint
{
    print STDERR "$progname:  Error:  ", @_;
}

# Normal print (i.e., don't print this in -q or -Q mode)
sub
nprintf
{
    printf @_ if ($verbosity >= 2);
}
sub
nprint
{
    print @_ if ($verbosity >= 2);
}

# Quiet print (i.e., print in -q mode but not in -Q mode)
sub
qprintf
{
    printf @_ if ($verbosity >= 1);
}
sub
qprint
{
    print @_ if ($verbosity >= 1);
}

# Make a directory hierarchy
sub
mkdirhier
{
    my $dir = $_[0];
    my @dirs = split("/", $dir);
    my $path = "";

    foreach $dir (@dirs) {
        $path .= "$dir/";
        dprint "mkdirhier() checking for \"$path\"\n";
        if (! -d $path) {
            dprint "mkdirhier() creating \"$path\"\n";
            mkdir($path, 0755) || die("Unable to create $path -- $!\n");
        }
    }
    dprint "Something went wrong in mkdirhier()!\n" if (! -d $_[0]);
}

# Parse product definition files recursively to establish
# all the products we need to work with and what packages or
# other products compose them.
sub
parse_product_def
{
    my $prod = $_[0];

    open(PROD, "$proddir/${prod}.prod") || return 0;

    # For now, just skip the product information.  Eventually we might care, but not now.
    # The first blank line signifies the end of the product information.
    while (<PROD>) {
        chomp($line = $_);
        last if ($line =~ /^\s*$/);
    }
    while (<PROD>) {
        chomp($line = $_);
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;
        next if ($line !~ /\S/ || $line =~ /^\#/);  # Ignore blank lines and comment lines
        undef %pkgvars;
        undef $module;
        @inp = split(/\s+/, $line);
        # Line begins with <type>:<name>, like "module:Eterm"
        ($type, $name) = split(":", shift @inp);
        $type =~ tr/[A-Z]/[a-z]/;
        if ($type =~ /^prod/) {
            $type = "product";
        } elsif ($type =~ /^mod/) {
            $type = "module";
        } elsif ($type =~ /^srpm/) {
            $type = "srpm";
        } else {
            eprint "Unrecognized type \"$type\" for package $name.  I'll have to skip that one.\n";
            next;
        }
        if ($name =~ /\/.+$/) {
            ($module = $name) =~ s/^([^\/]+)(.+)$/$1/;
            $name =~ s/^(.*)\/([^\/]+)$/$2/;
        }
        dprint "Module is $module, name is $name\n";
        if ($type eq "product") {
            # Recursively convert products into their component packages
            &parse_product_def($name);
        } else {
            # The rest of the line is whitespace-delimited sets of var=value
            foreach $varval (@inp) {
                ($var, $val) = split("=", $varval);
                $var =~ tr/[a-z]/[A-Z]/;
                # Common variables are REVISION/TAG, VERSION, DATE, CVSROOT, SPECFILE
                if ($var =~ /^REV/ || $var =~ /^TAG/) {
                    $var = "REVISION";
                } elsif ($var =~ /^REL/) {
                    $var = "RELEASE";
                } elsif ($var =~ /^VER/) {
                    $var = "VERSION";
                } elsif ($var =~ /^SPEC/) {
                    $var = "SPECFILE";
                } elsif ($var =~ /^DIR/) {
                    $var = "DIRECTORY";
                }
                $pkgvars{$var} = $val;
            }
            # Add defaults for stuff that is required
            if ($type eq "module") {
                if ($pkgvars{RELEASE} =~ /^head$/i) {
                    undef $pkgvars{RELEASE};
                }
            } elsif ($type eq "srpm") {
                $name =~ s/\.src\.rpm$//;
                if (!defined $pkgvars{RELEASE}) {
                    if ($name !~ /^\S+-[^-]+-[^-]+$/) {
                        eprint "I wasn't given enough information about the $name package in ${prod}.prod.  For SRPM\n";
                        eprint "packages, the version and release information must be specified as variables or\n";
                        eprint "embedded in the package name.  I'm going to have to skip that one.\n";
                        next;
                    } else {
                        ($tmp = $name) =~ s/^\S+-[^-]+-//;
                        $name =~ s/-[^-]+$//;
                        $pkgvars{RELEASE} = $tmp;
                    }
                }
                if (!defined $pkgvars{VERSION}) {
                    if ($name !~ /^\S+-[^-]+$/) {
                        eprint "I wasn't given enough information about the $name package in ${prod}.prod.  For SRPM\n";
                        eprint "packages, the version and release information must be specified as variables or\n";
                        eprint "embedded in the package name.  I'm going to have to skip that one.\n";
                        next;
                    } else {
                        ($tmp = $name) =~ s/^(\S+)-([^-]+)$/$2/;
                        $name =~ s/^(\S+)-([^-]+)$/$1/;
                        $pkgvars{VERSION} = $tmp;
                    }
                }
                $filename = sprintf("%s$name-$pkgvars{VERSION}-$pkgvars{RELEASE}.src.rpm", ($module ? "$module/" : ""));
            }
            # Now that we've got the name/version/release in their final forms, set up the data structures.
            $pkgs->{$name}{TYPE} = $type;
            $pkgs->{$name}{MODULE} = ($module ? $module : $name);
            $pkgs->{$name}{FILENAME} = ($filename ? $filename : $module);
            dprint "New package:  $name is a $pkgs->{$name}{TYPE}\n";
            foreach $pkgvar (keys %pkgvars) {
                if ($pkgvars{$pkgvar} !~ /^$/) {
                    $pkgs->{$name}{$pkgvar} = $pkgvars{$pkgvar};
                    dprint "Added variable $pkgvar to package $name with value \"$pkgs->{$name}{$pkgvar}\"\n";
                }
            }
            push @packages, $name;
        }
    }
    close(PROD);
    return 1;
}

# What to do if a package fails
sub
fail_package
{
    my ($pkg, $stage, $msg) = @_;

    push @failed_pkgs, $pkg;
    $failure->{$pkg}{STAGE} = $stage;
    if ($msg) {
        $failure->{$pkg}{MESSAGE} = $msg;
        eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage:  $failure->{$pkg}{MESSAGE}.\n";
    } else {
        eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage.\n";
    }
    exit(-1) if (! $opt_f);
    @packages = grep($_ ne $pkg, @packages);
    return 0;
}

sub
fetch_package
{
    my $cmd = $_[0];
    my $err = 0;
    my $tries = 0;
    my $msg = undef;

    for (; (($err == -1) || ($tries == 0)); $tries++) {
        dprint "About to run $cmd\n";
        if (!open(REVTOOL, "$cmd 2>&1 |")) {
            $err = 1;
            $msg = "Execution of \"$cmd\" failed -- $!";
            last;
        }
        while (<REVTOOL>) {
            chomp($line = $_);
            if ($debug) {
                nprint "From revtool -> $line\n";
            } else {
                nprint "$line\n";
            }
            next if ($line =~ /^\[debug:/);
            # Check the output for errors
            if ($line =~ /^cvs server: cannot find module/) {
                $err = 1;
                $msg = "$filename does not seem to exist in the repository";
            } elsif ($line =~ /^revtool:\s*Error/) {
                $err = 1;
                $msg = "$line";
            } elsif ($line =~ /^cvs server: warning: $filename is not \(any longer\) pertinent/) {
                $err = 1;
                $msg = "$filename was removed from the repository.  Please update the product file.";
            } elsif ($line =~ /^cvs \[checkout aborted\]: connect to \S+ failed: Connection refused/) {
                if ($tries < 10) {
                    $err = -1;
                    qprint "The CVS server seems to be down.  I'll wait a bit and try again.\n";
                    sleep 3;
                } else {
                    $err = 1;
                    $msg = "The CVS server was unreachable.";
                }
            } elsif ($line =~ /^cvs \[checkout aborted\]: received .* signal/) {
                if ($tries < 10) {
                    $err = -1;
                    qprint "The CVS server crashed.  I'll wait a bit and try again.\n";
                    sleep 3;
                } else {
                    $err = 1;
                    $msg = "The CVS server kept crashing.";
                }
            }
            last if ($err == 1);
        }
        close(REVTOOL);
        dprint "\"$cmd\" returned $?\n";
    }
    return ($err, $msg);
}

# Build RPMS from the spec file
sub
build_rpms
{
    my ($pkg, $specfile) = @_;
    my ($cmd, $rpm, $msg, $err, $line, $srpm);
    my @failed_deps;

    $rpm = ($pkgs->{$pkg}{RPMCMD} ? $pkgs->{$pkg}{RPMCMD} : "rpm");
    $cmd = "$rpm --rcfile $rpmrc -ba $specfile";
    dprint "About to run \"$cmd\"\n";
    if (!open(RPM, "$cmd </dev/null 2>&1 |")) {
        return (1, "Execution of \"$cmd\" failed -- $!", undef);
    }
    $err = 0;
    while (<RPM>) {
        chomp($line = $_);
        nprint "$line\n";
        if ($line =~ /^Wrote: .*\.src\.rpm$/) {
            ($srpm = $line) =~ s/^Wrote:\s+//;
        } elsif ($line =~ /^Bad exit status from/) {
            $err = 1;
            $line =~ s/^Bad exit status from \S+ \((%\w+)\)/$1/;
            $msg = "The RPM $line stage exited abnormally";
            last;
        } elsif ($line =~ /^error: failed build dependencies:/) {
            $err = 1;
            while (<RPM>) {
                chomp($line = $_);
                last if ($line !~ /is needed by/);
                $line =~ s/^\s+(\S+)\s+is needed by .*$/$1/;
                push @failed_deps, $line;
            }
            $msg = sprintf("Building this SRPM requires the following packages:  %s", join(" ", @failed_deps));
            last;
        } elsif ($line =~ /^Architecture is not included:/) {
            $err = 1;
            $line =~ s/^Architecture is not included:\s+//;
            $msg = "This SRPM does not build on the $line architecture";
        }
    }
    close(RPM);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0 && $err == 0) {
        $err = 1;
        $msg = "Unhandled RPM build error";
    }
    return ($err, $msg, $srpm);
}

#
# The build process stages
#
sub
do_bootstrap_stage
{
    my $line;
    my $err;
    my $msg;
    my @p = @packages;

    qprint "$progname:  Entering the bootstrap stage.  (${\(&get_timestamp())})\n";
    if (! -d "$builddir") {
        mkdir("$builddir", 0755) || die "Cannot create $builddir -- $!\n";
        foreach $dir ("BUILD", "SRPMS", "RPMS", "SPECS", "SOURCES") {
            mkdir("$builddir/$dir", 0755);
        }
    }
    if (-f "$ENV{HOME}/.rpmmacros" && -s _) {
        $rpmmacros = "$ENV{HOME}/.rpmmacros";
    } else {
        $rpmmacros = "$basedir/rpmmacros";
        if (!(-f "$basedir/rpmmacros" && -s _)) {
            # Create basic rpmmacros
            open(RPMMACROS, ">$rpmmacros") || die "Cannot create $rpmmacros -- $!\n";
            print RPMMACROS "\%_topdir        $builddir\n";
            close(RPMMACROS);
        }
    }
    if (-f "$ENV{HOME}/.rpmrc" && -s _) {
        $rpmrc = "$ENV{HOME}/.rpmrc";
    } else {
        $rpmrc = "$basedir/rpmrc";
        if (!(-f "$basedir/rpmrc" && -s _)) {
            # Create basic rpmrc
            open(RPMRC, ">$rpmrc") || die "Cannot create $rpmrc -- $!\n";
            print RPMRC "optflags:   i386 $ENV{CFLAGS}\n";
            print RPMRC "macrofiles: /usr/lib/rpm/macros:/usr/lib/rpm/%{_target}/macros:/etc/rpm/macros.specspo:",
                         "/etc/rpm/macros:/etc/rpm/%{_target}/macros:~/.rpmmacros:$rpmmacros\n";
            close(RPMRC);
        }
    }
    foreach $pkg (@p) {
        nprint "$progname:  Starting bootstrap stage for the \"$pkg\" package....\n";
        $filename = $pkgs->{$pkg}{FILENAME};
        if ($pkgs->{$pkg}{CVSROOT}) {
            $cvsroot = "-D $pkgs->{$pkg}{CVSROOT}";
        } else {
            $cvsroot = "";
        }
        if ($pkgs->{$pkg}{REVISION}) {
            $tag = "-t $pkgs->{$pkg}{REVISION}";
        } else {
            $tag = "";
        }
        dprint "Checking for $filename\n";
        # If it already exists , go on.
        if (($pkgs->{$pkg}{TYPE} eq "module" && -d $filename)
            || ($pkgs->{$pkg}{TYPE} eq "srpm" && -f $filename && -s _)) {
            nprint "$progname:  $filename already exists.  I'll assume it's the right one.\n";
            nprint "$progname:  Bootstrap stage for \"$pkg\" is complete.\n";
            next;
        }
        $cmd = "$revtool $cvsroot $tag -g $filename";
        ($err, $msg) = &fetch_package($cmd);  # Download the package using revtool
        if ($err == 1) {
            &fail_package($pkg, "bootstrap", $msg);
            next;
        }
        if (!(($pkgs->{$pkg}{TYPE} eq "module" && -d $filename)
              || ($pkgs->{$pkg}{TYPE} eq "srpm" && -f $filename && -s _))) {
            # If it's not there, we must've missed the error.
            &fail_package($pkg, "bootstrap", "Unhandled error condition");
            next;
        }
        nprint "$progname:  Bootstrap stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Bootstrap stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_compose_stage
{
    my ($specfile, $target, $pn, $dir, $err, $line);
    my @contents;
    my @tmp;
    my @p = @packages;

    qprint "$progname:  Entering the compose stage.  (${\(&get_timestamp())})\n";
    # No compose stage for SRPM's since they're *already* SRPM's....
    foreach $pkg (grep $pkgs->{$_}{TYPE} eq "module", @p) {
        nprint "$progname:  Starting compose stage for the \"$pkg\" package....\n";

        # The first step is to examine the module directory to find
        # the names of the vendor source directory and the spec file.
        if (! chdir($pkgs->{$pkg}{MODULE})) {
            &fail_package($pkg, "compose", "Could not chdir into $pkgs->{$pkg}{MODULE} -- $!");
            next;
        }
        ($pn = $prodname) =~ s/^va-//;
        opendir(DIR, ".");
        @contents = readdir(DIR);
        closedir(DIR);
        if ($pkgs->{$pkg}{SPECFILE} && -f $pkgs->{$pkg}{SPECFILE}) {
            # If they gave us the spec file and it exists, use that.
            $specfile = $pkgs->{$pkg}{SPECFILE};
        } else {
            # First choice:  Exactly one file named <pkg>-<distro>.spec
            @tmp = grep($_ =~ /^($pkg-)?(va-)?$pn\.spec/, @contents);
            if ($#tmp != 0) {
                # Second choice:  Exactly one file named <pkg>.spec
                @tmp = grep($_ =~ /^$pkg\.spec/, @contents);
                if ($#tmp != 0) {
                    # Third choice:  The first match to *.spec*
                    @tmp = grep($_ =~ /\.spec/, @contents);
                }
            }
            $specfile = $tmp[0];
            if (!defined $specfile || $specfile =~ /^$/) {
                # Our attempt to guess failed.  They need to specify the spec file in the .prod file.
                &fail_package($pkg, "compose", "No spec file could be located in $pkgs->{$pkg}{MODULE}");
                next;
            }
        }
        if ($pkgs->{$pkg}{DIRECTORY} && -d $pkgs->{$pkg}{DIRECTORY}) {
            # If they gave us the directory name, and it exists as a directory, use it
            $dir = $pkgs->{$pkg}{DIRECTORY};
        } else {
            # First choice:  The only directory not named CVS/SCCS/RCS/BitKeeper in the module
            @tmp = grep($_ !~ /^(CVS|SCCS|RCS|BitKeeper)$/ && -d $_, @contents);
            if ($#tmp != 0) {
                # Second choice:  The only directory that starts with the package name
                @tmp = grep($_ =~ /^$pkg/ && -d $_, @tmp);
                if ($#tmp != 0) {
                    # We're screwed.  Give up.
                    &fail_package($pkg, "compose", "Unable to determine vendor source directory");
                }
            }
            $dir = $tmp[0];
        }

        # tar that bad boy up.
        $cmd = "tar --exclude CVS --exclude RCS --exclude BitKeeper --exclude SCCS -zcf "
                . "$builddir/SOURCES/${pkg}-$pkgs->{$pkg}{VERSION}.tar.gz $dir";
        if (!open(CMD, "$cmd 2>&1 |")) {
            &fail_package($pkg, "compose", "Execution of \"$cmd\" failed -- $!");
            next;
        }
        $err = 0;
        while (<CMD>) {
            chomp($line = $_);
            nprint "tar output -> $line\n";
            if ($line !~ /^$/) {
                # Any output from this command is an error.
                $err = 1;
            }
        }
        close(CMD);
        dprint "\"$cmd\" returned $?\n";
        if ($err || $?) {
            &fail_package($pkg, "compose", "Creation of vendor source tarball failed");
            next;
        }

        # Now build the new SRPM from the new vendor source tarball and the spec file.
        ($err, $msg, $srpm) = &build_rpms($pkg, $specfile);
        if ($err) {
            &fail_package($pkg, "compose", $msg);
            next;
        }
        dprint "Module apparently just built its SRPM as $srpm\n";

        # Copy it here and assign FILENAME to it.
        system("mv $srpm .");
        $pkgs->{$pkg}{FILENAME} = $srpm;
        $pkgs->{$pkg}{FILENAME} =~ s/^(\S+)\/([^\/]+\.src\.rpm)$/$2/;
        $pkgs->{$pkg}{FILENAME} = "$pkgs->{$pkg}{MODULE}/$pkgs->{$pkg}{FILENAME}";
        dprint "Filename is $pkgs->{$pkg}{FILENAME}\n";

        # Go back to where we were.
        if ($basedir =~ /^\.?\.$/) {
            chdir("..");
        } else {
            chdir("$basedir");
        }

        nprint "$progname:  Compose stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Compose stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_explode_stage
{
    my ($cmd, $err, $msg, $line, $specfile, $rpm) = undef;
    my @manifest;
    my @p = @packages;

    qprint "$progname:  Entering the explode stage.  (${\(&get_timestamp())})\n";
    dprint "Packages left:  ", join(" ", @packages), "\n";

    foreach $pkg (@p) {
        undef @manifest;
        nprint "$progname:  Starting explode stage for the \"$pkg\" package....\n";
        $rpm = ($pkgs->{$pkg}{RPMCMD} ? $pkgs->{$pkg}{RPMCMD} : "rpm");

        # Examine the SRPM and figure out everything it contains.
        $cmd = "$rpm --rcfile $rpmrc -qlp $pkgs->{$pkg}{FILENAME}";
        dprint "About to run \"$cmd\"\n";
        if (!open(RPM, "$cmd 2>&1 |")) {
            &fail_package($pkg, "explode", "Execution of \"$cmd\" failed -- $!");
            next;
        }
        if (defined $pkgs->{$pkg}{SPECFILE}) {
            $specfile = $pkgs->{$pkg}{SPECFILE};
        } else {
            undef $specfile;
        }
        while (<RPM>) {
            chomp($line = $_);
            dprint "RPM contents -> $line\n";
            push @manifest, $line;  # Add the file to the manifest
            if ($line =~ /\.spec(\.in)?$/) {
                if (!defined $specfile) {
                    $specfile = $line;
                    dprint "Found spec file as $specfile\n";
                } elsif ($specfile eq $line) {
                    dprint "Found spec file $specfile as predicted.\n";
                } else {
                    qprint "$progname:  Warning:  $pkgs->{$pkg}{FILENAME} contains the spec file $line\n";
                    qprint "$progname:  which is different from the one I was told to expect ($specfile).\n";
                    qprint "$progname:  I will ignore the auto-detected one as requested, but this may be a problem.\n";
                }
            }
        }
        close(RPM);
        dprint "\"$cmd\" returned $?\n";
        if ($? != 0) {
            # FIXME:  What to do here?
        }
        if (! $specfile) {
            &fail_package($pkg, "explode", "Unable to locate spec file in SRPM");
            next;
        }
        # We'll use these later, so they MUST be defined for
        # any package we plan on actually building later.
        $pkgs->{$pkg}{SPECFILE} = "$builddir/SPECS/$specfile";
        $pkgs->{$pkg}{MANIFEST} = join(" ", @manifest);

        # Check for each of those files.
        $err = 0;
        foreach $piece (@manifest) {
            # FIXME:  Need to handle _topdir for people who did their own rpm* files.
            if (($piece =~ /\.spec(\.in)?$/ && -f "$builddir/SPECS/$piece")
                || (-f "$builddir/SOURCES/$piece")) {
                next;
            }
            $err = 1;  # Something is missing.  We must explode this SRPM.
            last;
        }
        # If everything is there, go on.
        if (! $err) {
            nprint "$progname:  SRPM has already been completely exploded.\n";
            nprint "$progname:  Explode stage for \"$pkg\" is complete.\n";
            next;
        }

        # Explode the SRPM into its components
        $cmd = "rpm --rcfile $rpmrc -U $pkgs->{$pkg}{FILENAME}";
        dprint "About to run \"$cmd\"\n";
        if (!open(RPM, "$cmd 2>&1 |")) {
            &fail_package($pkg, "explode", "Execution of \"$cmd\" failed -- $!");
            next;
        }
        $err = 0;
        while (<RPM>) {
            chomp($line = $_);
            nprint "$line\n";
            if ($line !~ /^$/) {
                # Any output from this command is an error.
                $err = 1;
                $msg = "$line";
                last;
            }
        }
        close(RPM);
        dprint "\"$cmd\" returned $?\n";
        if ($? != 0) {
            # FIXME:  What to do here?
        }
        if ($err) {
            &fail_package($pkg, "explode", $msg);
            next;
        }
        nprint "$progname:  Explode stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Explode stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_build_stage
{
    my ($cmd, $err, $msg, $line, $specfile, $rpm, $tmp, $target) = undef;
    my ($target_age, $orig_age, $spec_age);
    my @p = @packages;

    qprint "$progname:  Entering the build stage.  (${\(&get_timestamp())})\n";
    dprint "Packages left:  ", join(" ", @packages), "\n";

    foreach $pkg (@p) {
        nprint "$progname:  Starting build stage for the \"$pkg\" package....\n";

        # Check for a target SRPM that is newer than the original SRPM and the
        # spec file.  If such an SRPM exists, skip the build stage for this package.
        $target = "$builddir/SRPMS/$pkg" . "-"
                   . "$pkgs->{$pkg}{VERSION}" . "-" . "$pkgs->{$pkg}{RELEASE}.src.rpm";
        $specfile = $pkgs->{$pkg}{SPECFILE};
        dprint "Target SRPM is $target\n";
        if (-f $target) {
            $target_age = -M _;
            $orig_age = -M $pkgs->{$pkg}{FILENAME};
            $spec_age = -M $specfile;
            dprint "File ages:  $orig_age for $pkgs->{$pkg}{FILENAME}, $target_age for $target,"
                    . " and $spec_age for $specfile\n";
            if ($target_age < $spec_age && $target_age < $orig_age) {
                nprint "$progname:  The target SRPM already exists.\n";
                nprint "$progname:  Build stage for \"$pkg\" is complete.\n";
                next;
            }
        }

        # Rebuild from the spec file
        ($err, $msg) = &build_rpms($pkg, $specfile);
        if ($err) {
            &fail_package($pkg, "build", $msg);
        }
        nprint "$progname:  Build stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Build stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_package_stage
{
    my ($path, $version, $release);
    my @outfiles;
    my @tmp;
    my @contents;
    my @p = @packages;

    qprint "$progname:  Entering the package accumulation stage.  (${\(&get_timestamp())})\n";

    # Create the directories where we'll put the packages
    # FIXME:  The prod files should probably be able to specify this
    if (! -d "$basedir/$prod") {
        mkdir("$basedir/$prod", 0755) || die "Cannot create $basedir/$prod -- $!\n";
        foreach $dir ("SRPMS", "RPMS") {
            mkdir("$basedir/$prod/$dir", 0755);
        }
    }
    
    dprint "Packages left:  ", join(" ", @packages), "\n";

    foreach $pkg (@p) {
        nprint "$progname:  Starting package accumulation stage for the \"$pkg\" package....\n";
        $version = $pkgs->{$pkg}{VERSION};
        $release = $pkgs->{$pkg}{RELEASE};
        undef @outfiles, @tmp;

        # Find all the RPM's installed by this package
        dprint "Opening directory $builddir/SRPMS to scan for output files.\n";
        opendir(DIR, "$builddir/SRPMS") || die "Cannot open directory $builddir/SRPMS -- $!\n";
        @contents = readdir(DIR);
        foreach $rpm (@contents) {
            if ($rpm =~ /^$pkg-\S*$version-$release\.src\.rpm/) {
                dprint "Got output file $rpm\n";
                push @outfiles, "$builddir/SRPMS/$rpm";
            }
        }
        closedir(DIR);

        dprint "Opening directory $builddir/RPMS to scan for output files.\n";
        opendir(DIR, "$builddir/RPMS") || die "Cannot open directory $builddir/RPMS -- $!\n";
        @contents = readdir(DIR);
        closedir(DIR);
        foreach $dir (@contents) {
            opendir(DIR, "$builddir/RPMS/$dir") || die "Cannot open directory $builddir/RPMS/$dir -- $!\n";
            @tmp = readdir(DIR);
            closedir(DIR);
            foreach $rpm (@tmp) {
                if ($rpm =~ /^$pkg-\S*$version-$release\.\S+\.rpm/) {
                    dprint "Got output file $rpm\n";
                    push @outfiles, "$builddir/RPMS/$dir/$rpm";
                }
            }
        }

        dprint "Output files for $pkg:  ", join(" ", @outfiles), "\n";

        # Move each RPM into the appropriate place
        foreach $rpm (@outfiles) {
            ($path = $rpm) =~ s/^\S+\/(S?RPMS\/)/$1/;  # Get only the names of the subdirectories
            $path =~ s/\/([^\/]+)$//;
            $path = "$basedir/$prod/$path";
            dprint "Path is \"$path\"\n";
            &mkdirhier("$path");
            system("cp $rpm $path/");
        }
        nprint "$progname:  Package accumulation stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Package accumulation stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_iso_stage
{
    my @p = @packages;

    qprint "$progname:  Entering the ISO image stage.  (${\(&get_timestamp())})\n";
    foreach $pkg (@p) {
        nprint "$progname:  Starting ISO image stage for the \"$pkg\" package....\n";

        nprint "$progname:  ISO image stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  ISO image stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_cleanup_stage
{
    my @p = @packages;

    qprint "$progname:  Entering the cleanup stage.  (${\(&get_timestamp())})\n";
    foreach $pkg (@p) {
        nprint "$progname:  Starting cleanup stage for the \"$pkg\" package....\n";

        nprint "$progname:  Cleanup stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Cleanup stage is now complete.  (${\(&get_timestamp())})\n";
}

# Once we're all done, summarize any failures at the very end
# so that they're easy to find if the user is generating a log.
sub
summarize_failures
{
    my $ns, $nf, $nt;

    $ns = $#packages + 1;
    $nf = $#failed_pkgs + 1;
    $nt = $ns + $nf;
    qprintf "Package Summary:  Out of %d total packages, %d succeeded and %d failed.\n", $nt, $ns, $nf;

    foreach $pkg (@failed_pkgs) {
        if ($failure->{$pkg}{MESSAGE}) {
            eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage:  $failure->{$pkg}{MESSAGE}.\n";
        } else {
            eprint "Package \"$pkg\" failed at the $failure->{$pkg}{STAGE} stage.\n";
        }
    }
}

# This routine does the actual build process
sub
build_process
{
    $ENV{MAKE} = "make";  # Make sure we don't parallel build, because it doesn't work.
    $ENV{CFLAGS} = "-O2 -march=pentium";  # A bit of optimization, but not much.
    undef $ENV{LD_LIBRARY_PATH};  # Make glibc happy

    # Perform the build in stages, checking after each one to see if we should stop
    &do_bootstrap_stage();
    return if ($opt_b eq "s");

    &do_compose_stage();
    return if ($opt_b eq "c");

    &do_explode_stage();
    return if ($opt_b eq "e" || $opt_b eq "x");

    &do_build_stage();
    return if ($opt_b eq "b");

    &do_package_stage();
    return if ($opt_b eq "p");

    &do_iso_stage();
    return if ($opt_b eq "i");

    &do_cleanup_stage();
}

# main() here is basically the same as main() in C
sub
main
{
    $prod = $opt_p;
    ($prodname, $prodver) = split("-", $prod);

    if (! $prod) {
        eprint "You didn't tell me what to build, so I'm not quite sure what to do.\n";
        eprint "If you aren't familiar with how to use $progname, try $progname --help.\n";
        return;
    }

    # Parse the product definition files to figure out what the heck we need to build. :)
    if (! &parse_product_def($prod)) {
        # FIXME:  Eventually this should fall back on treating it like a module
        eprint "$prod does not seem to be a product.  Perhaps you made a typo?\n";
        return;
    }

    &build_process();
    &summarize_failures();
}

BEGIN {

    # Set up the basic variables
    $progname = "buildtool";
    $version = "0.1.0";

    # Synchronize output so it doesn't get all jumbled
    select STDERR; $| = 1;
    select STDOUT; $| = 1;

    # See the Getopt::Mixed man page for details on the syntax of this line
    $valid_opts = "h help>h v version>v d debug>d b=s build>b p=s product>p package>p"
                   . " q quiet>q Q really-quiet>Q silent>Q D dir>D f force>f";

    Getopt::Mixed::getOptions($valid_opts);
    $debug = $opt_d;
    $verbosity = ($opt_Q ? 0 : ($opt_q ? 1 : 2));
    if ($opt_D) {
        $proddir = $opt_D;
    } elsif ($ENV{PROD_DIR}) {
        $proddir = $ENV{PROD_DIR};
    } else {
        $proddir = ".";
    }
    $opt_b = "p" if (! $opt_b);
    $basedir = ($ENV{BASE_DIR} ? $ENV{BASE_DIR} : ".");
    $builddir = ($ENV{BUILD_DIR} ? $ENV{BUILD_DIR} : "$basedir/build");
    $revtool = sprintf("revtool%s", ($opt_d ? " --debug" : ""));
    if ($opt_v) {
	print "$progname $version by Michael Jennings\n";
        print "Copyright (c) 2000, Michael Jennings and VA Linux Systems, Inc.\n";
	exit(0);
    }
    if ($opt_h) {
	&print_usage_info();   # Never returns
    }
}

&main();

END {

}
