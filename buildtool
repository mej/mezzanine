#!/usr/bin/perl -w
#
# buildtool -- Product Build Management Tool
# 
# Copyright (C) 2000-2001, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: buildtool,v 1.145 2001/07/20 15:13:55 mej Exp $
#

# Include the Perl Modules we need
require POSIX;
require Getopt::Long;
use Cwd;
use Avalon::Util;
use Avalon::Src;
use Avalon::Build;
use Avalon::Prod;

# Print usage information
sub
print_usage_info
{
    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   buildtool [ options ]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -b --build <stage>               Stop building after a particular stage (see below)\n";
    print "    -p --product --package <name>    Specify the product or package to build\n";
    print "    -q --quiet                       Be somewhat quiet.  Simply gives basic progress info\n";
    print "    -Q --really-quiet --silent       Be very quiet.  Only errors are reported\n";
    print "    -D --dir <directory>             Specify \"directory\" as the base directory for the build\n";
    print "    -f --force                       Ignore errors, build as much as possible\n";
    print "    -l --log <logfile>               Specify a log file to send informational output to\n";
    print "    -P --parallel [expr]             Parallelize the build process based on the number of CPU's\n";
    print "    -t --target <arch>               Tell rpm to build for a particular target architecture\n";
    print "    -C --cflags <flags>              Specify the \$CFLAGS variable to use for building\n";
    print "    -U --user <userid>               Specify a userid for the repository (overrides product files)\n";
    print "       --tree <repository>           Specify the repository to use (overrides all product files)\n";
    print "       --tag <tag>                   Specify a tag to use (overrides all product files)\n";
    print "       --nocache                     Do not scan the cache (use with care)\n";
    print "       --clean                       Clean up RPM and buildroot directories when done\n";
    print "\n";
    print "The stages and their abbreviations (for use with the -b option) are:\n";
    print "  bootstrap (s), component (c), build (b), package accumulation (p)\n\n";
    print "The default is \"-bp\" if you do not specify otherwise.\n\n";
    exit(AVALON_SUCCESS);
}

# Normal print (i.e., don't print this in -q or -Q mode)
sub
nprintf
{
    if ($GLOBAL_LOG || $verbosity >= 2) {
        printf @_;
    }
}
sub
nprint
{
    if ($GLOBAL_LOG || $verbosity >= 2) {
        print @_;
    }
}

# Quiet print (i.e., print in -q mode but not in -Q mode)
sub
qprintf
{
    if ($GLOBAL_LOG || $verbosity >= 1) {
        printf @_;
    }
}
sub
qprint
{
    if ($GLOBAL_LOG || $verbosity >= 1) {
        print @_;
    }
}

# Spawn a child buildtool
sub
spawn_cmd
{
    my ($pkg, $logfile) = @_;
    my $pid;

    do {
        if ($pid = fork()) {
            # Parent -- return PID
            nprint "Spawned child process $pid to build $pkg (log file is $logfile)\n";
            return $pid;
        } elsif (defined $pid) {
            # Child -- reset state as needed and jump to build process
            $opt_f = 0;
            $verbosity = 0;
            $slave = 1;
            $master = 0;
            $opt_master = 0;
            close $GLOBAL_LOG if ($GLOBAL_LOG);
            open(STDOUT, ">/dev/null");
            open(STDIN, "</dev/null");
            if (!open(LOGFILE, ">$logfile")) {
                eprint "Unable to open $logfile -- $!\n";
            } else {
                $GLOBAL_LOG = \*LOGFILE;
                #system("chattr +S $logfile");  # Try to set sync on the log file, fail silently
                open(STDERR, ">&LOGFILE");
                select LOGFILE; $| = 1;
            }
	    # Reduce the package list to just one package.  Then we can proceed
	    # without having to incur the performance penalty of an exec().
            @packages = ($pkg);
            @failed_pkgs = ();
            &build_process();
            close(LOGFILE) if ($GLOBAL_LOG);
            exit (AVALON_SUCCESS);
        } elsif ($! !~ /No more processes/ && $! !~ /Resource temporarily unavailable/) {
            &fatal_error("fork() failed -- $!\n");
        }
        # Temporary failure
        dprint "Failed temporarily -- $!\n";
        sleep 5;
    } while (1);
}

#
# The build process stages
#
sub
do_bootstrap_stage
{
    my ($line, $err, $msg);
    my @p;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    ### The bootstrap stage is where everything gets downloaded.  The list of packages is cycled
    ### through, and each file/module is retrieved from the master repository.  Unfortunately,
    ### this process cannot be properly parallelized because CVS isn't parallel-safe for checkouts.
    qprint "$progname:  Entering the bootstrap stage.  (${\(&get_timestamp())})\n";
    foreach $pkg (@p) {
        my @flist;

        $err = 0;
        &create_rpm_files($pkg);
        if ($pkgs->{$pkg}{STAGES} !~ /s/) {
            nprint "$progname:  Skipping bootstrap stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting bootstrap stage for the \"$pkg\" package....\n";

	# Create @flist, the list of files we need to download for this package.
	# Unless it's an SRPM plus binary RPM's, there will only be one file.
        if ($pkgs->{$pkg}{FILENAME} eq $pkgs->{$pkg}{MODULE}) {
            push(@flist, $pkgs->{$pkg}{MODULE});
        } else {
            push(@flist, "$pkgs->{$pkg}{MODULE}/$pkgs->{$pkg}{FILENAME}");
        }
        if (defined($pkgs->{$pkg}{BINS})) {
            push(@flist, @{$pkgs->{$pkg}{BINS}});
        }
	# Set the proper CVSROOT and tag for the checkout.
        if ($global_tree) {
            $cvsroot = "-D $global_tree";
        } elsif ($pkgs->{$pkg}{CVSROOT}) {
            $cvsroot = "-D $pkgs->{$pkg}{CVSROOT}";
        } else {
            $cvsroot = "";
        }
        if ($global_user) {
            $cvsroot =~ s/\w+\@/$global_user\@/;
        }
        if ($global_tag) {
            $tag = "-t $global_tag";
        } elsif ($pkgs->{$pkg}{REVISION}) {
            ($tag = $pkgs->{$pkg}{REVISION}) =~ s/^([^:]+):([^:]+)$/$2/;
            $tag = "-t $tag";
        } else {
            $tag = "";
        }

	# Check out each file using revtool
        foreach $filename (@flist) {
            last if ($err);
            dprint "Checking for $filename\n";
            # If it already exists, go on.
            if ((($pkgs->{$pkg}{TYPE} eq "module" || $pkgs->{$pkg}{TYPE} eq "image") && -d $filename)
                || (($pkgs->{$pkg}{TYPE} eq "srpm" || $pkgs->{$pkg}{TYPE} eq "rpm" || $pkgs->{$pkg}{TYPE} eq "tar") && -f $filename && -s _)) {
                nprint "$progname:  $filename already exists.  I'll assume it's the right one.\n";
                next;
            }
            $cmd = "$revtool -l $cvsroot $tag -g $filename";
            ($err, $msg) = &fetch_package($cmd);
            if ($err) {
                &fail_package($pkg, "bootstrap", $msg);
                next;
            }
            if (!((($pkgs->{$pkg}{TYPE} eq "module" || $pkgs->{$pkg}{TYPE} eq "image") && -d $filename)
                  || (($pkgs->{$pkg}{TYPE} eq "srpm" || $pkgs->{$pkg}{TYPE} eq "rpm" || $pkgs->{$pkg}{TYPE} eq "tar") && -f $filename && -s _))) {
                # If it's not there, we must've missed the error.
                $err = AVALON_PACKAGE_FAILED;
                &fail_package($pkg, "bootstrap", "Unhandled error condition");
                next;
            }
        }

        nprint "$progname:  Bootstrap stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Bootstrap stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_component_stage
{
    my ($specfile, $target, $pn, $dir, $line, $src, $tarball, $rpm);
    my ($err, $msg, $srpm) = (0, 0, 0);
    my (@contents, @tmp, @dirs, @sfiles, @srcs, @manifest);
    my @p;
    local *DIR;
    local *PKGTOOL;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    ### The component stage is where all the individual package components are obtained and put
    ### into place.  For modules, this means creating source and patch files and copying them into.
    ### For source packages, it means exploding the source package.  No other packages use this stage.
    qprint "$progname:  Entering the component stage.  (${\(&get_timestamp())})\n";

    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /c/) {
            nprint "$progname:  Skipping component stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting component stage for the \"$pkg\" package....  (${\(&get_timestamp())})\n";

        if (! chdir("$builddir/$pkgs->{$pkg}{MODULE}")) {
            &fail_package($pkg, "component", "Could not chdir into $builddir/$pkgs->{$pkg}{MODULE} -- $!");
            next;
        }

        if ($pkgs->{$pkg}{TYPE} eq "module") {
            ### If there's a makefile, skip this stage.
            if (-s "$builddir/$pkgs->{$pkg}{MODULE}/Makefile.avalon") {
                nprint "$progname:  Avalon makefile exists, skipping component stage.\n";
                next;
            }

            ### Check to see if we really need to do this stage or not.
            # Find matches to pkg-*-*.src.rpm in the SRPMS directory
            @tmp = &grepdir(sub {/^$pkg-([^-]+)-([^-]+)\.(?:no)?src\.rpm$/}, "$builddir/SRPMS");
            if (scalar(@tmp) > 0) {
                # Keep the first one
                $srpm = $tmp[0];
                # If there are more, ignore them, but warn the user
                if ($#tmp > 0) {
                    nprint "$progname:  Warning:  Multiple target SRPM's found in $pkgs->{$pkg}{MODULE}.\n";
                    nprint "$progname:  Assuming that $srpm is the correct one.\n";
                }
                # The target SRPM already exists.  Skip this stage.
                nprint "$progname:  The target SRPM for \"$pkg\" already exists ($builddir/SRPMS/$srpm).\n";
                nprint "$progname:  I'll assume it's the right one.  Component stage for \"$pkg\" is complete.\n";
                # (?:) means "don't include this as a $<num> variable"
                $srpm =~ m/^(\S+)-([^-]+)-([^-]+)\.(?:no)?src\.rpm$/;
                ($pkgs->{$pkg}{VERSION}, $pkgs->{$pkg}{RELEASE}) = ($2, $3);
                $pkgs->{$pkg}{FILENAME} = "$builddir/SRPMS/$srpm";
                $pkgs->{$pkg}{STAGES} =~ s/b//;  # Don't do build stage either.
                next;
            }

	    if (-d "F") {
		### It's an SPM.  Just copy all the files into the right places.
		$specfile = &install_spm_files($builddir);
		if (! $specfile) {
		    &fail_package($pkg, "component", "Could not copy component files into $builddir");
		    next;
		}
		$pkgs->{$pkg}{SPECFILE} = $specfile;
	    } else {
		### The next step is to find the spec file.  If it's an oddball
		### case, they better have told us what it's actually called....
		opendir(DIR, ".");
		@contents = readdir(DIR);
		closedir(DIR);
		if ($pkgs->{$pkg}{SPECFILE} && -f $pkgs->{$pkg}{SPECFILE}) {
		    # If they gave us the spec file and it exists, use that.
		    $specfile = $pkgs->{$pkg}{SPECFILE};
		    dprint "User specified a spec file:  $specfile\n";
		} else {
		    # First choice:  Exactly one file named <pkg>-<distro>.spec
		    ($pn = $prodname) =~ s/^va-//;
		    @tmp = grep($_ =~ /^($pkg-)?(va-)?$pn\.spec/, @contents);
		    if ($#tmp != 0) {
			# Second choice:  Exactly one file named <pkg>.spec
			@tmp = grep($_ =~ /^$pkg\.spec/, @contents);
			if ($#tmp != 0) {
			    # Third choice:  The first match to *.spec*
			    @tmp = grep($_ =~ /\.spec/, @contents);
			}
		    }
		    $pkgs->{$pkg}{SPECFILE} = $specfile = $tmp[0];
		    if (!defined $specfile || $specfile =~ /^$/) {
			# Our attempt to guess failed.  They need to specify the spec file in the .prod file.
			&fail_package($pkg, "component", "No spec file could be located in $pkgs->{$pkg}{MODULE}");
			next;
		    }
		}

		### Next, generate the source files
		($err, $msg) = &gen_sources($pkg, $specfile);
		if ($err) {
		    &fail_package($pkg, "component", "Creation of vendor sources failed -- $msg");
		    next;
		}
	    }
        } elsif ($pkgs->{$pkg}{TYPE} eq "srpm") {
            my $rpmrc = "$buildroot/$pkg-rpmrc";

            if (defined($pkgs->{$pkg}{BINS})) {
                dprint "This package shouldn't even be using the component stage!  Skipping it.\n";
                next;
            }

            undef @manifest;
            $rpm = ($pkgs->{$pkg}{RPMCMD} ? $pkgs->{$pkg}{RPMCMD} : "rpm");

            ### Examine the SRPM and figure out everything it contains.
            $cmd = "$pkgtool -P \"$rpm\" -R $rpmrc -cp $pkgs->{$pkg}{FILENAME}";
            dprint "About to run \"$cmd\"\n";
            if (!open(PKGTOOL, "$cmd 2>&1 |")) {
                &fail_package($pkg, "component", "Execution of \"$cmd\" failed -- $!");
                next;
            }
	    # We've got to record the spec file name for later use
            if (defined $pkgs->{$pkg}{SPECFILE}) {
                $specfile = $pkgs->{$pkg}{SPECFILE};
            } else {
                undef $specfile;
            }
            while (<PKGTOOL>) {
                chomp($line = $_);
                next if ($line =~ /^\[pkgtool\//);
                dprint "RPM contents -> $line\n";
                # Add the file to the manifest
                push @manifest, $line;
                if ($line =~ /\.spec(\.in)?$/) {
                    if (!defined $specfile) {
                        $specfile = $line;
                        dprint "Found spec file as $specfile\n";
                    } elsif ($specfile eq $line) {
                        dprint "Found spec file $specfile as predicted.\n";
                    } else {
                        qprint "$progname:  Warning:  $pkgs->{$pkg}{FILENAME} contains the spec file $line\n";
                        qprint "$progname:  which is different from the one I was told to expect ($specfile).\n";
                        qprint "$progname:  I will ignore the auto-detected one as requested, but this may be a problem.\n";
                    }
                }
            }
            close(PKGTOOL);
            dprint "\"$cmd\" returned $?\n";
            if ($? != 0) {
                # FIXME:  What to do here?
            }
            if (! $specfile) {
                &fail_package($pkg, "component", "Unable to locate spec file in SRPM");
                next;
            }
            # We'll use this later, so it MUST be defined for any
            # package we plan on actually building at some point.
            $pkgs->{$pkg}{SPECFILE} = "$builddir/SPECS/$specfile";

            ### Explode the SRPM into its components
            $cmd = "$pkgtool -P \"$rpm\" -R $rpmrc -ip $pkgs->{$pkg}{FILENAME}";
            dprint "About to run \"$cmd\"\n";
            if (!open(PKGTOOL, "$cmd 2>&1 |")) {
                &fail_package($pkg, "component", "Execution of \"$cmd\" failed -- $!");
                next;
            }
            $err = 0;
            while (<PKGTOOL>) {
                chomp($line = $_);
                next if ($line =~ /^\[pkgtool\//);
                nprint "$line\n";
                if ($line !~ /successfully installed\.?$/) {
                    # Any otheroutput from this command is an error.
                    $err = 1;
                    ($msg = $line) =~ s/^pkgtool:\s+Error:\s+//;;
                    last;
                }
            }
            close(PKGTOOL);
            dprint "pkgtool returned $?\n";
            if ($? != 0) {
                # FIXME:  What to do here?
            }
            if ($err) {
                &fail_package($pkg, "component", $msg);
                next;
            }
        }

        nprint "$progname:  Component stage for \"$pkg\" is complete.  (${\(&get_timestamp())})\n";
    }
    chdir($builddir);
    qprint "$progname:  Component stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_build_stage
{
    my ($cmd, $line, $specfile, $rpm, $tmp, $target) = undef;
    my ($target_age, $orig_age, $spec_age);
    my ($err, $msg, $srpm) = (0, 0, 0);
    my @p;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    ### The build stage is where module, SRPM, and tar packages are built from sources.  Also,
    ### binary packages (and source packages with binaries) are copied into the RPM directories.
    qprint "$progname:  Entering the build stage.  (${\(&get_timestamp())})\n";

    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /b/) {
            nprint "$progname:  Skipping build stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting build stage for the \"$pkg\" package....  (${\(&get_timestamp())})\n";

        if (! chdir("$builddir/$pkgs->{$pkg}{MODULE}")) {
            return (AVALON_PACKAGE_FAILED, "Could not chdir into $builddir/$pkgs->{$pkg}{MODULE} -- $!", 0);
        }
        if (defined($pkgs->{$pkg}{BINS})) {
            my ($arch, $rpm, $file, $dest);

            # Source and binaries.
            $file = $pkgs->{$pkg}{FILENAME};
            $rpm = &basename($file);
            $dest = "$builddir/SRPMS/" . $rpm;
            if (-s $dest) {
                dprint "$dest already exists.\n";
            } else {
                dprint "ln -f $file $dest\n";
                &mkdirhier("$builddir/SRPMS") if (! -d "$builddir/SRPMS");
                if (!link($file, $dest)) {
                    return (AVALON_PACKAGE_FAILED, "Could not link $dest to $file -- $!", 0);
                }
            }
            $pkgs->{$pkg}{OUTFILES} = $dest;
            chdir($builddir);
            foreach $rpm (@{$pkgs->{$pkg}{BINS}}) {
                my $bin;

                $rpm =~ m/^.*\/([^\/]+)\.(\w+)\.rpm$/;
                $arch = $2;
                $bin = "$builddir/RPMS/$arch/$1.$arch.rpm";
                $pkgs->{$pkg}{OUTFILES} .= " $bin";
                if (-s $bin) {
                    dprint "$bin already exists\n";
                } else {
                    dprint "ln -f $rpm $bin\n";
                    &mkdirhier("$builddir/RPMS/$arch") if (! -d "$builddir/RPMS/$arch");
                    if (!link($rpm, $bin)) {
                        return (AVALON_PACKAGE_FAILED, "Could not link $bin to $rpm -- $!", 0);
                    }
                }
            }
        } elsif ($pkgs->{$pkg}{TYPE} eq "rpm") {
            my ($rpm, $arch, $dest);

            # Binary package.  Just move it into place.
            ($rpm = $pkgs->{$pkg}{FILENAME}) =~ m/\.(\w+)\.rpm/;
            $arch = $1;
            $dest = "$builddir/RPMS/$arch/" . &basename($rpm);
            if (-s $dest) {
                dprint "$dest already exists.\n";
            } else {
                dprint "ln -f $rpm $dest\n";
                &mkdirhier("$builddir/RPMS/$arch") if (! -d "$builddir/RPMS/$arch");
                if (!link($rpm, $dest)) {
                    return (AVALON_PACKAGE_FAILED, "Could not link $dest to $rpm -- $!", 0);
                }
            }
        } elsif ($pkgs->{$pkg}{TYPE} eq "tar") {
            # Rebuild from the tarball
            ($err, $msg, $srpm) = &build_pkgs($pkg, $pkgs->{$pkg}{FILENAME});
            dprint "do_build_stage():  build_pkgs($pkg, $specfile) returned $err, $msg, $srpm\n";
            if ($err) {
                &fail_package($pkg, "build", $msg);
            } else {
                $srpm =~ m/^(\S+)-([^-]+)-([^-]+)\.(?:no)?src\.rpm$/;
                ($pkgs->{$pkg}{VERSION}, $pkgs->{$pkg}{RELEASE}) = ($2, $3);
                dprint "Filename is $pkgs->{$pkg}{FILENAME}, version is $pkgs->{$pkg}{VERSION}, release is $pkgs->{$pkg}{RELEASE}\n";
            }
        } elsif ($pkgs->{$pkg}{TYPE} eq "module") {
            ### If there's a makefile, use special_build() to build it.
            if (-s "$builddir/$pkgs->{$pkg}{MODULE}/Makefile.avalon") {
                ($err, $msg, $srpm) = &special_build($pkg);
                dprint "do_build_stage():  special_build($pkg) returned $err, $msg, $srpm\n";
            } else {
                # Build the module into an SRPM
                $specfile = $pkgs->{$pkg}{SPECFILE};
                ($err, $msg, $srpm) = &build_pkgs($pkg, $specfile);
                dprint "do_build_stage():  build_pkgs($pkg, $specfile) returned $err, $msg, $srpm\n";
            }
            if ($err) {
                &fail_package($pkg, "build", $msg);
            }

            # Update the values for FILENAME, VERSION, and RELEASE
            $pkgs->{$pkg}{FILENAME} = $srpm;
            $srpm =~ s/^(\S+)\/([^\/]+src\.rpm)$/$2/;
            $srpm =~ m/^(\S+)-([^-]+)-([^-]+)\.(?:no)?src\.rpm$/;
            ($pkgs->{$pkg}{VERSION}, $pkgs->{$pkg}{RELEASE}) = ($2, $3);
            dprint "Filename is $pkgs->{$pkg}{FILENAME}, version is $pkgs->{$pkg}{VERSION}, release is $pkgs->{$pkg}{RELEASE}\n";
        } else {  # SRPM
            # Check for a target SRPM that is newer than the original SRPM and the
            # spec file.  If such an SRPM exists, skip the build stage for this package.
            $target = "$builddir/SRPMS/$pkg" . "-"
                       . "$pkgs->{$pkg}{VERSION}" . "-" . "$pkgs->{$pkg}{RELEASE}.src.rpm";
            $specfile = $pkgs->{$pkg}{SPECFILE};
            dprint "Target SRPM is $target\n";
            if (-f $target) {
                $target_age = -M _;
                $orig_age = -M $pkgs->{$pkg}{FILENAME};
                $spec_age = -M $specfile;
                dprint "File ages:  $orig_age for $pkgs->{$pkg}{FILENAME}, $target_age for $target,"
                        . " and $spec_age for $specfile\n";
                if ($target_age < $spec_age && $target_age < $orig_age) {
                    nprint "$progname:  The target SRPM already exists.\n";
                    nprint "$progname:  Build stage for \"$pkg\" is complete.\n";
                    next;
                }
            }

            # Rebuild from the spec file
            ($err, $msg, $srpm) = &build_pkgs($pkg, $specfile);
            dprint "do_build_stage():  build_pkgs($pkg, $specfile) returned $err, $msg, $srpm\n";
            if ($err) {
                &fail_package($pkg, "build", $msg);
            }
        }
        nprint "$progname:  Build stage for \"$pkg\" is complete.  (${\(&get_timestamp())})\n";
    }
    chdir($builddir);
    qprint "$progname:  Build stage is now complete.  (${\(&get_timestamp())})\n";
}

sub
do_package_stage
{
    my ($path, $version, $release, $type);
    my @outfiles;
    my @contents;
    my @p;
    local *DIR;

    if ($#_ >= 0) {
        @p = @_;
    } else {
        @p = @packages;
    }

    ### The package accumulation stage is where the output files (source and binary RPM's) from the
    ### build stage are copied (technically, linked) into their proper locations within image modules.
    qprint "$progname:  Entering the package accumulation stage.  (${\(&get_timestamp())})\n";

    foreach $pkg (@p) {
        if ($pkgs->{$pkg}{STAGES} !~ /p/) {
            nprint "$progname:  Skipping package accumulation stage for the \"$pkg\" package.\n";
            next;
        }
        nprint "$progname:  Starting package accumulation stage for the \"$pkg\" package....\n";
        $type = $pkgs->{$pkg}{TYPE};
        $version = $pkgs->{$pkg}{VERSION};
        $release = $pkgs->{$pkg}{RELEASE};
        undef @outfiles;

	### Look for output files.  Hopefully we recorded them from earlier.  If not, hunt for them.
        dprint "Checking for output files for $pkg $version-$release\n";
        if ($pkgs->{$pkg}{OUTFILES}) {
            dprint "Output files [$pkgs->{$pkg}{OUTFILES}] saved from earlier.\n";
            @outfiles = split(" ", $pkgs->{$pkg}{OUTFILES});
        } else {
            if ($type eq "srpm" || $type eq "module" || $type eq "tar") {
                # Find all the RPM's installed by this package
                dprint "Opening directory $builddir/SRPMS to scan for output files.\n";
                foreach $rpm (&grepdir(sub {/^\Q$pkg-\E\S*\Q$version-$release\E\.(?:no)?src\.rpm$/}, "$builddir/SRPMS")) {
                    dprint "Got output file $rpm\n";
                    push @outfiles, "$builddir/SRPMS/$rpm";
                }

                dprint "Opening directory $builddir/RPMS to scan for output files.\n";
                @contents = glob("$builddir/RPMS/*/*.rpm");
                foreach $rpm (@contents) {
                    my $srpm;

                    dprint "Checking $rpm\n";
                    if (defined $srpm_of_rpm{$rpm}) {
                        $srpm = $srpm_of_rpm{$rpm};
                    } else {
                        $srpm = `rpm -qp $rpm --queryformat \"%{SOURCERPM}\"`;
                        $srpm_of_rpm{$rpm} = $srpm;
                    }
                    if ($srpm =~ /^\Q$pkg-\E\S*\Q$version-$release\E\.(?:no)?src\.rpm$/) {
                        dprint "Got output file $rpm\n";
                        push @outfiles, $rpm;
                    }
                }
            } elsif ($type eq "rpm") {
                my ($filename, $arch, $outfile);

                ($filename = $pkgs->{$pkg}{FILENAME}) =~ s/^.*\/([^\/]+)$/$1/;
                ($arch = $filename) =~ s/^.*\.(\w+)\.rpm$/$1/;
                $outfile = "$builddir/RPMS/$arch/$filename";
                dprint "Output RPM is $outfile\n";
                if (-f $outfile) {
                    push @outfiles, $outfile;
                }
            }
        }

	# If we didn't find any, something is very wrong.
        if ($#outfiles == -1) {
            &fail_package($pkg, "package accumulation", "No output RPM's were found");
            next;
        }
        dprint "Output files for $pkg:  ", join(" ", @outfiles), "\n";

        # Copy each RPM into the appropriate place
        foreach $rpm (@outfiles) {
            my $found;

            $found = &place_file($pkg, $rpm);
            if ($found == 0) {
                qprint "Warning:  No location found matching $rpm\n";
            } else {
                dprint "Found $found locations for $rpm\n";
            }
        }
        nprint "$progname:  Package accumulation stage for \"$pkg\" is complete.\n";
    }
    qprint "$progname:  Package accumulation stage is now complete.  (${\(&get_timestamp())})\n";
}

# main() here is basically the same as main() in C
sub
main
{
    # Set up the basic variables
    $progname = "buildtool";
    $version = "2.0";
    umask 022;

    # No input.
    open(STDIN, "</dev/null");

    # See the Getopt::Long man page for details on the syntax of this line
    @valid_opts = ("h|help", "v|version", "d|debug", "b|build=s", "p|product|package=s",
                   "q|quiet", "Q|really-quiet|silent", "D|dir=s", "f|force", "l|log=s",
                   "P|parallel:s", "t|target=s", "C|cflags=s", "B|startbuild=s", "tree=s",
                   "tag=s", "nocache", "clean:s", "U|user=s");
    Getopt::Long::Configure("no_getopt_compat", "bundling", "no_ignore_case");
    Getopt::Long::GetOptions(@valid_opts);

    # Post-parse the options stuff
    if ($opt_v) {
        # Do not edit this variable.  It is updated automatically by CVS when you commit
        my $rcs_info = 'CVS Revision $Revision: 1.145 $ created on $Date: 2001/07/20 15:13:55 $ by $Author: mej $ ';

        $rcs_info =~ s/\$\s*Revision: (\S+) \$/$1/;
        $rcs_info =~ s/\$\s*Date: (\S+) (\S+) \$/$1 at $2/;
        $rcs_info =~ s/\$\s*Author: (\S+) \$ /$1/;
        print "\n";
	print "$progname $version by Michael Jennings <mej\@eterm.org>\n";
        print "Copyright (c) 2000, Michael Jennings and VA Linux Systems, Inc.\n";
        print "  ($rcs_info)\n";
        print "\n";
	return AVALON_SUCCESS;
    }
    if ($opt_h) {
	&print_usage_info();   # Never returns
    }
    &debug_set($opt_d);
    $revtool = "revtool" . (&debug_get() ? " --debug" : "");
    $pkgtool = "pkgtool" . (&debug_get() ? " --debug" : "");
    $GLOBAL_LOG = 0;
    open(STDERR, ">&STDOUT");
    if ($opt_l) {
        if (!open(LOGFILE, ">$opt_l")) {
            eprint "Unable to open $opt_l -- $!\n";
        } else {
            $GLOBAL_LOG = \*LOGFILE;
            #system("chattr +S $opt_l");  # Try to set sync on the log file, fail silently
            open(STDOUT, ">&LOGFILE");
            select LOGFILE; $| = 1;
        }
    }
    select STDOUT; $| = 1;
    $verbosity = ($opt_Q ? 0 : ($opt_q ? 1 : 2));
    $target = $opt_t;
    $global_user = $opt_U;
    $global_tree = $opt_tree;
    $global_tag = $opt_tag;

    # Set up the start/end stage identifiers
    $start_stage = ($opt_B ? $opt_B : "s");
    if (index("Zscbp", $start_stage) == -1) {
        eprint "Bad start stage \"$start_stage\".  Assuming \"s\".\n";
        $start_stage = "s";
    }
    $end_stage = ($opt_b ? $opt_b : "p");
    if ($end_stage ne "Z") {
        if (index("scbp", $end_stage) == -1) {
            eprint "Bad end stage \"$end_stage\".  Assuming \"p\".\n";
            $end_stage = "p";
        } elsif (index("scbp", $start_stage) > index("scbp", $end_stage)) {
            eprint "End stage \"$end_stage\" comes before start stage \"$start_stage\".\n";
            $start_stage = "s";
            $end_stage = "p";
        }
        dprint "Building stages \"$start_stage\" through \"$end_stage\"\n";
    }

    # Figure out parallelization stuff
    if ($opt_master) {
        $slave = 1;
        $master = 0;
    } elsif (defined($opt_P)) {
        $master = 1;
        $slave = 0;
        $num_cpus = &count_cpus();
        if ($opt_P) {
            my ($mult, $add);

            $opt_P =~ m/^(?:[Xx]([\d.]+))?([-+][\d.]+)?$/;
            ($mult, $add) = ($1, $2);
            dprint "Modifying \$num_cpus:  $opt_P   $mult   $add\n";
            $num_cpus = $num_cpus * ($mult ? $mult : 1) + ($add ? $add : 0);
        }
    } else {
        $master = 0;
        $slave = 0;
        $num_cpus = 1;
    }
    dprint "Using $num_cpus parallel processes.\n";

    # Try to parse the product name we were given into a name or a name-version combo
    if ($opt_p) {
        $prod = $opt_p;
        if ($prod =~ /^(\S+)-((?:\d|us|a|alpha|b|beta)[^-]+)$/) {
            ($prodname, $prodver) = ($1, $2);
        } else {
            ($prodname, $prodver) = ($prod, 0);
        }
        if ($opt_D && -d $opt_D) {
            $basedir = $opt_D;
        } elsif ($ENV{BASE_DIR} && $ENV{BASE_DIR} =~ /^\// && -d $ENV{BASE_DIR}) {
            $basedir = $ENV{BASE_DIR};
        } else {
            chomp($basedir = `pwd`);
        }
	if (-d "$basedir/$prod") {
	    $builddir = $basedir;
	} elsif ($ENV{BUILD_DIR}) {
	    $builddir = $ENV{BUILD_DIR};
	} else {
	    $builddir = "$basedir/build";
	}
    } else {
        my $cwd = &getcwd();

        $prod = $prodname = &basename($cwd);
        $basedir = $cwd;
        $builddir = &dirname($cwd);
	dprint "No product specified.  Assuming product \"$prod\" with base dir $basedir and build dir $builddir\n";
    }
    $buildroot = ($ENV{BUILDROOT} ? $ENV{BUILDROOT} : "/var/tmp/buildtool.$$");
    qprint "$progname:  Building product:  $prodname", ($prodver ? " $prodver" : ""), "\n";

    # Try to find the products directory
    foreach $dir (($ENV{PROD_DIR} ? $ENV{PROD_DIR} : 0), "$basedir/products", "$basedir/../products") {
	if ($dir && -d $dir) {
	    $proddir = $dir;
	    last;
	}
    }

    # Signal handling
    $SIG{HUP} = 'IGNORE';
    $SIG{INT} = \&handle_signal;
    $SIG{TERM} = \&handle_signal;
    $SIG{QUIT} = \&handle_fatal_signal;
    $SIG{ILL} = \&handle_fatal_signal;
    $SIG{ABRT} = \&handle_fatal_signal;
    $SIG{FPE} = \&handle_fatal_signal;
    $SIG{SEGV} = \&handle_fatal_signal;
    $SIG{BUS} = \&handle_fatal_signal;
    $SIG{TSTP} = 'IGNORE';
    $SIG{TTIN} = 'IGNORE';
    $SIG{TTOU} = 'IGNORE';

    # Environment modifications
    $ENV{MAKE} = "make";  # Make sure we don't parallel build, because it doesn't work.
    $ENV{CFLAGS} = ($opt_C ? $opt_C : "-O2 -march=pentiumpro");
    delete $ENV{LD_RUN_PATH};  # Don't hard code any RPATH's into binaries
    delete $ENV{LD_LIBRARY_PATH};  # Make glibc happy
    $ENV{PATH} = "/usr/build/bin:/usr/local/build/bin:/usr/lib/qt-1.45/bin:/usr/lib/qt-2.1.0/bin"
                  . ":/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/kerberos/sbin"
                  . ":/usr/kerberos/bin:.";

    # Parse the product definition files to figure out what the heck we need to build. :)
    # If we're a slave process, we know it's going to be a straight product entry.
    if ($slave || ! &parse_prod_file($prodname, $prodver, 0)) {
        if (! &parse_product_entry($prod)) {
            eprint "$prod does not seem to be a valid product or product entry.\n";
            eprint "Perhaps you made a typo?\n";
            return AVALON_BAD_PRODUCT;
        }
    }
    dprint "Products to be built:  ", join(" ", @products), "\n";

    if (! $opt_clean) {
        if (scalar(@packages) > 1) {
            $opt_clean = "root";
        } else {
            $opt_clean = "all";
        }
    }
    dprint "Cleaning:  $opt_clean\n";

    if ($end_stage ne "Z") {  # -dbZ, a.k.a. How To Debug the Parser :-)
        &initial_setup();
        &build_process();
        &cleanup($opt_clean);
    } else {
        # This way we can just do cleanup. :-)
        &cleanup($opt_clean);
    }
    return (defined(@failed_pkgs) && $#failed_pkgs != -1) ? AVALON_PACKAGE_FAILED : AVALON_SUCCESS;
}

exit &main();

END {
    &summarize_failures() if (! $slave);
    close($GLOBAL_LOG) if ($GLOBAL_LOG);
}
