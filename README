########################################################################
#            Software Engineering Build Server Information
#
#  Written by:  Michael Jennings
#               Ted T'so
#
#  $Id: README,v 1.11 2000/07/01 02:19:04 mej Exp $
#
########################################################################

0.  INTRODUCTION AND QUICK START
--------------------------------

This document is intended as a brief overview of the new Software
Engineering build system:  how it works, how to use it, and some of the
design philosophies behind it.  It also details the various standards
policies which govern its contents, so those planning on adding to
and/or maintaining part(s) of the tree should read those sections
carefully.

For those wishing to simply build a particular VA product, the first
step is to make sure you can access the repository.  To do this, set
the CVSROOT environment variable to the following value:

:pserver:anonymous@engr.su.valinux.com:/cvs/build

Next, cd into the directory where you want the build to occur and type
the following command:

$ revtool -g products

This will obtain the product files from the master server and place
them into a directory called products underneath the current
directory.  Find the file with the name of the product you wish to
build, then invoke the following command at your shell prompt:

$ buildtool -p <product>

...where <product> is the name of the product file, but without the
.prod on the end.  Executing this command will build all packages
associated with that product, both binary and source packages.  If you
wish to build ISO images as well, use "buildtool -bi -p <product>".

The following sections will have more detailed information on how to
use the system, so if you are going to be involved in the actual day-
to-day maintenance of the system or any packages within the system,
keep reading!


1.  OVERALL PHILOSOPHY
----------------------

The build system is designed on two basic concepts:  the "product" and
the "package."  A "product" is a collection of packages which form some
coherent entity when you put them all together, such as a distribution.
A "package" is the basic unit which the build system must know how to
take from its "source" form and generate its "target" form.  Take care
not to confuse this term with "package file."  Although a package can
take the form of a package file, like an SRPM, not all packages are
package files, nor are all package files packages.

In general, the build system works with two general classifications of
packages.  Some packages are modified by VA before being included in
our enhanced distribution(s), while others are taken directly from
RedHat or some other source.  The build system must be able to
seamlessly handle both these cases.  For the latter case, the packages
are simply kept as SRPM's, and buildtool knows how to explode the SRPM
and build from the exploded sources.

The former case is much more complicated.  Packages which are modified
internally by VA are stored as directory trees containing the source,
the necessary spec files, and any other files required by the build
process.  These directory trees will hereafter be referred to by their
proper term in revision control lingo, "modules."

Several tools are employed as user-level interfaces to this system.
The first, called "revtool," handles all interaction with the revision
control system.  It encapsulates all revision-control-system-specific
commands and gives them an interface which is independent of the
underlying system.  Thus, if the repository was moved from CVS to,
say, BitKeeper, revtool's code would change, but its interface would
remain the same.

The second tool is "buildtool," mentioned briefly above.  buildtool is
what takes a product name/version pair, like "va-redhat-6.2.1" and
translates that via a series of product definition/configuration files
("prod files" for short) into a set of packages to build.  It then
builds those packages, creating both source and binary package files.
It can also use these packages to build ISO images for product CD's.

There are other tools, such as pkgtool and safetool, which are not yet
ready for widespread use.  We'll discuss those when that situation
changes.


2.  REVISION CONTROL WITH REVTOOL
---------------------------------

The syntax of revtool is intended to be generic, in that it should
apply well to any arbitrary revision control system one might choose.
Each function revtool performs should translate into zero or more
commands specific to the revision control system in question.  For
example, a "put" in revtool-speak is analogous to a "commit" in CVS
lingo.  A "get" in revtool is either a "checkout" or an "update" in
CVS, or a "pull" in BitKeeper.  Thus, revtool acts as an encapsulation
layer for the underlying revision control system.

revtool also assists in routine upkeep actions, like maintaining the
ChangeLog.  revtool will append your commit log entry to the ChangeLog
automatically.  It will even create the ChangeLog for you if it
doesn't exist, and the date and identity information are provided for
you.

Finally, revtool acts as a means of policy enforcement.  This allows
us to ensure that commits are properly tagged, for example.
Consistency and cleanliness of operation are vital for the ongoing
functionality, stability, and manageability of the build system, and
revtool allows us to enforce the policies that provide those things
before anything enters the tree that could disrupt it.

2.1.  Retrieving and Updating Package Sources
---------------------------------------------

The most common activity for which revtool is used is obtaining
sources from the master server.  In revtool lingo, this is referred to
as a "get" operation and is performed via the "-g" or "--get"
options.  If any names are present on the command line, they will be
used.  If you wish to specify a particular tag for the get operation,
use the -t option.

Examples:

  To update a module in the current directory:
     revtool -g

  To download the "Eterm" module from the master server:
     revtool -g Eterm

  To retrieve the "imlib" package using a tag:
     revtool -gt IMLIB-1-9-8 imlib

  To obtain the "varmon" and "vacm" trees simultaneously:
     revtool -g varmon vacm

2.2.  Adding and Removing Files from the Master Server
------------------------------------------------------

As part of maintaining a package, it is sometimes necessary to add or
remove files from the source tree.  Special steps must be taken within
a revision control environment to add/remove files while still
maintaining the ability to check out the tree exactly as it existed in
a particular version or at a particular date/time.  Thus, you must use
revtool when adding or deleting files within a module.

Addition is done using the "-a" or "--add" options.  Removal uses the
"-r" or "--remove" options.  These options require that the files to
be added or removed be listed on the command line, and they cannot be
used simultaneously.  (If no files are listed on the command line, but
revtool is being run from a tty, you will be prompted to enter the
filename globs.)

The option syntax of revtool is designed to allow several things to
happen at once.  For example, you can add files and commit them with a
single revtool command.  The same applies for removing files.  An
unfortunate side effect of this ability is that you cannot use -a and
-r at the same time.  However, it is still possible to add some files,
remove some other files, and commit the module, all at once.  You must
use the --add-list and --rem-list options to do this.

Examples:

  To add a new README file to the current module:
     revtool -a README

  To add all the C files in the current directory:
     revtool -a *.c

  To add a FAQ file and commit all changes to the module:
     revtool -ap FAQ

  To add a FAQ and commit only the new FAQ file:
     revtool -axp FAQ

  (Note:  The -r option works in the exact same way.)

  To add "Makefile.am," remove "Makefile" and "Makefile.in," and
  commit:
     revtool -p --add-list Makefile.am --rem-list "Makefile Makefile.in"

2.3.  Committing New Changes to the Master Server
-------------------------------------------------

Even though you may alter files on your local machine, no one else can
see your changes until you upload (a.k.a. "push" or "commit") them to
the master server.  This operation is called a "put" in revtool-
speak.  You must also realize that adding or removing files (as shown
above) must be accompanied by (or followed by) a "put" in order to
make the change permanent.

Part of your responsibility when making changes to the master
repository is documenting the changes you've made and why they were
made.  This is the purpose of a "change log" or a "commit log."  This
document is updated each time a put operation is performed.

When you perform a put, the editor of your choice (as determined by
the $EDITOR environment variable) is opened and contains a template
change log entry.  This template contains date/time stamp with your
userid (and name if available).  Go to the last line of this template
and type a description of the changes you're uploading.  Your
description should be brief but as accurate and complete as possible.
This message will be automatically appended to the ChangeLog file just
before revtool uploads your changes.

By default, the "-p" and "--put" options IGNORE any filenames that
might appear on the command line.  This is so that additions and
removals may be easily combined with puts ("-ap" or "-rp") that commit
the entire module, not just the added/removed files.  If you want a
particular put to only operate on the specified files, add the "-x" or
"--exclusive" option ("-xp").  Also note that puts should be done from
the top directory of the module to which you are making changes.

Examples:

  To upload your changes in the current module to the master server:
     revtool -p

  To commit only your changes to the README file:
     revtool -xp README

2.4.  Querying the Master Server
--------------------------------

Much information is stored on the master server and in local
CVS-maintained files which can be very helpful to the developer.
Thus, revtool supports several options for querying the master server
to obtain various handy bits of information.  All the query options
use the syntax "-qX", where X is one of the following:

	t		List tags
	s		Show status relative to master repository
	l		Display the change log
	a		Display annotated source
	d		Generate a diff
	D		Generate a repository diff

All query options except 'd' require that one or more files or
directories be specified on the command line, and those files will be
queried for the requested information.  You can also specify
files/directories for the diff query, but as long as the current
directory contains revision-controlled sources, it's not required.

Examples:

  To display a list of known tags on the README file:
     revtool -qt README

  To display the status of the FAQ file:
     revtool -qs FAQ

  To display the e.c file annotated with revision numbers:
     revtool -qa e.c

  To generate a diff between two tags on a directory:
     revtool -qd -t 'FOO-1-0 FOO-1-0-PATCH-1' foo-1.0


2.5.  Creating Modules for New Packages
---------------------------------------

The process of taking non-revision-controlled sources on your local
hard disk and creating revision-controlled modules from them is known
as "importing."  Proper procedure for importing new packages into the
repository will be discussed in the package maintainer's guide below.
This section simply gives the proper revtool syntax for creating the
new tree.

Imports are done using revtool's "-i" or "--import" options.  A tag
for the initial revision of each file (a.k.a. the "release tag") must
also be specified via the -t option.  The branch tag (the "vendor
tag") is derived from the module name.  The module name should be
specified on the command line; if it isn't, the name of the current
directory is used instead.

Note that some revision control systems, like CVS, ignore certain
types of files when importing foreign sources.  Symbolic links are a
noteable example, as are files whose names begin with '.'.  Although
symlinks are always ignored by CVS, you can request that no normal
files be ignored, regardless of their names.  Use the "-x" option for
this purpose.

Also note that the default keyword expansion mode requested by revtool
is "-ko" (keep original keywords).  If you wish to specify key/value
or binary expansion rules, be sure to specify "-kkv" or "-kb"
(respectively) when doing the import.

Examples:

  To import a new package "foo" version 2.0:
     revtool -it FOO-2-0 foo

  To import a new package, cow 4.2.8, without ignoring dotfiles:
     revtool -xit COW-4-2-8 cow

  To import a directory containing binary files:
     revtool -kb -xit SUSE-6-4 contrib-suse


2.6.  Tagging Sources
---------------------

For revision control systems like CVS which operate on the basis of
file-level revisions (as opposed to the changeset methodology of
Aegis, BitKeeper, ClearCase, etc.), one of the most important ways of
keeping track of intermediate changes is tagging.  Tagging is a
mechanism through which a symbolic name is given to a set of related
changes.  This is generally done immediately after a commit.  Use the
"-t" or "--tag" options to set tags based on the revisions of your
current local source files.  Use "-T" or "--rtag" to tag the
repository default branch directly.  (You won't do this very often.)
You must specify the module name(s) when doing an rtag.

The way tagging works can initially be hard to understand.  The most
important thing to realize is that tagging does NOT affect your local
source files.  It does not assign sticky tags.  What it does is this.
Each file you've obtained from the master server has a revision number
associated with it.  Tagging goes through each local source file,
finds its revision number, and specifies that the tag you've chosen
should correspond with that particular revision of that particular
file.  Use "revtool -qs" to examine the file revisions you have
checked out, the tags those files have, and the corresponding revision
numbers for those tags.

When tagging the repository (rtagging), rather than checking the
revisions of the files you've checked out, it simply picks the latest
revision of each file on the default branch; i.e., it works exactly as
if you checked out the module ("revtool -g module") and then tagged
the checkout ("revtool -t tag").

Examples:

  To tag the revisions of each file that you have checked out:
     revtool -t FOO-1-0

  To tag the default branch of the cow package:
     revtool -T COW-4-2-8 cow


3.  BUILDING PRODUCTS
---------------------

The most common task the average user will want to perform with this
system is to build products.  In corporate terms, a product is any
piece of work that actually ships to customers.  The build system, on
the other hand, defines a product as a collection of packages and
other products which form a coherent whole.  The program which manages
the process of building products, buildtool, has yet another
definition.  A product, according to buildtool, is anything that has a
.prod file in the products directory.  The .prod file describes a
product in terms of its components and how they fit together.

The average user, however, will not need to know how product files
work or what their contents mean.  All they'll need to know is what
product, and what version of that product, they wish to build.  In
general, it should be easy to look at the *.prod files in the products
directory and tell which one names the product you wish to build.  For
example, if you want to build the Web CD, try finding a product file
named "webcd" or "web-cd."  (The actual filename would end in ".prod,"
of course, but we'll ignore that part for the sake of discussion.)

If you can't find the product you're looking for, it may not be in the
build system yet.  Feel free to ask one of the build system
maintainers for assistance.

The purpose of buildtool is to provide a consistent interface to the
end user for building products while simultaneously simplifying the
management and organization of product development in a revision
controlled environment.  In other words, the end user shouldn't have
to care how the rpm command works or what the proper syntax is for
mkhybrid.  Likewise, the people who maintain the products and packages
behind the scenes should have a system which allows them to build
products in a flexible manner but still enforces good design and
proper change management.

To this end, the syntax for buildtool is designed to be very simple
for the average user to employ while still being sufficiently powerful
for the power user to get done what needs to be done as efficiently as
possible.  This section will discuss buildtool syntax, starting with
the basics and finishing with the more powerful stuff.  Casual users
may want to stop before getting to the complicated parts.

3.1.  Running a Simple Build
----------------------------

The simplest build you can do is one where everything is defined in a
product file and for which you only want to build package files.  If
you know the product and version you wish to build, it's as easy as:

buildtool -p product-1.0

Of course, you would replace "product" with the name and "1.0" with
the version of the product you wish to build.

Assuming buildtool is able to locate the appropriate product file, it
will begin the build by parsing that file.  Once it is finished
parsing, buildtool will know which packages are needed to create the
product you requested.  It will then proceed to build all the
packages, one by one, until all packages for that product have been
built.  It will then place the built packages into the appropriate
directories inside the CD image tree.

3.2.  Changing the Output
-------------------------

Running a build can generate a large amount of output as buildtool
keeps informing you of what it's doing.  This isn't always desireable,
so buildtool supports some options that allow you to change how much
detail buildtool gives you about its progress.  The "-q" option
activates "quiet" mode, in which only important messages and general
progress are shown.  The "-Q" option tells buildtool to use "silent"
mode; nothing but error messages will be displayed.

The "-d" option, on the other hand, requests that buildtool report
debugging information as it runs.  This produces extremely large
amounts of output but can be very helpful in determining how buildtool
works or investigating problems.

Sometimes it is desireable to direct the output from a build to a
particular file in addition to viewing it on the screen.  For this
purpose, buildtool provides the "-l" option, which specifies the
filename for a log file to receive output.

3.3.  Additional Options
------------------------

You already have enough knowledge to start building products.
However, buildtool supports some additional options you may find
useful.

By default, a failure in any single package will result in the
termination of buildtool.  This is because, excluding products under
development, builds should never fail.  However, developers doing test
builds will want to specify the "-f" option which will force buildtool
to continue until as much of the product as possible has been built.

For the larger products, build times can be extremely high.  To help
reduce the time required to build large products, buildtool allows the
build process to be parallelized using the "-P" option.  This will
cause the main buildtool to act like a master process which spawns
slave processes to build individual packages.  The number of
simultaneous slaves spawned is determined by the number of CPU's in
the build machine.

Finally, you can tell buildtool which stage to stop at by using the
"-b" option.  The build stages will be discussed in more detail in the
next section.  Commonly-used stopping points are the ISO image stage
("-bi"), the bootstrap stage ("-bs"), and of course the default
stopping point, the package accumulation stage ("-bp").  If you want
to go all the way through the cleanup stage, use "-ba".

3.4.  The Build Process in Detail
---------------------------------

The build process has 7 stages, and buildtool will let you stop at any
stage.  It also tries to avoid doing unnecessary work, so if it
detects that a particular stage has already been completed (it doesn't
care *who* completed it, as long as it seems to be done), it will not
perform any actions for that stage.

First is the bootstrap stage.  Several things can happen here if they
haven't already been done.  First off, $BASE_DIR/build is created if
it doesn't already exist, as are the BUILD, SOURCES, SRPMS, RPMS, and
SPECS subdirectories for building SRPM's.  ($BASE_DIR is the base
directory used for the build.  This is generally the "base" module
from CVS.)  Next, if no rpmrc or rpmmacros files exist in $BASE_DIR,
skeleton ones are created which point to the right places.  If those
files do exist, they are not created/modified.  The bootstrap stage
also takes care of checking out the necessary modules if they are not
already present.  For any file or module that does not exist,
buildtool executes revtool to obtain the appropriate source files from
the repository.

The next stage is the compose stage.  Nothing is done here for SRPM's,
because this is where SRPM's are built from the modules.  The details
of how to modules are constructed and how they are translated into
vendor sources and patches are discussed later in this document.  For
now, all you need to know is that the SRPM ends up in
$BASE_DIR/build/SRPMS/.

The explode stage takes all the SRPMS and does "rpm -U" on them to
"explode" them into their component tarballs, patches, and spec files
in the appropriate places that rpm expects them to be under
$BASE_DIR/build.

The build stage is where all the packages are rebuilt from their
exploded components into source and binary RPM's using "rpm -ba".

The package accumulation stage is where all the new source and binary
RPM's are copied into the image directories for the product being
built.  At this point, you have a completed product.

The compose, explode, build, and package accumulation stages are the
ones which are parallelized if the "-P" option is specified.  The
other stages are not able to be parallelized.

The ISO image stage builds ISO 9660 files (with RockRidge and Joliet
extensions, as well as optional El Torito boot images) of the image
directories created previously.

Finally, the cleanup stage removes all the intermediate build steps,
including all files pulled from the repository, all RPM directories
(BUILD, SOURCES, etc.), and so forth.


4.  PACKAGE MAINTAINER'S GUIDE
------------------------------

The previous sections went over general syntax and operation of the
build environment and the tools used to interact with it.  This
section will bring all those concepts together as it takes you through
the step-by-step maintenance of a sample package.

Let's say you decide to maintain this great new debugging suite called
Cow.  Version 4.2.8 of Cow has just been released to the public, and
you feel that it is ready to be included into a product.  So what do
you do?

4.1.  Adding a New Package
--------------------------

4.2.  Patches
-------------

4.3.  Additional Source Files
-----------------------------

4.4.  Creating a Product File
-----------------------------

4.5.  Finally, Build That Sucker
--------------------------------


5.  STANDARDS AND CONVENTIONS
-----------------------------

5.1.  Changing a Package
------------------------

Any packages that we obtain from an external source, and do NOT modify
in any way, can be placed directly into revision control in its native
package format.  However, if any changes whatsoever are made by you to
a package, and you intend for those changes to be incorporated into
the load, you must "own" that package.  You then "own" that package
going forward until such time as a package can be obtained externally
which no longer requires modification (i.e., somebody made a package
which includes your changes, either as a patch or in the vendor
source).

The owner of a package has the following responsibilities:

 - You must import the module properly.  If you make an error, you
   must request that the build server administrators remove the module
   you imported so that you can import it again, and you must redo the
   import from scratch.
 - You must make sure that the module builds correctly via the build
   system in any state in which you commit it to revision control.
   This only applies if a product file refers to the branch and/or tag
   under which you make the commit.
 - Changes made by others to the module are their responsibility, but
   you must make sure that the overall integrity of the module is
   preserved.
 - As the original package vendor releases new versions of the
   package, you are responsible for ultimately choosing whether or not
   to go with the new versions or stay with the old.  If you choose
   the former, you are also responsible for importing the new vendor
   source and merging the existing patches into the new branch.
 - Bugs will be filed by others in the company via Engineering
   SourceForge.  Any bugs filed against the package you own are
   ultimately your responsibility, although you may delegate them to
   others.
 - If you write a patch to fix a bug in the original vendor source,
   this patch should be submitted via appropriate channels to the
   original author(s).  Likewise, any problems you fix in the actual
   build process (e.g., the spec file) should be submitted to the
   original packager or package vendor (e.g., RedHat), in a more or
   less timely manner as approved by management. :-)
