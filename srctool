#!/usr/bin/perl -w
#
# srctool -- Tool for managing source packages and modules
# 
# Copyright (C) 2001, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: srctool,v 1.38 2004/03/01 03:10:04 mej Exp $
#

# Include the Perl Modules we need
require POSIX;
require Getopt::Long;
use Cwd ('&getcwd', '&abs_path');
use File::Copy ('&cp', '&mv');

# Mezzanine modules
use Mezzanine::Util;
use Mezzanine::RevCtl;
use Mezzanine::PkgVars;
use Mezzanine::RPM;
use Mezzanine::Src;
use Mezzanine::Pkg;

my $import_as_pdr = 0;

# Print usage information
sub
print_usage_info
{
    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   srctool [ options ] [ <pkg> ]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -i --import                      Import a new package/source tree\n";
    print "    -p --prepare                     Prepare a working tree\n";
    print "    -m --merge                       Merge one or more raw files into an SPM\n";
    print "    -a --apply --patch               Apply changes in the working tree as a patch to the SPM\n";
    print "    -c --clean                       Clean up a package tree\n";
    print "    -r --resync                      Prepare to sync the repository with the current sources\n";
    print "    -n --name <name>                 Specify the name of a package (-i) or patch (-a)\n";
    print "    -D --dir <repository>            Specify the repository to use\n";
    print "    -L --local                       Local mode; do not talk to the master server\n";
    print "    -f --flat --pdr                  Import as a PDR (all files in top dir) rather than an SPM\n";
    print "\n";
    exit(MEZZANINE_SUCCESS);
}

# Import a package
sub
import_package
{
    my ($pkgfile, $name, $err, $msg, $cmd, $pwd, $tmpdir, $rpmcmd, $pkg, $ver, $rel, $arch, $spec, $tag, $specdata);
    my (@contents, @srcs, @patches, @tmp);

    $pwd = &getcwd();
    $pkgfile = &pkgvar_filename();
    $name = &pkgvar_name();

    # Create a working tree to be imported
    if ($pkgfile && -f $pkgfile) {
        ($pkg, $ver, $rel, $arch) = &parse_rpm_name($pkgfile);
        if ($arch !~ /^(no)?src$/) {
            eprint "Invalid package for import:  $pkgfile\n";
            return MEZZANINE_INVALID_PACKAGE;
        }

        print "Importing $pkgfile into $pkg tree....\n\n";

        # Create temp space for importing.
        if ($import_as_pdr) {
            $tmpdir = &create_temp_space($pkg, "PDR");
            if (! $tmpdir) {
                return MEZZANINE_SYSTEM_ERROR;
            }
            &convert_srpm_to_pdr($pkgfile, $tmpdir);
        } else {
            $tmpdir = &create_temp_space($pkg, "SPM");
            if (! $tmpdir) {
                return MEZZANINE_SYSTEM_ERROR;
            }
            &convert_srpm_to_spm($pkgfile, $tmpdir);
        }

        $tag = "$pkg-$ver-$rel";
        if ($local_mode) {
            chdir($pwd);
            if (! &copy_tree($tmpdir, "$pwd/$pkg")) {
                eprint "Unable to move $tmpdir to $pwd/$pkg -- $!\n";
                &nuke_tree("$pwd/$pkg");
                return MEZZANINE_FILE_OP_FAILED;
            } else {
                &nuke_tree($tmpdir);
            }
            print "You requested local mode.  You will need to import the new tree by hand (mzimport $pkg).\n";
        } else {
            chdir($tmpdir);
            $tag =~ tr/a-z/A-Z/;
            $tag =~ s/\./_/g;
            &revctl_rtag($tag);
            &revctl_exclusive(1);
            $err = &import_vendor_sources();
            if ($err != MEZZANINE_SUCCESS) {
                eprint "Import of $pkgfile failed.\n";
                return $err;
            }
            chdir($pwd);
        }
	&clean_temp_space();
    } elsif (! $pkgfile || -d $pkgfile) {
	if (! $name || $name !~ /-/) {
	    if (-t STDIN) {
		my ($pname, $pver);

		print "Missing -n option.  Please supply the following information:\n";
		print "Package name:  ";
		chomp($pname = <STDIN>);
		while (! $pver) {
		    print "Package version:  ";
		    chomp($pver = <STDIN>);
		    if ($pver =~ /-/) {
			eprint "Package versions cannot contain hyphens.  Please try again.\n";
			undef $pver;
		    }
		}
		$name = "$pname-$pver";
		print "For future reference, you can specify this information on the command line like this:  -n $name\n";
	    } else {
		eprint "No package name/version supplied for FST import\n";
		return MEZZANINE_MISSING_INFO;
	    }
	}

        if ($local_mode) {
            print "You requested local mode.  You will need to import the new tree by hand (mzimport -n $name).\n";
        } else {
            chdir($pkgfile) if ($pkgfile);
            if (($err = &generate_symlink_file("")) != MEZZANINE_SUCCESS) {
                return $err;
            }
            ($tag = $name) =~ tr/a-z/A-Z/;
            $tag =~ s/\./_/g;
            &revctl_rtag($tag);
            &revctl_exclusive(1);
            $err = &import_vendor_sources();
            if ($err != MEZZANINE_SUCCESS) {
                eprint "Import of $pkgfile failed.\n";
                return $err;
            }
        }
        chdir($pwd);
    }
    return MEZZANINE_SUCCESS;
}

sub
prepare_tree($$)
{
    my ($pkg, $pwd, $pkgdir, $cmd, $err, $msg, $spec, $tmpdir, $params, $tmp);
    my (@srcs, @patches, @tmp);

    # cd into the package directory if one was specified.  If not, use the current directory.
    $pwd = &getcwd();
    if (&pkgvar_filename()) {
        $pkg = &pkgvar_filename();
        $pkgdir = &abs_path($pkg);
    } else {
        $pkgdir = $pwd;
        $pkg = &pkgvar_filename(&basename($pkgdir));
    }
    if (!chdir($pkgdir) && ($pkg ne &basename($pwd))) {
        eprint "Unable to cd to $pkgdir -- $!\n";
        return MEZZANINE_INVALID_PACKAGE;
    }

    # Create the working directory
    &nuke_tree($WORK_DIR);
    if (!&mkdirhier($WORK_DIR)) {
        eprint "Unable to create working directory -- $!\n";
        return MEZZANINE_SYSTEM_ERROR;
    }

    # Copy all the files into their proper places for RPM's use
    if (&pkgvar_type() eq "PDR") {
        $params = "--define '_topdir $pkgdir' --define '_builddir $pkgdir/$WORK_DIR' "
            . "--define '_sourcedir $pkgdir' --define '_specdir $pkgdir'";
        @tmp = &grepdir(sub { $_ =~ /\.spec(\.in)?$/ }, ".");
        if (scalar(@tmp) != 1) {
            eprintf("Found %d spec files:  \"%s\".\n", scalar(@tmp),
                    join("\", \"", @tmp));
            return MEZZANINE_INVALID_PACKAGE;
        }
        $spec = $tmp[0];
    } else {
        # Create the RPM build tree
        $tmpdir = &create_temp_space($pkg, "build");
        if (! $tmpdir) {
            return MEZZANINE_SYSTEM_ERROR;
        }
        $spec = &install_spm_files($tmpdir);
        $params = "--define \"_topdir $tmpdir\" --define \"_builddir $pkgdir/$WORK_DIR\"";
    }
    if (! $spec) {
        return MEZZANINE_INVALID_PACKAGE;
    }
    $params .= " --nodeps -bp $spec";
    print "Creating working directory $pkgdir/$WORK_DIR....\n";
    @tmp = &run_cmd("rpmbuild", $params, 0);
    if (($err = shift @tmp) != MEZZANINE_SUCCESS) {
        eprint "Creation of working directory failed -- $tmp[$#tmp]\n";
    } elsif ($command eq "prep") {
        print "You may now chdir to ", ($pkgdir eq $pwd ? $WORK_DIR : "$pkg/$WORK_DIR"), " to make changes.\n";
        print "Use \"mzpatch -n <patch_name>\" to generate a patch when done.\n";
    }

    &clean_temp_space();
    chdir($pwd);
    return $err;
}

sub
gen_patch($$)
{
    my ($pkg, $patch, $old_wd, $new_wd, $err, $line_cnt, $pwd, $patchdir);
    my @output;
    local *PATCH;

    $pkg = &pkgvar_filename();
    if ($pkg) {
        $pwd = &getcwd();
        if (!chdir($pkg)) {
            eprint "Unable to chdir to $pkg -- $!\n";
            return MEZZANINE_SYSTEM_ERROR;
        }
    } else {
        $pkg = &basename(&getcwd());
        &pkgvar_filename($pkg);
    }

    $patch = &pkgvar_name();
    if ($patch =~ /^\d+$/) {
        # Redo the spec file to comment out
        # the patch we're about to regenerate.
        if (! &pkgvar_instructions()) {
            my @tmp;

            if (&pkgvar_type() eq "PDR") {
                @tmp = &grepdir(sub {$_ =~ /\.spec(\.in)?$/}, ".");
            } else {
                @tmp = &grepdir(sub {$_ =~ /\.spec(\.in)?$/}, "F");
            }
            if (scalar(@tmp) != 1) {
                eprintf("Found %d spec files:  \"%s\".\n", scalar(@tmp),
                        join("\", \"", @tmp));
                return MEZZANINE_INVALID_PACKAGE;
            }
            &pkgvar_instructions($tmp[0]);
        }
        dprint "Disabling patch $patch to regenerate.\n";
        if (! &disable_patch($patch)) {
            eprint "Unable to disable patch $patch.\n";
            return MEZZANINE_FILE_OP_FAILED;
        }
    }

    $old_wd = $WORK_DIR;
    $new_wd = $old_wd . "+patched";

    # First, rename the old working directory
    if (-d $new_wd) {
        # Looks like it's already been renamed.
        wprint "Patched working tree $new_wd exists.  I'll assume it's the right one.\n";
        if (-d $old_wd) {
            &nuke_tree($old_wd);
        }
    } elsif (! &move_files($old_wd, $new_wd)) {
        eprint "Unable to move $old_wd to $new_wd -- $!\n";
        return MEZZANINE_SYSTEM_ERROR;
    }
    # Then create a new one using the routine above
    &pkgvar_filename("");
    if (($err = &prepare_tree()) != MEZZANINE_SUCCESS) {
        return $err;
    }

    # Re-enable the patch
    if ($patch =~ /^\d+$/) {
        my $specdata = &parse_spec_file();

        dprint "Re-enabling regenerated patch $patch ($specdata->{PATCH}{$patch}).\n";
        if (! &enable_patch($patch)) {
            eprint "Unable to re-enable patch $patch.\n";
            return MEZZANINE_FILE_OP_FAILED;
        }
        $patch = $specdata->{"PATCH"}{$patch};
    }

    # Now diff the two trees and save the output
    @output = &run_cmd("diff", "-Nur -x '*.orig' -x '*.rej' $old_wd $new_wd", 0);
    if (($err = shift @output) == 2) {
        foreach my $msg (grep(/^diff: /, @output)) {
            eprint "$msg\n";
        }
    }

    # If the patch directory doesn't exist, create it.
    if (!(-d "P") && (-d "F")) {
        my @tmp;

        $patchdir = "P/";
        if (! &mkdirhier("P")) {
            return MEZZANINE_SYSTEM_ERROR;
        }
        if ($local_mode) {
            print "You requested local mode.  You will need to add the patch directory by hand (mzadd P).\n";
        } else {
            $err = &add_new_files("P");
            if ($err != MEZZANINE_SUCCESS && $err != MEZZANINE_DUPLICATE) {
                eprint "Addition of directory P failed.\n";
                return $err;
            }
        }
    } elsif (-d "P") {
        $patchdir = "P/";
    } else {
        $patchdir = "";
    }

    # Finally, process the output to save the patch
    if (!open(PATCH, ">$patchdir$patch")) {
        eprint "Unable to open $patchdir$patch for writing -- $!\n";
        return MEZZANINE_SYSTEM_ERROR;
    }
    foreach my $line (@output) {
        next if ($line =~ /^diff: /);
        if ($line =~ /^(diff|---|\+\+\+|\*\*\*)/) {
            $line =~ s/$old_wd\///;
            $line =~ s/\Q$new_wd\E\//mezzanine_patched_/;
        }
        if ($line =~ /^[-I=Rrd\+\s@\*\\]/ || $line =~ /^$/) {
            print PATCH "$line\n";
            $line_cnt++;
        } else {
            dprint "Extra line in diff:  $line";
        }
    }
    close(PATCH);
    print "Created $patchdir$patch ($line_cnt lines).\n";

    # Add the new patch file
    if ($local_mode) {
        print "You requested local mode.  You will need to add the new patch by hand (mzadd P/$patch).\n";
    } else {
        $err = &add_new_files("P/$patch");
        if ($err != MEZZANINE_SUCCESS && $err != MEZZANINE_DUPLICATE) {
            eprint "Addition of directory P/$patch failed.\n";
            return $err;
        }
        print "Patch added and ready for commit.\n";
    }

    # Cleanup
    &nuke_tree($old_wd);
    &move_files($new_wd, $old_wd);
    chdir($pwd) if ($pwd);

    return MEZZANINE_SUCCESS;
}

sub
merge_file($$)
{
    my ($new_file) = shift;
    my ($pkg, $type, $dest, $pwd, $err);

    if ($new_file =~ /^([SPRF]):(.*)$/) {
        ($type, $new_file) = ($1, $2);
    } elsif ($new_file =~ /^(.*):([SPRF])$/) {
        ($type, $new_file) = ($2, $1);
    } elsif ($new_file =~ /\.(patch|diff)(\.gz|\.bz2|\.Z)?$/) {
        $type = 'P';
    } elsif ($new_file =~ /\.(cpio|tar|cgz|tgz)(\.gz|\.bz2|\.Z)?$/) {
        $type = 'S';
    } elsif ($new_file =~ /\.spec(\.in)?$/) {
        $type = 'F';
    } elsif ($new_file =~ /\.(no)?src\.rpm$/) {
        $type = 'R';
    } elsif ($new_file =~ /^\.mezz/) {
        $type = 'E';
    } else {
        if (-t STDIN) {
            print "Please specify whether $new_file is a Source file, Patch, spec File, or an Extra file ";
            for (; $type !~ /^[SPFE]$/; ) {
                print "[S/P/F/E]:  ";
                chomp($type = <STDIN>);
                $type =~ tr/a-z/A-Z/;
            }
        } else {
            eprint "Unable to guess the type of merge file $new_file.  You must specify it.\n";
            return MEZZANINE_BAD_ADDITION;
        }
    }

    $pkg = &pkgvar_filename();
    if ($pkg) {
        $pwd = &getcwd();
        if (!chdir($pkg)) {
            eprint "Unable to chdir into $pkg -- $!\n";
            return MEZZANINE_SYSTEM_ERROR;
        }
    } else {
        $pkg = &basename(&getcwd());
    }

    dprint "Merging $new_file ($type) into $pkg\n";
    if ($type eq 'R') {
        # Merge in new files from an SRPM.
        if ($import_as_pdr) {
            &convert_srpm_to_pdr($new_file, ".");
        } else {
            &convert_srpm_to_spm($new_file, ".");
        }
        print "You will need to run 'mzsync' next.\n";
    } else {
        my @output;

        # Copy the file into the appropriate directory
        if ($type eq 'E') {
            $dest = "";
        } else {
            $dest = "$type/";
            if (! -d $type && !&mkdirhier($type)) {
                eprint "Unable to create directory $type -- $!\n";
                return MEZZANINE_SYSTEM_ERROR;
            }
        }
        $dest .= &basename($new_file);
        if (! &cp($new_file, $dest)) {
            eprint "Unable to copy $new_file to $dest -- $!\n";
            return MEZZANINE_SYSTEM_ERROR;
        }

        # Add the file to be committed later.
        if ($local_mode) {
            print "You requested local mode.  You will need to add the new file(s) by hand (mzadd $dest).\n";
        } else {
            $err = &add_new_files($dest);
            if ($err != MEZZANINE_SUCCESS) {
                eprint "Addition of $new_file ($dest) failed.\n";
            } else {
                print "$new_file merged successfully.\n";
            }
        }
    }
    chdir($pwd) if ($pwd);
    return $err;
}

# Clean up a package tree
sub
clean_package
{
    my ($pkg, $pwd, $err);
    my @output;

    $pkg = &pkgvar_filename();
    if ($pkg) {
        $pwd = &getcwd();
        if (!chdir($pkg)) {
            eprint "Unable to chdir to $pkg -- $!\n";
            return MEZZANINE_SYSTEM_ERROR;
        }
    } else {
        $pkg = &basename(&getcwd());
    }

    if ($local_mode) {
        eprint "You requested local mode.  I will not be able to clean this module.\n";
        return MEZZANINE_SYNTAX_ERROR;
    }

    print "Cleaning and resyncing $pkg...\n";
    @output = &run_mz_cmd("revtool", &revctl_repository() . " -g", 0);
    if (($err = shift @output) != MEZZANINE_SUCCESS) {
        print @output;
        eprint "Unable to resync with repository.\n";
        return $err;
    }
    @output = grep(/^\?/, @output);
    if (scalar(@output)) {
        foreach my $item (@output) {
            $item =~ s/^\?\s+//;
            print "Removing $item...\n";
            &nuke_tree($item);
        }
    }

    print "Cleanup of $pkg complete.\n";
    chdir($pwd) if ($pwd);
    return MEZZANINE_SUCCESS;
}

# Get a tree back in sync with your checkout
sub
sync_package
{
    my ($pkg, $pwd, $err, $done);
    my (@output, @new, @old, @add, @rm);

    $pkg = &pkgvar_filename();
    if ($pkg) {
        $pwd = &getcwd();
        if (!chdir($pkg)) {
            eprint "Unable to chdir to $pkg -- $!\n";
            return MEZZANINE_SYSTEM_ERROR;
        }
    } else {
        $pkg = &basename(&getcwd());
    }

    if ($local_mode) {
        eprint "You requested local mode.  I will not be able to sync this module.\n";
        return MEZZANINE_SYNTAX_ERROR;
    }

    print "Syncing $pkg...\n";

    @output = &run_mz_cmd("revtool", &revctl_repository() . " -g", 0);
    if (($err = shift @output) != MEZZANINE_SUCCESS) {
        print @output;
        eprint "Unable to contact repository.\n";
        return $err;
    }
    foreach my $a (grep(/^\?\s/, @output)) {
        $a =~ s/^\?\s+//;
        push @add, $a;
    }
    push @new, @add;
    foreach my $r (grep(/^U\s/, @output)) {
        $r =~ s/^U\s+//;
        push @rm, $r;
    }
    push @old, @rm;
    for (; scalar(@add); ) {
        @output = &run_mz_cmd("revtool", &revctl_repository() . " -a " . join(" ", @add), 0);
        @add = ();
        foreach my $a (grep(/^\?\s/, @output)) {
            $a =~ s/^\?\s+//;
            push @add, $a;
        }
        push @new, @add;
    }
    if (scalar(@rm)) {
        @output = &run_mz_cmd("revtool", &revctl_repository() . " -r " . join(" ", @rm), 0);
    }

    if (!scalar(@new) && !scalar(@old)) {
        print "No additions or removals were needed.\n";
    } else {
        if (scalar(@new)) {
            print "Added files/directories:  ", join(" ", sort(@new)), "\n";
        }
        if (scalar(@old)) {
            print "Removed files/directories:  ", join(" ", sort(@old)), "\n";
        }
    }
    print "Sync of $pkg complete.  Your changes will not be finalized until you commit them.\n";
    chdir($pwd) if ($pwd);
    return MEZZANINE_SUCCESS;
}

# Move repository files around
sub
move_package_files
{
    my @flist = @_;
    my ($target, $err, $done);
    my (@output, @add, @rm);

    $target = pop(@flist);
    if ((scalar(@flist) > 1) && (! -d $target)) {
        mkdir $target, 0775;
        if (! $local_mode) {
            @output = &run_mz_cmd("revtool", &revctl_repository() . " -a $target", 0);
        }
    }

    if (&move_files(@flist, $target) != scalar(@flist)) {
        eprint "Error moving files.\n";
        return MEZZANINE_SYSTEM_ERROR;
    }

    if ($local_mode) {
        wprint "Files have been moved, but no contact was made with the respository.  Run \"mzsync\" when ready.\n";
        return MEZZANINE_SYNTAX_ERROR;
    }

    @rm = @flist;
    if (-d $target) {
        $target .= '/' if ($target !~ /\/$/);
        foreach my $f (@flist) {
            push @add, $target . &basename($f);
        }
    } else {
        push @add, $target;
    }

    @output = &run_mz_cmd("revtool", &revctl_repository() . " -r " . join(" ", @rm), 0);
    @output = &run_mz_cmd("revtool", &revctl_repository() . " -a " . join(" ", @add), 0);

    print "Removed files:  " . join(" ", @rm) . "\n";
    print "Added files:  " . join(" ", @add) . "\n";
    print "Move complete.  Your changes will not be finalized until you commit them.\n";
    return MEZZANINE_SUCCESS;
}

# main() here is basically the same as main() in C
sub
main
{
    # Set up the basic variables
    $progname = "srctool";
    $version = "2.1";
    umask 022;

    # See the Getopt::Long man page for details on the syntax of this line
    @valid_opts = ("h|help", "v|version", "d|debug", "i|import", "p|prepare",
                   "m|merge", "r|resync", "a|apply|patch", "move", "n|name=s",
                   "c|clean", "D|dir|repository=s", "L|local", "f|flat|pdr");
    Getopt::Long::Configure("no_getopt_compat", "bundling", "no_ignore_case");
    Getopt::Long::GetOptions(@valid_opts);

    # Post-parse the options stuff
    select STDOUT; $| = 1;
    if ($opt_v) {
        # Do not edit this variable.  It is updated automatically by CVS when you commit
        my $rcs_info = 'CVS Revision $Revision: 1.38 $ created on $Date: 2004/03/01 03:10:04 $ by $Author: mej $ ';

        $rcs_info =~ s/\$\s*Revision: (\S+) \$/$1/;
        $rcs_info =~ s/\$\s*Date: (\S+) (\S+) \$/$1 at $2/;
        $rcs_info =~ s/\$\s*Author: (\S+) \$ /$1/;
        print "\n";
	print "$progname $version by Michael Jennings <mej\@eterm.org>\n";
        print "Copyright (c) 2001, Michael Jennings\n";
        print "  ($rcs_info)\n";
        print "\n";
	return MEZZANINE_SUCCESS;
    } elsif ($opt_h) {
	&print_usage_info();   # Never returns
    }

    &debug_set($opt_d);
    &pkgvar_name($opt_n);
    if (scalar(@ARGV)) {
	@flist = @ARGV;
    }
    &revctl_repository($opt_D);
    if ($opt_L) {
        &revctl_command("/bin/true");
        $local_mode = 1;
    }

    # Signal handling
    $SIG{HUP} = 'IGNORE';
    $SIG{INT} = \&handle_signal;
    $SIG{TERM} = \&handle_signal;
    $SIG{QUIT} = \&handle_fatal_signal;
    $SIG{ILL} = \&handle_fatal_signal;
    $SIG{ABRT} = \&handle_fatal_signal;
    $SIG{FPE} = \&handle_fatal_signal;
    $SIG{SEGV} = \&handle_fatal_signal;
    $SIG{BUS} = \&handle_fatal_signal;
    $SIG{TSTP} = \&handle_fatal_signal;
    $SIG{TTIN} = \&handle_fatal_signal;
    $SIG{TTOU} = \&handle_fatal_signal;

    if ($0 =~ /mzimport$/ || $opt_i) {
        $command = "import";
        if ($opt_f) {
            $import_as_pdr = 1;
        }
	if (scalar(@flist)) {
	    foreach $f (@flist) {
		my $err;

                &pkgvar_filename($f);
		$err = &import_package();
		return $err if ($err);
	    }
	} else {
	    return &import_package();
	}
    } elsif ($0 =~ /mzprep$/ || $opt_p) {
        $command = "prep";
	if (scalar(@flist)) {
	    foreach $f (@flist) {
		my $err;

                &pkgvar_filename($f);
		$err = &prepare_tree();
		return $err if ($err);
	    }
	} else {
	    return &prepare_tree();
	}
    } elsif ($0 =~ /mzmerge$/ || $opt_M) {
        my $pkg;

        $command = "merge";
        if ($opt_f) {
            $import_as_pdr = 1;
        }
        foreach my $f (@flist) {
            if (-d $f) {
                $pkg = $f;
                last;
            }
        }
        if ($pkg) {
            @flist = grep($_ ne $pkg, @flist);
        } elsif (! -d "F") {
            eprint "No valid module specified.\n";
            return MEZZANINE_BAD_MODULE;
        } else {
            $pkg = "";
        }
        foreach my $f (@flist) {
            my $err;

            &pkgvar_filename($pkg);
            $err = &merge_file($f);
            return $err if ($err);
        }
    } elsif ($0 =~ /mzpatch$/ || $opt_a) {
        my ($pkg, $patch);

        $command = "patch";
        if (! $pkg) {
            $pkg = ".";
            &pkgvar_filename($pkg);
            if (! &pkgvar_type()) {
                eprint "No package was specified, and the current directory doesn't look like one.\n";
                return MEZZANINE_SYNTAX_ERROR;
            }
        }
        if (!($patch = &pkgvar_name())) {
            if (scalar(@flist) == 2) {
                if (-d $flist[0]) {
                    ($pkg, $patch) = @flist;
                } elsif (-d $flist[1]) {
                    ($patch, $pkg) = @flist;
                }
            } elsif (scalar(@flist) == 1) {
                if (-d $flist[0]) {
                    $pkg = $flist[0];
                } else {
                    $patch = $flist[0];
                }
            } else {
                eprint "No patch name was specified.\n";
                return MEZZANINE_SYNTAX_ERROR;
            }
        }
        &pkgvar_filename($pkg);
        &pkgvar_name($patch);
        return &gen_patch();
    } elsif ($0 =~ /mzclean$/ || $opt_c) {
        $command = "clean";
	if (scalar(@flist)) {
	    foreach $f (@flist) {
		my $err;

                &pkgvar_filename($f);
		$err = &clean_package();
		return $err if ($err);
	    }
	} else {
	    return &clean_package();
	}
    } elsif ($0 =~ /mz(re)?sync$/ || $opt_r) {
        $command = "sync";
	if (scalar(@flist)) {
	    foreach $f (@flist) {
		my $err;

                &pkgvar_filename($f);
		$err = &sync_package();
		return $err if ($err);
	    }
	} else {
	    return &sync_package();
	}
    } elsif ($0 =~ /mzmv$/ || $opt_move) {
        $command = "move";
	if (scalar(@flist) > 1) {
            $err = &move_package_files(@flist);
            return $err if ($err);
	} else {
            eprint "Two or more parameters required for move.\n";
            return MEZZANINE_SYNTAX_ERROR;
	}
    } else {
    }
    return MEZZANINE_SUCCESS;
}

exit &main();
