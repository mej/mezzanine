#!/usr/bin/perl -w
#
# srctool -- Tool for generating disk images, CD's, etc.
# 
# Copyright (C) 2001, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: srctool,v 1.6 2001/03/22 02:35:55 mej Exp $
#

# Include the Perl Modules we need
require POSIX;
require Getopt::Long;

# Constants
#
$WORK_DIR = "work";
$TMP_DIR = "/var/tmp/srctool.$$";

# Return codes for revtool
sub REVTOOL_NO_SERVER()           {1;}
sub REVTOOL_SERVER_CRASH()        {2;}
sub REVTOOL_BAD_LOGIN()           {3;}
sub REVTOOL_COMMAND_FAILED()      {4;}
sub REVTOOL_ACCESS_DENIED()       {5;}
sub REVTOOL_NO_SOURCES()          {6;}

sub REVTOOL_FILE_NOT_FOUND()      {21;}
sub REVTOOL_FILE_REMOVED()        {22;}
sub REVTOOL_CONFLICT_FOUND()      {23;}
sub REVTOOL_INVALID_TAG()         {24;}

sub REVTOOL_BAD_ADDITION()        {41;}
sub REVTOOL_BAD_REMOVAL()         {42;}

sub REVTOOL_NEED_UPDATE()         {61;}
sub REVTOOL_BAD_LOG_ENTRY()       {62;}

sub REVTOOL_UNSPECIFIED_ERROR()   {127;}


# Return codes for pkgtool
sub PKGTOOL_SUCCESS()           {0;}
sub PKGTOOL_FATAL_ERROR()       {1;}
sub PKGTOOL_SYNTAX_ERROR()      {2;}
sub PKGTOOL_COMMAND_FAILED()    {3;}

sub PKGTOOL_MISSING_FILES()     {10;}
sub PKGTOOL_SPEC_ERRORS()       {11;}
sub PKGTOOL_DEPENDENCIES()      {12;}
sub PKGTOOL_ARCH_MISMATCH()     {13;}
sub PKGTOOL_BUILD_FAILURE()     {14;}
sub PKGTOOL_BAD_MODULE()        {15;}

sub PKGTOOL_TERMINATED()        {50;}
sub PKGTOOL_CRASHED()           {60;}
sub PKGTOOL_UNSPECIFIED_ERROR   {127;}

# Return codes for srctool
sub SRCTOOL_SUCCESS()         {0;}
sub SRCTOOL_FATAL_ERROR()     {1;}
sub SRCTOOL_SYNTAX_ERROR()    {2;}
sub SRCTOOL_COMMAND_FAILED()  {3;}
                                
sub SRCTOOL_INVALID_PACKAGE() {10;}
sub SRCTOOL_FILE_OP_FAILED()  {11;}
sub SRCTOOL_MISSING_INFO()    {12;}
sub SRCTOOL_SYSTEM_ERROR()    {13;}

sub SRCTOOL_TERMINATED()      {50;}
sub SRCTOOL_CRASHED()         {60;}
sub SRCTOOL_UNSPECIFIED_ERROR {127;}

# Print usage information
sub
print_usage_info
{
    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   srctool [ options ]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -i --import                      Import a new package/source tree\n";
    print "    -p --prepare                     Prepare a working tree\n";
    print "    -n --name <pkg>-<version>        Specify the package name and version for an import\n";
    print "\n";
    exit(SRCTOOL_SUCCESS);
}

# Generate timestamp for debugging/log file
sub
get_timestamp
{
    return POSIX::strftime("%A, %d %B %Y %H:%M:%S %Z", localtime);
}

# Report a fatal error
sub
fatal_error
{
    my $msg = "$progname:  FATAL:  $_[0]";

    print STDERR $msg;
    exit(SRCTOOL_FATAL_ERROR);
}

# Debugging output
sub
dprintf
{
    return if (! $debug);
    print "[debug:$progname] ";
    printf @_;
}
sub
dprint
{
    my @dbg;
    my ($f, $l, $s);

    return if (! $debug);
    @dbg = caller(1);
    ($f, $l, $s) = @dbg[1, 2, 3];
    $f =~ s/^.*\/([^\/]+)$/$1/;
    print "[$f/$l/$s()] ", @_;
}

# Print an error
sub
eprintf
{
    print "$progname:  Error:  ";
    printf @_;
}
sub
eprint
{
    print "$progname:  Error:  ", @_;
}

# Handle a terminate signal
sub
handle_signal
{
    my $sig = $_[0];

    eprint "Someone sent me a SIG$sig asking me to exit, so I shall.\n";
    close($GLOBAL_LOG) if ($GLOBAL_LOG);
    exit SRCTOOL_TERMINATED;
}

# Handle a fatal signal
sub
handle_fatal_signal
{
    my $sig = $_[0];

    eprint "Caught fatal signal SIG$sig.  Cleaning up and aborting...\n";
    close($GLOBAL_LOG) if ($GLOBAL_LOG);
    exit SRCTOOL_CRASHED;
}

# Handle a perl warning
sub
handle_warning
{
    dprint @_;
}

# Make a directory hierarchy
sub
mkdirhier
{
    my $dir = $_[0];
    my @dirs = split("/", $dir);
    my $path = "";

    dprint "mkdirhier($dir) called.\n";
    foreach $dir (@dirs) {
        $path .= "$dir/";
        if (! -d $path) {
            dprint "mkdirhier() creating \"$path\"\n";
            mkdir($path, 0755) || eprint("Unable to create $path -- $!\n");
        }
    }
    if (! -d $_[0]) {
        dprint "Something went wrong in mkdirhier()!\n";
        return 0;
    } else {
        return 1;
    }
}

# Emulate rm -rf
sub
nuke_tree
{
    my $path = $_[0];
    my @files;
    local *DIR;

    if ((-d $path) && !(-l $path)) {
        opendir(DIR, $path) || return 0;
        @files = readdir(DIR);
        closedir(DIR);
        foreach $f (@files) {
            if ($f ne "." && $f ne "..") {
                &nuke_tree("$path/$f");
            }
        }
        dprint "Removing directory $path\n";
        rmdir $path || return 0;
    } else {
        dprint "Unlinking $path\n";
        unlink($path) || return 0;
    }
    return 1;
}

# Grep a directory for files matching a particular expression
sub grepdir(&$);
sub
grepdir(&$)
{
    my ($func, $dir) = @_;
    my @files;
    local *DIR;

    opendir(DIR, $dir) || return 0;
    @files = grep(&$func($_), readdir(DIR));
    closedir(DIR);
    return @files;
}

# Return the files in a particular directory
sub
find_files
{
    my $dir = $_[0];
    my @files;

    @files = &grepdir(sub {-f "$dir/$_" && $_ !~ /^\./}, $dir);
    foreach my $f (0..$#files) {
	$files[$f] = "$dir/$files[$f]";
    }
    return @files;
}

# Return the subdirectories in a particular directory
sub
find_subdirs
{
    my $dir = $_[0];
    my @subdirs;

    @subdirs = &grepdir(sub {-d "$dir/$_" && $_ !~ /^\./}, $dir);
    foreach my $f (0..$#subdirs) {
	$subdirs[$f] = "$dir/$subdirs[$f]";
    }
    return @subdirs;
}

# Create temporary working space in /var/tmp
sub
create_temp_space
{
    my ($pkg, $type) = @_;
    my ($dir, $d);
    my @dirlist;

    $dir = "$TMP_DIR/$pkg";
    &nuke_tree($dir);
    &mkdirhier($dir) || return "";
    if ($type eq "SPM") {
	@dirlist = ("S", "P", "F");
    } elsif ($type eq "build") {
	@dirlist = ("BUILD", "SOURCES", "SRPMS", "RPMS", "SPECS");
    }
    foreach $d (@dirlist) {
	if (!&mkdirhier("$dir/$d")) {
	    eprint "Creation of $dir/$d failed -- $!\n";
	    return "";
	}
    }
    return $dir;
}

# Clean up temp space
sub
clean_temp_space
{
    return &nuke_tree($TMP_DIR);
}

# Generic wrapper to grab command output
sub
run_cmd
{
    my ($prog, $params, $show_output) = @_;
    my ($err, $msg, $line, $cmd) = undef;
    my @output;
    local *CMD;

    $cmd = "$prog $params";

    dprint "About to run $cmd\n";
    if (!open(CMD, "$cmd 2>&1 |")) {
        return (-1, "Execution of \"$cmd\" failed -- $!");
    }
    while (<CMD>) {
        chomp($line = $_);
        push @output, $line;
        if ($show_output) {
            print "$show_output$line\n";
        } else {
            dprint "From $prog -> $line\n";
        }
    }
    close(CMD);
    $err = $? >> 8;
    dprint "\"$cmd\" returned $err\n";
    return ($err, @output);
}

# Wrapper for Avalon commands specifically
sub
run_av_cmd
{
    my ($prog, $params, $show_output) = @_;
    my ($err, $msg, $line, $cmd) = undef;
    my (@output, @tmp);

    $params = "--debug $params" if ($debug);
    @output = &run_cmd($prog, $params, $show_output);
    $err = shift @output;
    if ($err) {
        my @tmp;

        @tmp = grep(/^\w+:\s*error:\s*(\S.*)$/i, @output);
        if (scalar(@tmp)) {
            $msg = $tmp[$#tmp];
        }
    }
    return ($err, ($show_output ? $msg : @output));
}

# Import a package
sub
import_package
{
    my ($pkgfile, $name) = @_;
    my ($err, $msg, $cmd, $pwd, $tmpdir, $rpmcmd, $pkg, $ver, $rel, $spec, $tag);
    my (@contents, @srcs, @patches, @tmp);

    chomp($pwd = `/bin/pwd`);

    if ($pkgfile && -f $pkgfile) {
        # If it's a file, make sure it's an SRPM
        if ($pkgfile =~ /^(?:.*\/)?([^\/]+)-([^-]+)-([^-]+)\.(no)?src\.rpm$/) {
            ($pkg, $ver, $rel) = ($1, $2, $3);
        } else {
            eprint "Invalid package for import:  $pkgfile\n";
            return SRCTOOL_INVALID_PACKAGE;
        }
        print "Importing $pkgfile into $pkg tree....\n\n";
        # Create a working tree to be imported
        $tmpdir = &create_temp_space($pkg, "SPM");
	if (! $tmpdir) {
	    return SRCTOOL_SYSTEM_ERROR;
	}
        $rpmcmd = "rpm --define \"_sourcedir $tmpdir/S\" --define \"_specdir $tmpdir/F\"";
        # Install the SRPM into the temporary directory
        @tmp = &run_av_cmd("pkgtool", "-P '$rpmcmd' -ip $pkgfile", 0);
        if (($err = shift @tmp) != 0) {
            eprint "Unable to install $pkgfile\n";
            return SRCTOOL_COMMAND_FAILED;
        }
        # The spec file should be the only file in $tmpdir/F
        @tmp = &find_files("$tmpdir/F");
        if (scalar(@tmp) != 1) {
            my $n = scalar(@tmp);
            &fatal_error("$n spec files?!\n");
        }
        $spec = $tmp[0];
        # Get a list of all source and patch files
        @tmp = &run_av_cmd("pkgtool", "-P '$rpmcmd' -Cs $spec", 0);
        if (($err = shift @tmp) != 0) {
            eprint "Unable to catalog $pkgfile\n";
            return SRCTOOL_COMMAND_FAILED;
        }
        foreach my $line (@tmp) {
            my ($type, $num, $filename) = split(":", $line);

            if ($type eq "S") {
                push @srcs, $filename;
            } elsif ($type eq "P") {
                push @patches, $filename;
            }
        }
        # Move the patches to $tmpdir/P/
        foreach my $patch (@patches) {
            if (! -f "$tmpdir/S/$patch") {
                eprint "Missing patch file $patch?!\n";
                return SRCTOOL_FILE_OP_FAILED;
            } else {
                if (!link("$tmpdir/S/$patch", "$tmpdir/P/$patch") || !unlink("$tmpdir/S/$patch")) {
                    eprint "Unable to move $patch to $tmpdir/P/ -- $!\n";
                    return SRCTOOL_FILE_OP_FAILED;
                }
            }
        }
        chdir($tmpdir);
        $tag = "$pkg-$ver-$rel";
        $tag =~ tr/a-z/A-Z/;
        $tag =~ s/\./_/g;
        ($err, $msg) = &run_av_cmd("revtool", "-xit $tag", "  ");
        if ($err) {
            eprint "Import of $pkgfile failed -- $msg\n";
            return $err;
        }
        chdir($pwd);
	&clean_temp_space();
    } elsif (! $pkgfile || -d $pkgfile) {
	if (! $name || $name !~ /-/) {
	    if (-t STDIN) {
		my ($pname, $pver);

		print "Missing -n option.  Please supply the following information:\n";
		print "Package name:  ";
		$pname = <STDIN>;
		while (! $pver) {
		    print "Package version:  ";
		    $pver = <STDIN>;
		    if ($pver =~ /-/) {
			eprint "Package versions cannot contain hyphens.  Please try again.\n";
			undef $pver;
		    }
		}
		$name = "$pname-$pver";
		print "For future reference, you can specify this information on the command line like this:  -n $name\n";
	    } else {
		eprint "No package name/version supplied for FST import\n";
		return SRCTOOL_MISSING_INFO;
	    }
	}
	chdir($pkgfile) if ($pkgfile);
        ($tag = $name) =~ tr/a-z/A-Z/;
        $tag =~ s/\./_/g;
        ($err, $msg) = &run_av_cmd("revtool", "-xit $tag", "  ");
        if ($err) {
            eprint "Import of $pkgfile failed -- $msg\n";
            return $err;
        }
        chdir($pwd);
    }
    return SRCTOOL_SUCCESS;
}

sub
prepare_tree
{
    my $pkg = $_[0];
    my ($pwd, $pkgdir, $cmd, $err, $msg, $spec, $tmpdir, $rpmcmd, $tmp);
    my (@srcs, @patches, @tmp);

    chomp($pwd = `/bin/pwd`);

    # cd into the package directory if one was specified.  If not, use the current directory.
    if ($pkg) {
	if (!chdir($pkg)) {
	    eprint "Unable to cd to $pkg -- $!\n";
	    return SRCTOOL_INVALID_PACKAGE;
	}
	chomp($pkgdir = `/bin/pwd`);
    } else {
	($pkg = $pwd) =~ s/^.*\/([^\/]+)$/$1/;
	$pkgdir = $pwd;
    }
    # Create the working directory
    &nuke_tree($WORK_DIR);
    if (!mkdir($WORK_DIR)) {
        eprint "Unable to create working directory -- $!\n";
        return SRCTOOL_SYSTEM_ERROR;
    }
    # Find all the sources and patches and the spec file.
    @srcs = &find_files("S");
    @patches = &find_files("P");
    @tmp = &find_files("F");
    if (scalar(@tmp) != 1) {
	my $n = scalar(@tmp);
	&fatal_error("$n spec files?!\n");
    }
    $spec = $tmp[0];
    # Create the RPM build tree
    $tmpdir = &create_temp_space($pkg, "build");
    if (! $tmpdir) {
	return SRCTOOL_SYSTEM_ERROR;
    }
    # Copy all the files into their proper places for RPM's use
    foreach my $f (@srcs, @patches) {
        my $fname;

        ($fname = $f) =~ s/^.\///;
	if (!link($f, "$tmpdir/SOURCES/$fname")) {
	    eprint "Unable to copy $f into $tmpdir/SOURCES -- $!\n";
	    return SRCTOOL_SYSTEM_ERROR;
	}
    }
    ($tmp = $spec) =~ s/^.\///;
    if (!link($spec, "$tmpdir/SPECS/$tmp")) {
	eprint "Unable to copy $spec into $tmpdir/SPECS -- $!\n";
	return SRCTOOL_SYSTEM_ERROR;
    }
    print "Creating working directory $pkgdir/$WORK_DIR....\n";
    $rpmcmd = "--define \"_topdir $tmpdir\" --define \"_builddir $pkgdir/$WORK_DIR\" -bp $spec";
    @tmp = &run_cmd("rpm", $rpmcmd, 0);
    if (($err = shift @tmp) != 0) {
        eprint "Creation of working directory failed -- $tmp[$#tmp]\n";
    }
    return $err;
}

# main() here is basically the same as main() in C
sub
main
{
    # Set up the basic variables
    $progname = "srctool";
    $version = "1.0";

    # See the Getopt::Long man page for details on the syntax of this line
    @valid_opts = ("h|help", "v|version", "d|debug", "i|import", "p|prepare", "m|mod|modify",
                   "r|resync", "a|apply:s", "n|name=s");
    Getopt::Long::Configure("no_getopt_compat", "bundling", "no_ignore_case");
    Getopt::Long::GetOptions(@valid_opts);

    # Post-parse the options stuff
    select STDOUT; $| = 1;
    if ($opt_v) {
        # Do not edit this variable.  It is updated automatically by CVS when you commit
        my $rcs_info = 'CVS Revision $Revision: 1.6 $ created on $Date: 2001/03/22 02:35:55 $ by $Author: mej $ ';

        $rcs_info =~ s/\$\s*Revision: (\S+) \$/$1/;
        $rcs_info =~ s/\$\s*Date: (\S+) (\S+) \$/$1 at $2/;
        $rcs_info =~ s/\$\s*Author: (\S+) \$ /$1/;
        print "\n";
	print "$progname $version by Michael Jennings <mej\@eterm.org>\n";
        print "Copyright (c) 2001, Michael Jennings and VA Linux Systems, Inc.\n";
        print "  ($rcs_info)\n";
        print "\n";
	return SRCTOOL_SUCCESS;
    } elsif ($opt_h) {
	&print_usage_info();   # Never returns
        # This is a really silly way to shut up the "used only once" warnings.
        $opt_h = $opt_v = $opt_a = $opt_i = $opt_m = $opt_p = $opt_r = 0;
    }

    $debug = ($opt_d ? $opt_d : 0);
    $pkgname = ($opt_n ? $opt_n : "");
    if (scalar(@ARGV)) {
	@flist = @ARGV;
    }

    # Signal handling
    $SIG{HUP} = 'IGNORE';
    $SIG{INT} = \&handle_signal;
    $SIG{TERM} = \&handle_signal;
    $SIG{QUIT} = \&handle_fatal_signal;
    $SIG{ILL} = \&handle_fatal_signal;
    $SIG{ABRT} = \&handle_fatal_signal;
    $SIG{FPE} = \&handle_fatal_signal;
    $SIG{SEGV} = \&handle_fatal_signal;
    $SIG{BUS} = \&handle_fatal_signal;
    $SIG{TSTP} = \&handle_fatal_signal;
    $SIG{TTIN} = \&handle_fatal_signal;
    $SIG{TTOU} = \&handle_fatal_signal;
    $SIG{__WARN__} = \&handle_warning;

    if ($0 =~ /avimport$/ || $opt_i) {
	if (scalar(@flist)) {
	    foreach $f (@flist) {
		my $err;

		$err = &import_package($f, $pkgname);
		return $err if ($err);
	    }
	} else {
	    return &import_package("", $pkgname);
	}
    } elsif ($0 =~ /avprep$/ || $opt_p) {
	if (scalar(@flist)) {
	    foreach $f (@flist) {
		my $err;

		$err = &prepare_tree($f);
		return $err if ($err);
	    }
	} else {
	    return &prepare_tree("");
	}
    } elsif ($0 =~ /avmod$/ || $opt_m) {
    } elsif ($0 =~ /avpatch$/ || $opt_a) {
    } elsif ($opt_r) {
    } else {
    }
    return SRCTOOL_SUCCESS;
}

exit &main();
