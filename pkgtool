#!/usr/bin/perl -w
#
# pkgtool -- Tool for generating source/patch files from a source code repository
# 
# Copyright (C) 2000, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: pkgtool,v 1.39 2001/06/15 03:27:37 mej Exp $
#

# Include the Perl Modules we need
require POSIX;
require Getopt::Long;
use Cwd;
use Avalon::Util;
use Avalon::Pkgtool;

# Print usage information
sub
print_usage_info
{
    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   pkgtool [ options ]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -b --build                       Build a package\n";
    print "    -i --install                     Install (unarchive) a package\n";
    print "    -c --contents                    Check the contents of a package\n";
    print "    -q --query <type>                Query attributes of a package\n";
    print "    -o --sources [srcs]              Specify the sources to generate\n";
    print "    -p --package <file>              Specify the package filename\n";
    print "    -s --specfile --scripts <path>   Specify the spec file (or debian script directory) to use\n";
    print "    -m --module <name>               Specify the module name\n";
    print "    -r --release-tag <tag>           Operate on the revisions starting at <tag>\n";
    print "    -t --head-tag <tag>              Operate on the revisions up to and including <tag>\n";
    print "    -P --program <cmd>               Specify the package management program to be used\n";
    print "    -R --rcfile <rcfile>             Specify an alternate rpmrc file\n";
    print "    -D --dir <directory>             Specify \"directory\" as the full path to the module\n";
    print "       --root <dir>                  Specify the build/install root (depending on mode)\n";
    print "       --tar <tarcmd>                Use <tarcmd> as the \"tar\" command\n";
    print "       --zip <zipcmd>                Use <zipcmd> as the compression program\n";
    print "\n";
    exit(AVALON_SUCCESS);
}

sub
should_ignore
{
    my $fname = $_[0];

    # Ignore revision control goop
    return 1 if ($fname =~ /^(CVS|SCCS|RCS|BitKeeper)$/);
    # Ignore the revtool-generated ChangeLog
    return 1 if ($fname =~ /^[Cc]hanges?\.?[Ll]og$/);
    # Ignore dotfiles
    return 1 if ($fname =~ /^\./);
    # Ignore spec files
    return 1 if ($fname =~ /\.spec(\.in)?$/);
    # Ignore the debian/ directory
    return 1 if ($fname =~ /^debian$/ && -d $fname);

    return 0;
}

sub
get_tag_list
{
    my $tagfile = $_[0];
    my ($cmd, $line);
    my @tags;
    local *CMD;

    $cmd = "revtool -qt $tagfile";
    if (!open(CMD, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    while (<CMD>) {
        chomp($line = $_);
        if ($line =~ /^([-A-Z0-9]+) at (revision|branch) [.\d]+$/) {
            push @tags, $1;
            $tag_type{$1} = $2;
        } elsif ($line =~ /^No tags found/) {
            eprint "The sample tag file ($tagfile) contains no tags.\n";
            last;
        } else {
            eprint "Unexpected output from revtool:  $line\n";
        }
    }
    close(CMD);
    return (reverse @tags);
}

sub
fetch_package
{
    my $cmd = $_[0];
    my ($err, $msg, $line) = undef;
    local *REVTOOL;

    dprint "About to run $cmd\n";
    if (!open(REVTOOL, "$cmd 2>&1 |")) {
        $err = AVALON_COMMAND_FAILED;
        $msg = "Execution of \"$cmd\" failed -- $!";
        last;
    }
    while (<REVTOOL>) {
        chomp($line = $_);
        dprint "From revtool -> $line\n";
        next if ($line =~ /^\[debug:/);
        # Check the output for errors
        if ($line =~ /^revtool:\s*Error/) {
            ($msg = $line) =~ s/^revtool:\s*Error:\s*//;
        }
    }
    close(REVTOOL);
    $err = $?;
    dprintf "\"$cmd\" returned $err (%d)\n", $err >> 8;
    return ($err >> 8, $msg);
}

sub
update_to_tag
{
    my ($tag, $src_files) = @_;
    my ($err, $msg, $cmd, $line) = undef;
    my (@new_files);
    local *REVTOOL;

    $tag = ($tag ? "-t $tag" : "--reset");
    $cmd = "revtool -g $tag" . ($src_files ? " $src_files" : "");
    dprint "About to run $cmd\n";
    if (!open(REVTOOL, "$cmd 2>&1 |")) {
        $err = AVALON_COMMAND_FAILED;
        $msg = "Execution of \"$cmd\" failed -- $!";
        last;
    }
    while (<REVTOOL>) {
        chomp($line = $_);
        dprint "From revtool -> $line\n";
        next if ($line =~ /^\[debug:/);
        # Check the output for errors
        if ($line =~ /^U (\S+)$/) {
            push @new_files, $1;
        } elsif ($line =~ /is not a valid tag/) {
            eprint "$tag does not seem to be valid for this package.\n";
            last;
        } elsif ($line =~ /^revtool:\s*Error/) {
            ($msg = $line) =~ s/^revtool:\s*Error:\s*//;
            eprint "$msg\n";
        }
    }
    close(REVTOOL);
    $err = $?;
    dprintf "Command returned $err (%d)\n", $err >> 8;
    return @new_files;
}

sub
check_for_source_files
{
    my ($src_files, $tarball, $destdir) = @_;

    if ($tarball) {
        # Check to see if the tarball exists
        if (-f "$destdir/$tarball" && -s _) {
            return 1;
        } else {
            return 0;
        }
    } else {
        foreach $src (split(" ", $src_files)) {
            if ((! -f "$destdir/$src") || (! -s _)) {
                return 0;
            }
        }
        return 1;
    }
}

sub
create_source_file
{
    my ($src_files, $tarball, $destdir, $tar, $zip) = @_;
    my $cmd;
    local *CMD;

    dprint "Source files:  \"$src_files\"\n";
    if ($tarball) {
        print "Generating $tarball...\n";
        if ($tar) {
            $cmd = $tar;
            $cmd =~ s/\%f/$src_files/;
            $cmd =~ s/\%t/$destdir$tarball/;
        } else {
            if (! $zip) {
                if ($tarball =~ /(gz|Z)$/) {
                    $zip = "gzip";
                } elsif ($tarball =~ /\.bz2$/) {
                    $zip = "bzip2";
                }
            }
            if ($zip) {
                $zip = " --use-compress-program=$zip";
            } else {
                $zip = " ";
            }
            $cmd = "tar --exclude CVS --exclude RCS --exclude BitKeeper --exclude SCCS"
                   . "$zip -cf ${destdir}$tarball $src_files";
        }
        dprint "Creating $tarball:  $cmd\n";
        unlink($tarball);
        if (!open(CMD, "$cmd 2>&1 |")) {
            eprint "Execution of \"$cmd\" failed -- $!\n";
            return AVALON_COMMAND_FAILED;
        }
        while (<CMD>) {
            chomp($line = $_);
            print "tar output -> $line\n";
        }
        close(CMD);
        dprint "Command returned $?\n";
        if ($?) {
            eprint "Creation of vendor source tarball $tarball failed\n";
            return AVALON_BUILD_FAILURE;
        }
    } else {
        my $rc;

        print "Copying $src_files to $destdir.\n";
        $rc = system("cp -f $src_files $destdir") >> 8;
        if ($rc) {
            eprint "Unable to copy $src_files to $destdir -- $!\n";
            return AVALON_BUILD_FAILURE;
        }
    }
    return AVALON_SUCCESS;
}

sub
gen_diff
{
    my ($module, $src_files, $prev_tag, $tag, $patch) = @_;
    my ($cmd, $line_cnt, $ignore, $fname);
    my @src_files;
    local (*CMD, *PATCH);

    @src_files = split(" ", $src_files);
    if (!open(PATCH, ">$patch")) {
        eprint "Unable to write to patch file $patch -- $!\n";
        return AVALON_BUILD_FAILURE;
    }
    $cmd = "revtool -qD -t '$prev_tag $tag' $module";
    dprint "About to run \"$cmd\"\n";
    if (!open(CMD, "$cmd 2>/dev/null |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
        return AVALON_COMMAND_FAILED;
    }
    $line_cnt = $ignore = 0;
    while (<CMD>) {
        chomp($line = $_);
        next if ($line =~ /^revtool/);
        if ($line =~ /^Index: (\S+)$/) {
            my @tmp;

            ($fname = $1) =~ s/^\Q$module\E\///;
            @tmp = grep(($fname eq $_) || ($fname =~ /^\Q$_\E\//), @src_files);
            if ($#tmp < 0) {
                # Not a source file.  Ignore it.
                dprint "Ignoring patch to $fname\n";
                $ignore = 1;
            } else {
                # A source file.  Include it.
                dprint "Now diffing $fname\n";
                $ignore = 0;
            }
            next;
        } elsif ($line =~ /^(diff|---|\+\+\+|\*\*\*)/) {
            $line =~ s/\Q$module\/$fname\E\b/$fname/g;
        }
        next if ($ignore);

        if ($line =~ /^[-I=Rrd+\s@\*\\]/) {
            print PATCH "$line\n";
            $line_cnt++;
        } else {
            dprint "Extra line in diff:  $line\n";
        }
    }
    close(CMD);
    close(PATCH);
    print "Generated $patch ($line_cnt lines).\n";
    dprint "\"$cmd\" returned $?\n";
    return AVALON_SUCCESS;
}

sub
touch_file
{
    my $file = $_[0];
    local *TMP;

    open(TMP, ">$file") && close(TMP);
}

sub
rpm_install
{
    my $pkg_file = $_[0];
    my ($rpm, $cmd, $rc, $err, $msg);
    my (@failed_deps);
    local *RPM;

    $rpm = ($pkg_prog ? $pkg_prog : "rpm");
    $rc = ($rcfile ? "--rcfile '/usr/lib/rpm/rpmrc:$rcfile'" : "");
    $cmd = "$rpm $rc" . ($rootdir ? " --root $rootdir " : " ") . "-U $pkg_file";
    dprint "About to run \"$cmd\"\n";
    if (!open(RPM, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    $err = AVALON_SUCCESS;
    while (<RPM>) {
        chomp($line = $_);
        print "$line\n";
        if ($line =~ /^error: failed build dependencies:/) {
            $err = AVALON_DEPENDENCIES;
            while (<RPM>) {
                chomp($line = $_);
                last if ($line !~ /is needed by/);
                $line =~ s/^\s+(\S+)\s+is needed by .*$/$1/;
                push @failed_deps, $line;
            }
            $msg = sprintf("Installing this package requires the following:  %s", join(" ", @failed_deps));
            last;
        } elsif ($line =~ /^Architecture is not included:/) {
            $err = AVALON_ARCH_MISMATCH;
            $line =~ s/^Architecture is not included:\s+//;
            $msg = "This package does not install on the $line architecture";
        }
    }
    close(RPM);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0 && $err == AVALON_SUCCESS) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    if ($err == AVALON_SUCCESS) {
        print "$pkg_file successfully installed.\n";
    } else {
        eprint "$msg\n";
    }
    return $err;
}

sub
deb_install
{
    my $pkg_file = $_[0];
    my ($dpkg, $cmd);
    my @inp;
    local *DPKG;

    $dpkg = ($pkg_prog ? $pkg_prog : "dpkg");
    $cmd = "$dpkg -x $pkg_file";
    dprint "About to run \"$cmd\"\n";
    if (!open(DPKG, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    while (<DPKG>) {
        print;
    }
    close(DPKG);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    print "$pkg_file successfully installed.\n";
    return AVALON_SUCCESS;
}

sub
tar_install
{
    my $pkg_file = $_[0];
    my ($tar, $dir, $cmd, $err, $msg);
    my (@failed_deps);
    local *TAR;

    $dir = ($rootdir ? $rootdir : "/");
    $tar = ($pkg_prog ? $pkg_prog : "tar -C $dir");
    if ($pkg_file =~ /\.(t?gz|Z)$/) {
        $tar .= " --use-compress-program=gzip";
    } elsif ($pkg_file =~ /\.bz2$/) {
        $tar .= " --use-compress-program=bzip2";
    }
    $cmd = "$tar -xvf $pkg_file";
    dprint "About to run \"$cmd\"\n";
    if (!open(TAR, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    $err = AVALON_SUCCESS;
    while (<TAR>) {
        chomp($line = $_);
        if ($line =~ /^tar: /) {
            eprint "$line\n";
        } else {
            dprint "   $line\n";
        }
    }
    close(TAR);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0 && $err == AVALON_SUCCESS) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    if ($err == AVALON_SUCCESS) {
        print "$pkg_file successfully installed.\n";
    } else {
        eprint "$pkg_file installation failed.\n";
    }
    return $err;
}

sub
rpm_show_contents
{
    my $pkg_file = $_[0];
    my ($rpm, $cmd, $rc);
    local *RPM;

    $rpm = ($pkg_prog ? $pkg_prog : "rpm");
    $rc = ($rcfile ? "--rcfile '/usr/lib/rpm/rpmrc:$rcfile'" : "");
    $cmd = "$rpm $rc -ql " . ($pkg_file ? "-p $pkg_file" : "");
    dprint "About to run \"$cmd\"\n";
    if (!open(RPM, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    while (<RPM>) {
        print;
    }
    close(RPM);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    return AVALON_SUCCESS;
}

sub
deb_show_contents
{
    my $pkg_file = $_[0];
    my ($dpkg, $cmd, $line);
    local *DPKG;

    $dpkg = ($pkg_prog ? $pkg_prog : "dpkg");
    $cmd = "$dpkg -c " . ($pkg_file ? "$pkg_file" : "");
    dprint "About to run \"$cmd\"\n";
    if (!open(DPKG, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    while (<DPKG>) {
        chomp;
        ($line = $_) =~ s/^.* \.(\/.*)$/$1/;
        print "$line\n";
    }
    close(DPKG);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    return AVALON_SUCCESS;
}

sub
tar_show_contents
{
    my $pkg_file = $_[0];
    my ($tar, $cmd);
    local *TAR;

    $tar = ($pkg_prog ? $pkg_prog : "tar");
    if ($pkg_file =~ /\.(t?gz|Z)$/) {
        $tar .= " --use-compress-program=gzip";
    } elsif ($pkg_file =~ /\.bz2$/) {
        $tar .= " --use-compress-program=bzip2";
    }
    $cmd = "$tar -tvf $pkg_file";
    dprint "About to run \"$cmd\"\n";
    if (!open(TAR, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    while (<TAR>) {
        print;
    }
    close(TAR);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    return AVALON_SUCCESS;
}

sub
rpm_query
{
    my ($pkg_file, $query_type) = @_;
    my ($rpm, $rpm_opt, $cmd, $rc, $line);
    my (@prov, @deps);
    local *RPM;

    if ($query_type eq "d") {
        $rpm_opt = "-q --qf '[Contains:  %{FILENAMES}\n][Provides:  %{PROVIDES}\n][Requires:  %{REQUIRENAME} %{REQUIREFLAGS:depflags} %{REQUIREVERSION}\n]'";
    } elsif ($query_type eq "s") {
        $rpm_opt = "-q --qf 'Source:  %{SOURCERPM}\n'";
    } else {
        eprint "Unrecognized query type \"$query_type\"\n";
        return AVALON_SYNTAX_ERROR;
    }
    $rpm = ($pkg_prog ? $pkg_prog : "rpm");
    $rc = ($rcfile ? "--rcfile '/usr/lib/rpm/rpmrc:$rcfile'" : "");
    $cmd = "$rpm $rc $rpm_opt " . ($pkg_file ? "-p $pkg_file" : "-a");
    dprint "About to run \"$cmd\"\n";
    if (!open(RPM, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    while (<RPM>) {
        print;
    }
    close(RPM);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    return AVALON_SUCCESS;
}

sub
deb_query
{
    my ($pkg_file, $query_type) = @_;
    my ($dpkg, $cmd, $line);
    my (@prov, @deps);
    local *DPKG;

    if ($query_type eq "d") {
    } else {
        eprint "Unrecognized query type \"$query_type\"\n";
        return AVALON_SYNTAX_ERROR;
    }
    $dpkg = ($pkg_prog ? $pkg_prog : "dpkg");
    $cmd = "$dpkg -I " . ($pkg_file ? "$pkg_file" : "");
    dprint "About to run \"$cmd\"\n";
    if (!open(DPKG, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    while (<DPKG>) {
        chomp($line = $_);
        if ($query_type eq "d") {
            if ($line =~ /^\s*Provides:\s+(.*)$/) {
                ($line = $1) =~ s/[\(\)]//g;
                push @prov, split(/\s*,\s*/, $line);
            } elsif ($line =~ /^\s*Depends:\s+(.*)$/) {
                ($line = $1) =~ s/[\(\)]//g;
                push @deps, split(/\s*,\s*/, $line);
            }
        }
    }
    close(DPKG);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    foreach $prov (@prov) {
        print "Capability:  $prov\n";
    }
    foreach $dep (@deps) {
        print "Dependency:  $dep\n";
    }   
    return AVALON_SUCCESS;
}

sub
tar_query
{
    eprint "Tar packages cannot be queried.\n";
    return AVALON_COMMAND_INVALID;
}

sub
rpm_build
{
    my ($cmd, $rpm, $line);
    my ($err, $msg) = (0, 0);
    my (@failed_deps, @not_found, @spec_errors, @out_files);
    local *RPM;

    $rpm = ($pkg_prog ? $pkg_prog : "rpm") . ($rcfile ? " --rcfile '/usr/lib/rpm/rpmrc:$rcfile'" : "");
    if ($rootdir) {
        $rpm .= " --buildroot=\"$rootdir\"";
    }
    if ($_[0] =~ /src\.rpm$/) {
        $cmd = "$rpm" . ($rcfile ? " --rcfile \"$rcfile\"" : "") . " --rebuild $_[0]";
    } elsif ($_[0] =~ /\.(t?gz|Z|bz2)$/) {
        $cmd = "$rpm" . ($rcfile ? " --rcfile \"$rcfile\"" : "") . " -ta $_[0]";
    } else {
        $cmd = "$rpm" . ($rcfile ? " --rcfile \"$rcfile\"" : "") . " -ba $_[0]";
    }
    dprint "About to run \"$cmd\"\n";
    if (!open(RPM, "$cmd </dev/null 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
        return AVALON_COMMAND_FAILED;
    }
    $err = AVALON_SUCCESS;
    while (<RPM>) {
        chomp($line = $_);
        print "$line\n";
        if ($line =~ /^Wrote:\s+(\S+\.\w+\.rpm)$/) {
            push @out_files, $1;
        } elsif ($line =~ /^line \d+: [^:]+: /
                 || $line =~ /^Failed to find \w+:/
                 || $line =~ /^Symlink points to BuildRoot: /) {
            $err = AVALON_SPEC_ERRORS;
            push @spec_errors, $line;
        } elsif ($line =~ /^Bad exit status from/) {
            $err = AVALON_BUILD_FAILURE;
            $line =~ s/^Bad exit status from \S+ \((%\w+)\)/$1/;
            $msg = "The RPM $line stage exited abnormally";
        } elsif ($line =~ /^error: failed build dependencies:/) {
            $err = AVALON_DEPENDENCIES;
            while (<RPM>) {
                chomp($line = $_);
                last if ($line !~ /is needed by/);
                $line =~ s/^\s+(\S+)\s+is needed by .*$/$1/;
                push @failed_deps, $line;
            }
            $msg = sprintf("Building this package requires the following:  %s", join(" ", @failed_deps));
            last;
        } elsif ($line =~ /^Architecture is not included:/) {
            $err = AVALON_ARCH_MISMATCH;
            $line =~ s/^Architecture is not included:\s+//;
            $msg = "This package does not build on the $line architecture";
        } elsif ($line =~ /^File (.*): No such file or directory$/
                 || $line =~ /^Bad file: (.*): No such file or directory$/
                 || $line =~ /^File is not a regular file: (.*)$/
                 || $line =~ /^Unable to open icon (\S+):$/
                 || $line =~ /^No (patch number \d+)$/
                 || $line =~ /^Could not open \%files file (\S+): No such file or directory$/
                 || $line =~ /^File not found(?: by glob)?: (.*)$/) {
            $err = AVALON_MISSING_FILES;
            push @not_found, $1;
        }
    }
    close(RPM);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0 && $err == AVALON_SUCCESS) {
        $err = AVALON_UNSPECIFIED_ERROR;
        $msg = "Unhandled package build error";
    } elsif ($#not_found != -1) {
        $msg = sprintf("The following were expected by the build, but no matching files were found:  \"%s\"",
                       join("\", \"", @not_found));
    } elsif ($#spec_errors != -1) {
        $msg = sprintf("The spec file contains the following errors:  \"%s\"", join("\", \"", @spec_errors));
    }

    if ($msg) {
        eprint "$msg\n";
    }
    if ($#out_files >= 0) {
        print "Package files generated:  ", join(" ", @out_files), "\n";
    }
    return $err;
}

sub
deb_build
{

}

sub
rpm_generate_source_files
{
    my ($specfile, $module, $srcs, $head_tag, $release_tag) = @_;
    my ($err, $msg, $src_files, $tarball, $modname, $tag_prefix, $prev_tag);
    my (@contents, @tags, @srcs, @all_srcs);
    local (*DIR, *CMD);

    if ($module && (!chdir($module))) {
        return AVALON_BAD_MODULE;
    }
    if (-f "CVS/Repository") {
        chomp($modname = &cat_file("CVS/Repository"));
    } elsif ($module) {
        ($modname = $module) =~ s/^.*\/([^\/]+)$/$1/;
    } else {
        $modname = &basename(&getcwd());
    }
    if ($destdir && $destdir !~ /\/$/) {
        $destdir .= "/";
    }
    opendir(DIR, ".");
    @contents = readdir(DIR);
    closedir(DIR);

    &parse_spec_file($specfile) if ($specfile);

    if (! $release_tag) {
        ($release_tag = "$specdata->{DEFINES}{PACKAGE_NAME}-$specdata->{DEFINES}{PACKAGE_VERSION}") =~ tr/[a-z]/[A-Z]/;
        $release_tag =~ s/[^-A-Z0-9]/-/g;
    }
    $tag_prefix = $release_tag;

    if ($srcs) {
        @srcs = split(/[\s,]/, $srcs);
    } elsif (-s "avalon.srcs") {
        @srcs = &parse_srcs_file("avalon.srcs");
    } else {
        my $fname;

        wprint "No SRCS variable found.  Proceeding with default assumptions.  If the assumptions don't work,\n";
        wprint "you will need to create an avalon.srcs file for this package.\n";

        foreach $fname (@contents) {
            next if (&should_ignore($fname));
            if (-d $fname) {
                my @tmp;

                @tmp = grep($_ =~ /^\Q$fname\E\.(tgz|tar\.gz|tar\.Z|tar\.bz2|tbz)$/, values %{$specdata->{SOURCE}});
                if (scalar(@tmp)) {
                    push @srcs, "$fname:$tmp[0]";
                } else {
                    push @srcs, "$fname:$fname.tar.gz";
                }
            } else {
                push @srcs, $fname;
            }
        }
    }

    dprint "Preparing to generate sources \"", join(" ", @srcs), "\".\n";
    dprint "Sources:  ", join(", ", @{$specdata->{SOURCES}}), "\n";
    dprint "Patches:  ", join(", ", @{$specdata->{PATCHES}}), "\n";

    if (scalar(@{$specdata->{PATCHES}})) {
        @tags = grep($tag_type{$_} eq "revision", &get_tag_list($tagfile));
        if ($release_tag || $head_tag) {
            my @real_tags;
            my $keep = ($release_tag ? 0 : 1);

            foreach $tag (@tags) {
                if ($tag eq $release_tag) {
                    $keep = 1;
                } elsif ($tag eq $head_tag) {
                    $keep = 0;
                }
                push @real_tags, $tag if ($keep);
            }
            @tags = @real_tags;
        }
        dprint "Real Tags:  ", join(" ", @tags), "\n";
        for ($i = 1; $i <= $#tags; $i++) {
            if ($tags[$i] =~ /^$tag_prefix-PATCH-(\d+)$/) {
                my $num = $1;

                if (!defined($specdata->{PATCH}{$num})) {
                    print "$progname:  Warning:  Patch $num exists as a tag but is not referenced in the spec file.\n";
                    next;
                }
                $last_tag{$specdata->{PATCH}{$num}} = $tags[$i - 1];
                dprint "Previous tag for patch $num ($specdata->{PATCH}{$num}) is $last_tag{$specdata->{PATCH}{$num}}\n";
            } elsif ($tags[$i] =~ /^$tag_prefix-SOURCE-(\d+)$/) {
                my $num = $1;

                if (!defined($specdata->{SOURCE}{$num})) {
                    print "$progname:  Warning:  Source $num exists as a tag but is not referenced in the spec file.\n";
                    next;
                }
                $last_tag{$specdata->{SOURCE}{$num}} = $tags[$i - 1];
                dprint "Previous tag for source $num ($specdata->{SOURCE}{$num}) is $last_tag{$specdata->{SOURCE}{$num}}\n";
            } elsif ($tags[$i] =~ /^(.*)-(SOURCE|PATCH)-\d+$/) {
                my $tmp = $1;
                my @tmp;

                # It's trying to be a valid tag.  Maybe we can help it along.
                @tmp = grep($_ =~ /^$tmp/, @tags);
                if ($#tmp > ($#tags / 2)) {
                    # More than half of the tags start with this.  Somebody screwed up.  Let's help.
                    $tag_prefix = $tmp;
                    print "$progname:  Warning:  Incorrect tag prefix detected.  Using $tag_prefix instead of $release_tag.\n";
                    $i = 0;
                }
            }                
        }
        #($err, $msg) = &fetch_package("revtool -gt $release_tag $modname");
        #if ($err) {
        #    eprint "Unable to obtain $modname using release tag $release_tag -- $msg\n";
        #    return AVALON_BAD_MODULE;
        #}
        #chdir($modname);

        #opendir(DIR, ".");
        #@contents = readdir(DIR);
        #closedir(DIR);

        # Generate all the source files that already exist
        dprint "Beginning initial source file generation....\n";
        &update_to_tag($release_tag) if ($release_tag);
        foreach $src (@srcs) {
            my @tmp;
            my $i;

            ($src_files, $tarball) = split(":", $src);
            @tmp = split(/[\&\s]+/, $src_files);
            if ($tarball) {
                dprint "\"$src_files\", \"$tarball\", (", join('|', @tmp), ")\n";
            } else {
                dprint "\"$src_files\", (", join('|', @tmp), ")\n";
            }
            for ($i = 0; $i < scalar(@tmp); ) {
                my @matches = grep(-e $_, glob($tmp[$i]));

                splice(@tmp, $i, 1, @matches);
                $i += scalar(@matches);
            }
            @all_srcs = (@all_srcs, @tmp);
            #@tmp = grep(-e $_, @tmp);
            next if ($#tmp < 0);
            dprint "\@tmp contains ", scalar(@tmp), " elements:  ", join(" ", @tmp), "\n";
            $src_files = join(" ", @tmp);
            if (&check_for_source_files($src_files, $tarball, $destdir)) {
                dprint "Not creating ", ($tarball ? $tarball : "\"$src_files\""), " -- Already exists.\n";
            } else {
                $err = &create_source_file($src_files, $tarball, $destdir, $tar, $zip);
                if ($err) {
                    return $err;
                }
            }
            foreach $num (@{$specdata->{SOURCES}}) {
                if (($tarball && $specdata->{SOURCE}{$num} =~ /$tarball$/)
                    || (! $tarball && $src_files =~ /^(.*\s+)?$specdata->{SOURCE}{$num}(\s+.*)?$/)) {
                    dprint "Undefining source $num\n";
                    delete $specdata->{SOURCE}{$num};
                }
            }
            @{$specdata->{SOURCES}} = sort {$a <=> $b} keys %{$specdata->{SOURCE}};
        }

        # Clean the checkout we did.
        #chdir("..");
        #&nuke_tree($modname) if (-d $modname);

        # At this point, we've generated all the source files which are initially available
        # in the original import of the module.  Now update to generate other sources.

        $src_files = join(" ", @all_srcs);  # For generating diffs

        $prev_tag = "";
        dprint "Beginning final source file generation....\n";
        foreach $num (@{$specdata->{SOURCES}}) {
            my $source = $specdata->{SOURCE}{$num};
            my ($tag, $files);
            my @new_files;

            dprint "Generating source $num ($source)\n";
            $tag = "$tag_prefix-SOURCE-$num";
            if (!defined $last_tag{$specdata->{SOURCE}{$num}}) {
                eprint "No tag exists for $source ($tag).  I'll create an empty file for it, but this may cause problems.\n";
                &touch_file("$destdir$source");
                next;
            }
            if (&check_for_source_files($source, 0, $destdir)) {
                dprint "Not creating $source -- Already exists.\n";
                next;
            }
            &update_to_tag($last_tag{$specdata->{SOURCE}{$num}}) if ($prev_tag ne $last_tag{$specdata->{SOURCE}{$num}});
            @new_files = &update_to_tag($tag);
            @new_files = grep(! &should_ignore($_), @new_files);
            $prev_tag = $tag;
            next if ($#new_files < 0);
            $files = join(" ", @new_files);
            $err = &create_source_file($files, ($source =~ /\.tar(\.[A-Za-z0-9]+)?$/ ? $source : 0), $destdir, $tar, $zip);
            if ($err) {
                return $err;
            }
        }

        # For patches, diff between the two tags to generate the patch files.
        foreach $num (@{$specdata->{PATCHES}}) {
            my $patch = $specdata->{PATCH}{$num};
            my $tag;

            dprint "Generating diff for patch $num ($patch)\n";
            $tag = "$tag_prefix-PATCH-$num";
            if (!defined $last_tag{$specdata->{PATCH}{$num}}) {
                eprint "No tag exists for $specdata->{PATCH}{$num} ($tag).  I'll create an empty file for it, but this may cause problems.\n";
                &touch_file("$destdir$specdata->{PATCH}{$num}");
                next;
            }
            if (&check_for_source_files($patch, 0, $destdir)) {
                dprint "Not creating $patch -- Already exists.\n";
                next;
            }
            $err = &gen_diff($modname, $src_files, $last_tag{$specdata->{PATCH}{$num}}, $tag, "$destdir$specdata->{PATCH}{$num}");
            if ($err) {
                return $err;
            }
        }
        &update_to_tag($head_tag ? $head_tag : "");
    } else {
        # Just sources.  Do it like we always have.
        foreach $src (@srcs) {
            ($src_files, $tarball) = split(":", $src);
            $src_files =~ s/\&/ /g;
            if (&check_for_source_files($src_files, $tarball, $destdir)) {
                dprint "Not creating ", ($tarball ? $tarball : "\"$src_files\""), " -- Already exists.\n";
            } else {
                $err = &create_source_file($src_files, $tarball, $destdir, $tar, $zip);
                if ($err) {
                    return $err;
                }
            }
        }
    }
    return AVALON_SUCCESS;
}

# main() here is basically the same as main() in C
sub
main
{
    my $ret;

    # Set up the basic variables
    $progname = "pkgtool";
    $version = "2.0";
    &print_usage_info() if (!scalar(@ARGV));
    umask 022;

    # See the Getopt::Long man page for details on the syntax of this line
    @valid_opts = ("h|help", "v|version", "d|debug", "b|build", "i|install", "c|contents", "q|query=s",
                   "g|generate", "u|unarch|unarchive", "o|sources:s", "p|package=s", "s|specfile|scripts=s",
                   "m|module=s", "r|release-tag=s", "t|head-tag=s", "P|program=s", "R|rcfile=s", "tar=s",
                   "zip=s", "tagfile=s", "D|destdir=s", "root=s");
    Getopt::Long::Configure("no_getopt_compat", "bundling", "no_ignore_case");
    Getopt::Long::GetOptions(@valid_opts);

    # Post-parse the options stuff
    select STDOUT; $| = 1;
    if ($opt_v) {
        # Do not edit this variable.  It is updated automatically by CVS when you commit
        my $rcs_info = 'CVS Revision $Revision: 1.39 $ created on $Date: 2001/06/15 03:27:37 $ by $Author: mej $ ';

        $rcs_info =~ s/\$\s*Revision: (\S+) \$/$1/;
        $rcs_info =~ s/\$\s*Date: (\S+) (\S+) \$/$1 at $2/;
        $rcs_info =~ s/\$\s*Author: (\S+) \$ /$1/;
        print "\n";
	print "$progname $version by Michael Jennings <mej\@eterm.org>\n";
        print "Copyright (c) 2000, Michael Jennings and VA Linux Systems, Inc.\n";
        print "  ($rcs_info)\n";
        print "\n";
	return AVALON_SUCCESS;
    } elsif ($opt_h) {
	&print_usage_info();   # Never returns
    }

    if ($opt_b) {
        $mode = "build";
    } elsif ($opt_i) {
        $mode = "install";
    } elsif ($opt_u) {
        $mode = "unarchive";
    } elsif ($opt_c) {
        $mode = "contents";
    } elsif ($opt_g) {
        $mode = "generate";
    } elsif ($opt_q) {
        $mode = "query";
        $query_type = $opt_q;
    } else {
        &fatal_error("Nothing to do!\n");
    }

    &debug_set($opt_d);
    $srcs = $opt_o;
    $pkg_file = $opt_p;
    $pkg_prog = $opt_P;
    $specfile = $script_dir = $opt_s;
    $module = $opt_m;
    $release_tag = $opt_r;
    $head_tag = $opt_t;
    $rcfile = $opt_R;
    $tar = $opt_tar;
    $zip = $opt_zip;
    $tagfile = ($opt_tagfile ? $opt_tagfile : $specfile);
    $destdir = ($opt_D ? $opt_D : "");
    $rootdir = ($opt_root ? $opt_root : "");

    # Signal handling
    $SIG{HUP} = 'IGNORE';
    $SIG{INT} = \&handle_signal;
    $SIG{TERM} = \&handle_signal;
    $SIG{QUIT} = \&handle_fatal_signal;
    $SIG{ILL} = \&handle_fatal_signal;
    $SIG{ABRT} = \&handle_fatal_signal;
    $SIG{FPE} = \&handle_fatal_signal;
    $SIG{SEGV} = \&handle_fatal_signal;
    $SIG{BUS} = \&handle_fatal_signal;
    $SIG{TSTP} = \&handle_fatal_signal;
    $SIG{TTIN} = \&handle_fatal_signal;
    $SIG{TTOU} = \&handle_fatal_signal;

    if ($specfile) {
        if ((-f $specfile || -f "$module/$specfile") && -s _) {
            $type = "rpm";
        } elsif (-d $script_dir) {
            $type = "deb";
        } else {
            eprint "You must specify a valid spec file or script directory with -s\n";
            return AVALON_SYNTAX_ERROR;
        }
    }
    if ($#ARGV >= 0) {
        if (! $specfile) {
            # If they didn't give us a spec file, find one on the command line
            ($specfile) = grep(/\.spec(\.in)?$/, @ARGV);
            if ($specfile) {
                @ARGV = grep($_ !~ /\.spec(\.in)?$/, @ARGV);
            }
        }
        if (! $pkg_file) {
            # If it looks like a package, assume it is one
            $pkg_file = join(" ", grep(/\.(rpm|deb|t?gz|Z)$/, @ARGV));
            if ($pkg_file) {
                @ARGV = grep($_ !~ /\.(rpm|deb|t?gz|Z)$/, @ARGV);
            }
        }
    }
    if ($pkg_file) {
        if ($pkg_file =~ /\.(deb|diff\.gz)$/) {
            $type = "deb";
        } elsif ($pkg_file =~ /\.rpm$/) {
            $type = "rpm";
        } elsif ($pkg_file =~ /\.(t?gz|Z|bz2)$/) {
            $type = "tar";
        }
        dprint "Package type is $type\n";
    }

    if ($mode eq "build") {
        if ($type eq "rpm") {
            # FIXME:  Maybe I should detect if source file generation is needed here?
            if ($specfile) {
                $ret = &rpm_build($specfile);
            } elsif ($pkg_file && $pkg_file =~ /src\.rpm$/) {
                $ret = &rpm_build($pkg_file);
            }
        } elsif ($type eq "deb") {
            $ret = &deb_build();
        } elsif ($type eq "tar") {
            $ret = &rpm_build($pkg_file);
        }
    } elsif ($mode eq "install") {
        if (! $pkg_file) {
            eprint "You cannot perform an install without specifying a package.\n";
            return AVALON_SYNTAX_ERROR;
        }
        if ($type eq "rpm") {
            $ret = &rpm_install($pkg_file);
        } elsif ($type eq "deb") {
            $ret = &deb_install($pkg_file);
        } elsif ($type eq "tar") {
            $ret = &tar_install($pkg_file);
        }
    } elsif ($mode eq "contents") {
        if ($type eq "rpm") {
            $ret = &rpm_show_contents($pkg_file);
        } elsif ($type eq "deb") {
            $ret = &deb_show_contents($pkg_file);
        } elsif ($type eq "tar") {
            $ret = &tar_show_contents($pkg_file);
        }
    } elsif ($mode eq "generate") {
        if (! $specfile) {
            eprint "Please specify a spec file/script directory\n";
            return AVALON_SYNTAX_ERROR;
        }
        if ($type eq "rpm") {
            $ret = &rpm_generate_source_files($specfile, $module, $srcs, $head_tag, $release_tag);
        } elsif ($type eq "deb") {
        } elsif ($type eq "tar") {
        }
    } elsif ($mode eq "query") {
        if (! $specfile && ! $pkg_file) {
            eprint "Please specify a spec file/script directory or a package file.\n";
            return AVALON_SYNTAX_ERROR;
        }
        if ($type eq "rpm") {
            $ret = &rpm_query($pkg_file, $query_type);
        } elsif ($type eq "deb") {
            $ret = &deb_query($pkg_file, $query_type);
        } elsif ($type eq "tar") {
            $ret = &tar_query($pkg_file, $query_type);
        }
    }

    return $ret;
}

exit &main();
