#!/usr/bin/perl -w
#
# pkgtool -- Tool for generating source/patch files from a source code repository
# 
# Copyright (C) 2000, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: pkgtool,v 1.45 2001/08/14 00:22:55 mej Exp $
#

# Include the Perl Modules we need
require POSIX;
require Getopt::Long;
use Cwd ('&getcwd', '&abs_path');
use Avalon::Util;
use Avalon::Pkg;
use Avalon::RPM;
use Avalon::Deb;
use Avalon::Tar;
use Avalon::Build;

# Print usage information
sub
print_usage_info
{
    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   pkgtool [ options ]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -b --build                       Build a package\n";
    print "    -i --install                     Install (unarchive) a package\n";
    print "    -c --contents                    Check the contents of a package\n";
    print "    -q --query <type>                Query attributes of a package\n";
    print "    -o --sources [srcs]              Specify the sources to generate\n";
    print "    -p --package <file>              Specify the package filename\n";
    print "    -s --specfile --scripts <path>   Specify the spec file (or debian script directory) to use\n";
    print "    -m --module <name>               Specify the module name\n";
    print "    -r --release-tag <tag>           Operate on the revisions starting at <tag>\n";
    print "    -t --head-tag <tag>              Operate on the revisions up to and including <tag>\n";
    print "    -P --program <cmd>               Specify the package management program to be used\n";
    print "    -R --rcfile <rcfile>             Specify an alternate rpmrc file\n";
    print "    -D --dir <directory>             Specify \"directory\" as the full path to the module\n";
    print "       --root <dir>                  Specify the build/install root (depending on mode)\n";
    print "       --tar <tarcmd>                Use <tarcmd> as the \"tar\" command\n";
    print "       --zip <zipcmd>                Use <zipcmd> as the compression program\n";
    print "\n";
    exit(AVALON_SUCCESS);
}

# main() here is basically the same as main() in C
sub
main
{
    my ($err, $msg, $outfiles);

    # Set up the basic variables
    $progname = "pkgtool";
    $version = "2.1";
    &print_usage_info() if (!scalar(@ARGV) && &basename($0) !~ /^av/);
    umask 022;

    # See the Getopt::Long man page for details on the syntax of this line
    @valid_opts = ("h|help", "v|version", "d|debug", "b|build", "i|install", "c|contents", "q|query=s",
                   "g|generate", "u|unarch|unarchive", "o|sources:s", "p|package=s", "s|specfile|scripts=s",
                   "m|module=s", "t|target=s", "P|program=s", "R|rcfile=s", "tar=s", "zip=s", "D|destdir=s",
                   "root=s");
    Getopt::Long::Configure("no_getopt_compat", "bundling", "no_ignore_case");
    Getopt::Long::GetOptions(@valid_opts);

    # Post-parse the options stuff
    select STDOUT; $| = 1;
    if ($opt_v) {
        # Do not edit this variable.  It is updated automatically by CVS when you commit
        my $rcs_info = 'CVS Revision $Revision: 1.45 $ created on $Date: 2001/08/14 00:22:55 $ by $Author: mej $ ';

        $rcs_info =~ s/\$\s*Revision: (\S+) \$/$1/;
        $rcs_info =~ s/\$\s*Date: (\S+) (\S+) \$/$1 at $2/;
        $rcs_info =~ s/\$\s*Author: (\S+) \$ /$1/;
        print "\n";
	print "$progname $version by Michael Jennings <mej\@eterm.org>\n";
        print "Copyright (c) 2000, Michael Jennings and VA Linux Systems, Inc.\n";
        print "  ($rcs_info)\n";
        print "\n";
	return AVALON_SUCCESS;
    } elsif ($opt_h) {
	&print_usage_info();   # Never returns
    }

    if ($0 =~ /build$/) {
        $mode = "build";
    } elsif ($0 =~ /inst(all)?$/) {
        $mode = "install";
    } elsif ($opt_b) {
        $mode = "build";
    } elsif ($opt_i) {
        $mode = "install";
    } elsif ($opt_u) {
        $mode = "unarchive";
    } elsif ($opt_c) {
        $mode = "contents";
    } elsif ($opt_g) {
        $mode = "generate";
    } elsif ($opt_q) {
        $mode = "query";
        $query_type = $opt_q;
    } else {
        &fatal_error("Nothing to do!\n");
    }

    &debug_set($opt_d);
    $srcs = ($opt_o ? $opt_o : "");
    $pkg_file = ($opt_p ? $opt_p : "");
    $pkg_prog = ($opt_P ? $opt_P : "");
    $specfile = ($script_dir = $opt_s ? $opt_s : "");
    $module = ($opt_m ? $opt_m : "");
    $target = ($opt_t ? $opt_t : "rpms");
    $rcfile = ($opt_R ? $opt_R : "");
    $tar = ($opt_tar ? $opt_tar : "");
    $zip = ($opt_zip ? $opt_zip : "");
    $destdir = ($opt_D ? $opt_D : "");
    $rootdir = ($opt_root ? $opt_root : "");

    # Signal handling
    $SIG{HUP} = 'IGNORE';
    $SIG{INT} = \&handle_signal;
    $SIG{TERM} = \&handle_signal;
    $SIG{QUIT} = \&handle_fatal_signal;
    $SIG{ILL} = \&handle_fatal_signal;
    $SIG{ABRT} = \&handle_fatal_signal;
    $SIG{FPE} = \&handle_fatal_signal;
    $SIG{SEGV} = \&handle_fatal_signal;
    $SIG{BUS} = \&handle_fatal_signal;
    $SIG{TSTP} = \&handle_fatal_signal;
    $SIG{TTIN} = \&handle_fatal_signal;
    $SIG{TTOU} = \&handle_fatal_signal;

    if ($mode eq "build") {
        my ($pkg, $topdir, $buildroot);

        if ($module) {
            $pkg = $module;
            $topdir = $module;
            ($err, $msg, $outfiles) = &build_package($pkg, $topdir, $buildroot, $target);
        } elsif ((-f $specfile) && (! $pkg_file)) {
            &prepare_build_tree($pkg, $topdir, $buildroot);
            ($err, $msg, $outfiles) = &build_topdir($specfile, $topdir, $buildroot, $target);
        } else {
            if ($pkg_file) {
                $pkg = $pkg_file;
            } elsif (scalar(@ARGV)) {
                $pkg = shift @ARGV;
            } else {
                $pkg = ".";
            }
            $topdir = ((-d $pkg) ? &abs_path($pkg) : undef);
            ($err, $msg, $outfiles) = &build_package($pkg, $topdir, $buildroot, $target);
        }
        if ($err != AVALON_SUCCESS) {
            eprint "Package build failed:  $msg\n";
            return $err;
        }
        print "Package build succeeded.  Output files are:\n\n";
        foreach my $f (split(' ', $outfiles)) {
            if (&copy_files($f, $topdir)) {
                print &basename($f);
            } else {
                print $f;
                $err = 1;
            }
            print "\n";
        }
        print "\n";
        &cleanup_build_tree($topdir, $buildroot, ($err ? "temp" : "build"));
    } elsif ($mode eq "install") {
        if (! $pkg_file) {
            eprint "You cannot perform an install without specifying a package.\n";
            return AVALON_SYNTAX_ERROR;
        }
        if ($type eq "rpm") {
            ($err, $msg, $outfiles) = &rpm_install($pkg_file);
        } elsif ($type eq "deb") {
            ($err, $msg, $outfiles) = &deb_install($pkg_file);
        } elsif ($type eq "tar") {
            ($err, $msg, $outfiles) = &tar_install($pkg_file);
        }
    } elsif ($mode eq "contents") {
        if ($type eq "rpm") {
            ($err, $msg, $outfiles) = &rpm_show_contents($pkg_file);
        } elsif ($type eq "deb") {
            ($err, $msg, $outfiles) = &deb_show_contents($pkg_file);
        } elsif ($type eq "tar") {
            ($err, $msg, $outfiles) = &tar_show_contents($pkg_file);
        }
    } elsif ($mode eq "generate") {
        if (! $specfile) {
            eprint "Please specify a spec file/script directory\n";
            return AVALON_SYNTAX_ERROR;
        }
        if ($type eq "rpm") {
            ($err, $msg, $outfiles) = &rpm_generate_source_files($specfile, $module, $srcs, $destdir, $tar, $zip);
        } elsif ($type eq "deb") {
        } elsif ($type eq "tar") {
        }
    } elsif ($mode eq "query") {
        if (! $specfile && ! $pkg_file) {
            eprint "Please specify a spec file/script directory or a package file.\n";
            return AVALON_SYNTAX_ERROR;
        }
        if ($type eq "rpm") {
            ($err, $msg, $outfiles) = &rpm_query($pkg_file, $query_type);
        } elsif ($type eq "deb") {
            ($err, $msg, $outfiles) = &deb_query($pkg_file, $query_type);
        } elsif ($type eq "tar") {
            ($err, $msg, $outfiles) = &tar_query($pkg_file, $query_type);
        }
    }
    return $err;
}

exit &main();
