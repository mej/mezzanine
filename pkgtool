#!/usr/bin/perl -w
#
# pkgtool -- Tool for generating source/patch files from a source code repository
# 
# Copyright (C) 2000, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: pkgtool,v 1.42 2001/07/26 03:13:50 mej Exp $
#

# Include the Perl Modules we need
require POSIX;
require Getopt::Long;
use Cwd;
use Avalon::Util;
use Avalon::Pkg;
use Avalon::Build;

# Print usage information
sub
print_usage_info
{
    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   pkgtool [ options ]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -b --build                       Build a package\n";
    print "    -i --install                     Install (unarchive) a package\n";
    print "    -c --contents                    Check the contents of a package\n";
    print "    -q --query <type>                Query attributes of a package\n";
    print "    -o --sources [srcs]              Specify the sources to generate\n";
    print "    -p --package <file>              Specify the package filename\n";
    print "    -s --specfile --scripts <path>   Specify the spec file (or debian script directory) to use\n";
    print "    -m --module <name>               Specify the module name\n";
    print "    -r --release-tag <tag>           Operate on the revisions starting at <tag>\n";
    print "    -t --head-tag <tag>              Operate on the revisions up to and including <tag>\n";
    print "    -P --program <cmd>               Specify the package management program to be used\n";
    print "    -R --rcfile <rcfile>             Specify an alternate rpmrc file\n";
    print "    -D --dir <directory>             Specify \"directory\" as the full path to the module\n";
    print "       --root <dir>                  Specify the build/install root (depending on mode)\n";
    print "       --tar <tarcmd>                Use <tarcmd> as the \"tar\" command\n";
    print "       --zip <zipcmd>                Use <zipcmd> as the compression program\n";
    print "\n";
    exit(AVALON_SUCCESS);
}

sub
should_ignore
{
    my $fname = $_[0];

    # Ignore revision control goop
    return 1 if ($fname =~ /^(CVS|SCCS|RCS|BitKeeper)$/);
    # Ignore the revtool-generated ChangeLog
    return 1 if ($fname =~ /^[Cc]hanges?\.?[Ll]og$/);
    # Ignore dotfiles
    return 1 if ($fname =~ /^\./);
    # Ignore spec files
    return 1 if ($fname =~ /\.spec(\.in)?$/);
    # Ignore the debian/ directory
    return 1 if ($fname =~ /^debian$/ && -d $fname);

    return 0;
}

sub
touch_file
{
    my $file = $_[0];
    local *TMP;

    open(TMP, ">$file") && close(TMP);
}

sub
rpm_install
{
    my $pkg_file = $_[0];
    my ($rpm, $cmd, $rc, $err, $msg);
    my (@failed_deps);
    local *RPM;

    $rpm = ($pkg_prog ? $pkg_prog : "rpm");
    $rc = ($rcfile ? "--rcfile '/usr/lib/rpm/rpmrc:$rcfile'" : "");
    $cmd = "$rpm $rc" . ($rootdir ? " --root $rootdir " : " ") . "-U $pkg_file";
    dprint "About to run \"$cmd\"\n";
    if (!open(RPM, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    $err = AVALON_SUCCESS;
    while (<RPM>) {
        chomp($line = $_);
        print "$line\n";
        if ($line =~ /^error: failed build dependencies:/) {
            $err = AVALON_DEPENDENCIES;
            while (<RPM>) {
                chomp($line = $_);
                last if ($line !~ /is needed by/);
                $line =~ s/^\s+(\S+)\s+is needed by .*$/$1/;
                push @failed_deps, $line;
            }
            $msg = sprintf("Installing this package requires the following:  %s", join(" ", @failed_deps));
            last;
        } elsif ($line =~ /^Architecture is not included:/) {
            $err = AVALON_ARCH_MISMATCH;
            $line =~ s/^Architecture is not included:\s+//;
            $msg = "This package does not install on the $line architecture";
        }
    }
    close(RPM);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0 && $err == AVALON_SUCCESS) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    if ($err == AVALON_SUCCESS) {
        print "$pkg_file successfully installed.\n";
    } else {
        eprint "$msg\n";
    }
    return $err;
}

sub
deb_install
{
    my $pkg_file = $_[0];
    my ($dpkg, $cmd);
    my @inp;
    local *DPKG;

    $dpkg = ($pkg_prog ? $pkg_prog : "dpkg");
    $cmd = "$dpkg -x $pkg_file";
    dprint "About to run \"$cmd\"\n";
    if (!open(DPKG, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    while (<DPKG>) {
        print;
    }
    close(DPKG);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    print "$pkg_file successfully installed.\n";
    return AVALON_SUCCESS;
}

sub
tar_install
{
    my $pkg_file = $_[0];
    my ($tar, $dir, $cmd, $err, $msg);
    my (@failed_deps);
    local *TAR;

    $dir = ($rootdir ? $rootdir : "/");
    $tar = ($pkg_prog ? $pkg_prog : "tar -C $dir");
    if ($pkg_file =~ /\.(t?gz|Z)$/) {
        $tar .= " --use-compress-program=gzip";
    } elsif ($pkg_file =~ /\.bz2$/) {
        $tar .= " --use-compress-program=bzip2";
    }
    $cmd = "$tar -xvf $pkg_file";
    dprint "About to run \"$cmd\"\n";
    if (!open(TAR, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    $err = AVALON_SUCCESS;
    while (<TAR>) {
        chomp($line = $_);
        if ($line =~ /^tar: /) {
            eprint "$line\n";
        } else {
            dprint "   $line\n";
        }
    }
    close(TAR);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0 && $err == AVALON_SUCCESS) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    if ($err == AVALON_SUCCESS) {
        print "$pkg_file successfully installed.\n";
    } else {
        eprint "$pkg_file installation failed.\n";
    }
    return $err;
}

sub
rpm_show_contents
{
    my $pkg_file = $_[0];
    my ($rpm, $cmd, $rc);
    local *RPM;

    $rpm = ($pkg_prog ? $pkg_prog : "rpm");
    $rc = ($rcfile ? "--rcfile '/usr/lib/rpm/rpmrc:$rcfile'" : "");
    $cmd = "$rpm $rc -ql " . ($pkg_file ? "-p $pkg_file" : "");
    dprint "About to run \"$cmd\"\n";
    if (!open(RPM, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    while (<RPM>) {
        print;
    }
    close(RPM);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    return AVALON_SUCCESS;
}

sub
deb_show_contents
{
    my $pkg_file = $_[0];
    my ($dpkg, $cmd, $line);
    local *DPKG;

    $dpkg = ($pkg_prog ? $pkg_prog : "dpkg");
    $cmd = "$dpkg -c " . ($pkg_file ? "$pkg_file" : "");
    dprint "About to run \"$cmd\"\n";
    if (!open(DPKG, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    while (<DPKG>) {
        chomp;
        ($line = $_) =~ s/^.* \.(\/.*)$/$1/;
        print "$line\n";
    }
    close(DPKG);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    return AVALON_SUCCESS;
}

sub
tar_show_contents
{
    my $pkg_file = $_[0];
    my ($tar, $cmd);
    local *TAR;

    $tar = ($pkg_prog ? $pkg_prog : "tar");
    if ($pkg_file =~ /\.(t?gz|Z)$/) {
        $tar .= " --use-compress-program=gzip";
    } elsif ($pkg_file =~ /\.bz2$/) {
        $tar .= " --use-compress-program=bzip2";
    }
    $cmd = "$tar -tvf $pkg_file";
    dprint "About to run \"$cmd\"\n";
    if (!open(TAR, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    while (<TAR>) {
        print;
    }
    close(TAR);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    return AVALON_SUCCESS;
}

sub
rpm_query
{
    my ($pkg_file, $query_type) = @_;
    my ($rpm, $rpm_opt, $cmd, $rc, $line);
    my (@prov, @deps);
    local *RPM;

    if ($query_type eq "d") {
        $rpm_opt = "-q --qf '[Contains:  %{FILENAMES}\n][Provides:  %{PROVIDES}\n][Requires:  %{REQUIRENAME} %{REQUIREFLAGS:depflags} %{REQUIREVERSION}\n]'";
    } elsif ($query_type eq "s") {
        $rpm_opt = "-q --qf 'Source:  %{SOURCERPM}\n'";
    } else {
        eprint "Unrecognized query type \"$query_type\"\n";
        return AVALON_SYNTAX_ERROR;
    }
    $rpm = ($pkg_prog ? $pkg_prog : "rpm");
    $rc = ($rcfile ? "--rcfile '/usr/lib/rpm/rpmrc:$rcfile'" : "");
    $cmd = "$rpm $rc $rpm_opt " . ($pkg_file ? "-p $pkg_file" : "-a");
    dprint "About to run \"$cmd\"\n";
    if (!open(RPM, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    while (<RPM>) {
        print;
    }
    close(RPM);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    return AVALON_SUCCESS;
}

sub
deb_query
{
    my ($pkg_file, $query_type) = @_;
    my ($dpkg, $cmd, $line);
    my (@prov, @deps);
    local *DPKG;

    if ($query_type eq "d") {
    } else {
        eprint "Unrecognized query type \"$query_type\"\n";
        return AVALON_SYNTAX_ERROR;
    }
    $dpkg = ($pkg_prog ? $pkg_prog : "dpkg");
    $cmd = "$dpkg -I " . ($pkg_file ? "$pkg_file" : "");
    dprint "About to run \"$cmd\"\n";
    if (!open(DPKG, "$cmd 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
    }
    while (<DPKG>) {
        chomp($line = $_);
        if ($query_type eq "d") {
            if ($line =~ /^\s*Provides:\s+(.*)$/) {
                ($line = $1) =~ s/[\(\)]//g;
                push @prov, split(/\s*,\s*/, $line);
            } elsif ($line =~ /^\s*Depends:\s+(.*)$/) {
                ($line = $1) =~ s/[\(\)]//g;
                push @deps, split(/\s*,\s*/, $line);
            }
        }
    }
    close(DPKG);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0) {
        return AVALON_UNSPECIFIED_ERROR;
    }
    foreach $prov (@prov) {
        print "Capability:  $prov\n";
    }
    foreach $dep (@deps) {
        print "Dependency:  $dep\n";
    }   
    return AVALON_SUCCESS;
}

sub
tar_query
{
    eprint "Tar packages cannot be queried.\n";
    return AVALON_COMMAND_INVALID;
}

sub
rpm_generate_source_files
{
    my ($specfile, $module, $srcs, $destdir, $tar, $zip) = @_;
    my @srcs;

    @srcs = &get_source_list($specfile, $module, $srcs, $destdir);
    return &create_source_files($destdir, $tar, $zip, @srcs);
}

sub
rpm_build
{
    my $target = $_[0];
    my ($cmd, $rpm, $line, $pwd);
    my ($err, $msg) = (0, 0);
    my (@failed_deps, @not_found, @spec_errors, @out_files);
    local *RPM;

    $rpm = ($pkg_prog ? $pkg_prog : "rpm") . ($rcfile ? " --rcfile '/usr/lib/rpm/rpmrc:$rcfile'" : "");
    if ($rootdir) {
        $rpm .= " --buildroot=\"$rootdir\"";
    }
    if (-d $target) {
        $pwd = &getcwd();
        if (!chdir($target)) {
            eprint "Unable to chdir to \"$target\" -- $!\n";
            return AVALON_SYSTEM_ERROR;
        }
    } elsif ($target =~ /src\.rpm$/) {
        $cmd = "$rpm" . ($rcfile ? " --rcfile \"$rcfile\"" : "") . " --rebuild $target";
    } elsif ($target =~ /\.(t?gz|Z|bz2)$/) {
        $cmd = "$rpm" . ($rcfile ? " --rcfile \"$rcfile\"" : "") . " -ta $target";
    } else {
        $cmd = "$rpm" . ($rcfile ? " --rcfile \"$rcfile\"" : "") . " -ba $target";
    }
    dprint "About to run \"$cmd\"\n";
    if (!open(RPM, "$cmd </dev/null 2>&1 |")) {
        eprint "Execution of \"$cmd\" failed -- $!\n";
        return AVALON_COMMAND_FAILED;
    }
    $err = AVALON_SUCCESS;
    while (<RPM>) {
        chomp($line = $_);
        print "$line\n";
        if ($line =~ /^Wrote:\s+(\S+\.\w+\.rpm)$/) {
            push @out_files, $1;
        } elsif ($line =~ /^line \d+: [^:]+: /
                 || $line =~ /^Failed to find \w+:/
                 || $line =~ /^Symlink points to BuildRoot: /) {
            $err = AVALON_SPEC_ERRORS;
            push @spec_errors, $line;
        } elsif ($line =~ /^Bad exit status from/) {
            $err = AVALON_BUILD_FAILURE;
            $line =~ s/^Bad exit status from \S+ \((%\w+)\)/$1/;
            $msg = "The RPM $line stage exited abnormally";
        } elsif ($line =~ /^error: failed build dependencies:/) {
            $err = AVALON_DEPENDENCIES;
            while (<RPM>) {
                chomp($line = $_);
                last if ($line !~ /is needed by/);
                $line =~ s/^\s+(\S+)\s+is needed by .*$/$1/;
                push @failed_deps, $line;
            }
            $msg = sprintf("Building this package requires the following:  %s", join(" ", @failed_deps));
            last;
        } elsif ($line =~ /^Architecture is not included:/) {
            $err = AVALON_ARCH_MISMATCH;
            $line =~ s/^Architecture is not included:\s+//;
            $msg = "This package does not build on the $line architecture";
        } elsif ($line =~ /^File (.*): No such file or directory$/
                 || $line =~ /^Bad file: (.*): No such file or directory$/
                 || $line =~ /^File is not a regular file: (.*)$/
                 || $line =~ /^Unable to open icon (\S+):$/
                 || $line =~ /^No (patch number \d+)$/
                 || $line =~ /^Could not open \%files file (\S+): No such file or directory$/
                 || $line =~ /^File not found(?: by glob)?: (.*)$/) {
            $err = AVALON_MISSING_FILES;
            push @not_found, $1;
        }
    }
    close(RPM);
    dprint "\"$cmd\" returned $?\n";
    if ($? != 0 && $err == AVALON_SUCCESS) {
        $err = AVALON_UNSPECIFIED_ERROR;
        $msg = "Unhandled package build error";
    } elsif ($#not_found != -1) {
        $msg = sprintf("The following were expected by the build, but no matching files were found:  \"%s\"",
                       join("\", \"", @not_found));
    } elsif ($#spec_errors != -1) {
        $msg = sprintf("The spec file contains the following errors:  \"%s\"", join("\", \"", @spec_errors));
    }

    if ($msg) {
        eprint "$msg\n";
    }
    if ($#out_files >= 0) {
        print "Package files generated:  ", join(" ", @out_files), "\n";
    }
    return $err;
}

sub
deb_build
{

}

# main() here is basically the same as main() in C
sub
main
{
    my $ret;

    # Set up the basic variables
    $progname = "pkgtool";
    $version = "2.1";
    &print_usage_info() if (!scalar(@ARGV));
    umask 022;

    # See the Getopt::Long man page for details on the syntax of this line
    @valid_opts = ("h|help", "v|version", "d|debug", "b|build", "i|install", "c|contents", "q|query=s",
                   "g|generate", "u|unarch|unarchive", "o|sources:s", "p|package=s", "s|specfile|scripts=s",
                   "m|module=s", "t|type=s", "P|program=s", "R|rcfile=s", "tar=s", "zip=s", "D|destdir=s",
                   "root=s");
    Getopt::Long::Configure("no_getopt_compat", "bundling", "no_ignore_case");
    Getopt::Long::GetOptions(@valid_opts);

    # Post-parse the options stuff
    select STDOUT; $| = 1;
    if ($opt_v) {
        # Do not edit this variable.  It is updated automatically by CVS when you commit
        my $rcs_info = 'CVS Revision $Revision: 1.42 $ created on $Date: 2001/07/26 03:13:50 $ by $Author: mej $ ';

        $rcs_info =~ s/\$\s*Revision: (\S+) \$/$1/;
        $rcs_info =~ s/\$\s*Date: (\S+) (\S+) \$/$1 at $2/;
        $rcs_info =~ s/\$\s*Author: (\S+) \$ /$1/;
        print "\n";
	print "$progname $version by Michael Jennings <mej\@eterm.org>\n";
        print "Copyright (c) 2000, Michael Jennings and VA Linux Systems, Inc.\n";
        print "  ($rcs_info)\n";
        print "\n";
	return AVALON_SUCCESS;
    } elsif ($opt_h) {
	&print_usage_info();   # Never returns
    }

    if ($0 =~ /build$/) {
        $mode = "build";
    } elsif ($0 =~ /inst(all)?$/) {
        $mode = "install";
    } elsif ($opt_b) {
        $mode = "build";
    } elsif ($opt_i) {
        $mode = "install";
    } elsif ($opt_u) {
        $mode = "unarchive";
    } elsif ($opt_c) {
        $mode = "contents";
    } elsif ($opt_g) {
        $mode = "generate";
    } elsif ($opt_q) {
        $mode = "query";
        $query_type = $opt_q;
    } else {
        &fatal_error("Nothing to do!\n");
    }

    &debug_set($opt_d);
    $srcs = $opt_o;
    $pkg_file = $opt_p;
    $pkg_prog = $opt_P;
    $specfile = $script_dir = $opt_s;
    $module = $opt_m;
    $type = $opt_t;
    $rcfile = $opt_R;
    $tar = $opt_tar;
    $zip = $opt_zip;
    $destdir = ($opt_D ? $opt_D : "");
    $rootdir = ($opt_root ? $opt_root : "");

    # Signal handling
    $SIG{HUP} = 'IGNORE';
    $SIG{INT} = \&handle_signal;
    $SIG{TERM} = \&handle_signal;
    $SIG{QUIT} = \&handle_fatal_signal;
    $SIG{ILL} = \&handle_fatal_signal;
    $SIG{ABRT} = \&handle_fatal_signal;
    $SIG{FPE} = \&handle_fatal_signal;
    $SIG{SEGV} = \&handle_fatal_signal;
    $SIG{BUS} = \&handle_fatal_signal;
    $SIG{TSTP} = \&handle_fatal_signal;
    $SIG{TTIN} = \&handle_fatal_signal;
    $SIG{TTOU} = \&handle_fatal_signal;

    if ($specfile) {
        if ((-f $specfile || -f "$module/$specfile") && -s _) {
            $type = "rpm" if (! $type);
        } elsif (-d $script_dir) {
            $type = "deb" if (! $type);
        } else {
            eprint "You must specify a valid spec file or script directory with -s\n";
            return AVALON_SYNTAX_ERROR;
        }
    }
    if ($pkg_file && ! $type) {
        if ($pkg_file =~ /\.(deb|diff\.gz)$/) {
            $type = "deb";
        } elsif ($pkg_file =~ /\.rpm$/) {
            $type = "rpm";
        } elsif ($pkg_file =~ /\.(t?gz|Z|bz2)$/) {
            $type = "tar";
        }
    }
    dprint "Package type is $type\n";

    if ($mode eq "build") {
        if ($type eq "rpm") {
            # FIXME:  Maybe I should detect if source file generation is needed here?
            if ($specfile) {
                $ret = &rpm_build($specfile);
            } elsif ($pkg_file && $pkg_file =~ /src\.rpm$/) {
                $ret = &rpm_build($pkg_file);
            } elsif (-d "F") {
                $ret = &rpm_build(".");
            } elsif (-d "$module/F") {
                $ret = &rpm_build($module);
            }
        } elsif ($type eq "deb") {
            $ret = &deb_build();
        } elsif ($type eq "tar") {
            $ret = &rpm_build($pkg_file);
        }
    } elsif ($mode eq "install") {
        if (! $pkg_file) {
            eprint "You cannot perform an install without specifying a package.\n";
            return AVALON_SYNTAX_ERROR;
        }
        if ($type eq "rpm") {
            $ret = &rpm_install($pkg_file);
        } elsif ($type eq "deb") {
            $ret = &deb_install($pkg_file);
        } elsif ($type eq "tar") {
            $ret = &tar_install($pkg_file);
        }
    } elsif ($mode eq "contents") {
        if ($type eq "rpm") {
            $ret = &rpm_show_contents($pkg_file);
        } elsif ($type eq "deb") {
            $ret = &deb_show_contents($pkg_file);
        } elsif ($type eq "tar") {
            $ret = &tar_show_contents($pkg_file);
        }
    } elsif ($mode eq "generate") {
        if (! $specfile) {
            eprint "Please specify a spec file/script directory\n";
            return AVALON_SYNTAX_ERROR;
        }
        if ($type eq "rpm") {
            $ret = &rpm_generate_source_files($specfile, $module, $srcs, $destdir, $tar, $zip);
        } elsif ($type eq "deb") {
        } elsif ($type eq "tar") {
        }
    } elsif ($mode eq "query") {
        if (! $specfile && ! $pkg_file) {
            eprint "Please specify a spec file/script directory or a package file.\n";
            return AVALON_SYNTAX_ERROR;
        }
        if ($type eq "rpm") {
            $ret = &rpm_query($pkg_file, $query_type);
        } elsif ($type eq "deb") {
            $ret = &deb_query($pkg_file, $query_type);
        } elsif ($type eq "tar") {
            $ret = &tar_query($pkg_file, $query_type);
        }
    }

    return $ret;
}

exit &main();
