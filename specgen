#!/usr/bin/perl -w
#
# specgen -- Tool for creating spec files for generic package types.
# 
# Copyright (C) 2004, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: specgen,v 1.1 2004/03/25 02:58:40 mej Exp $
#

use strict;
use vars '$progname', '$version', '$opt_v', '$opt_h', '$opt_d',
    '$opt_t', '$opt_s', '$opt_p', '$opt_n', '$opt_u';
use CPAN;
use POSIX;
use Getopt::Long;
use Mezzanine::Util;
use Mezzanine::Template;

my %package_start = (
                     "SUMMARY" => "FIXME -- Brief synopsis goes here",
                     "NAME" => "",
                     "VERSION" => "",
                     "RELEASE" => "1.%{?_vendorsuffix:%{_vendorsuffix}}%{!?_vendorsuffix:%{_vendor}}",
                     "VENDORSUFFIX" => "%{?_vendorsuffix:%{_vendorsuffix}}%{!?_vendorsuffix:%{_vendor}}",
                     "LICENSE" => "OSI-Approved",
                     "GROUP" => "FIXME/SetThis",
                     "TARBALL" => "",
                     "EXTRACTWITH" => "",
                     "PACKAGER" => "%{?_packager:%{_packager}}%{!?_packager:%{_vendor}}",
                     "VENDOR" => "%{?_vendorinfo:%{_vendorinfo}}%{!?_vendorinfo:%{_vendor}}",
                     "DISTRIBUTION" => "%{?_distribution:%{_distribution}}%{!?_distribution:%{_vendor}}",
                     "DESCRIPTION" => "FIXME -- Description goes here",
                     "SRCDIR" => "",
                     "CFLAGS" => "%{?cflags:%{cflags}}%{!?cflags:\$RPM_OPT_FLAGS}",
                     "CXXFLAGS" => "%{?cxxflags:%{cxxflags}}%{!?cflags:\$RPM_OPT_FLAGS}",
                     "DOCFILES" => "README",
                     "INSTFILES" => "/*",
                     "CHANGELOG" => sprintf("* %s Mezzanine <mezzanine\@kainx.org>\n- %s\n",
                                            POSIX::strftime("%a %b %d %Y", localtime()),
                                            "Specfile auto-generated by $progname"),
                     "TEMPLATE" => undef
                    );
# Print usage information
sub
print_usage_info
{
    my ($leader, $underbar);

    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   specgen [ options ] package [...]\n";
    print "\n";
    print "    -h --help                        Show this usage information\n";
    print "    -d --debug                       Turn on debugging\n";
    print "    -v --version                     Show version and copyright\n";
    print "    -t --template <path>             Use specified template file/directory\n";
    print "\n";
    exit(MEZZANINE_SUCCESS);
}

# Interactively obtain information from the user IFF stdin and stdout are tty's.
sub
prompt_user($$)
{
    my ($prompt, $default) = @_;
    my $response;

    if (!(-t STDIN && -t STDOUT)) {
        return $default;
    }
    if ($default) {
        print "$prompt (default \"$default\"):  ";
    } else {
        print "$prompt:  ";
    }
    $response = <STDIN>;
    chomp($response);

    return (($response) ? ($response) : ($default));
}

sub
parse_tarball_name($)
{
    my $href = $_[0];
    my $pkg = $href->{"TARBALL"};

    if (! $pkg) {
        eprint "Ummm...no package?  Somebody screwed the pooch.\n";
        return undef;
    }

    if ($pkg =~ /(\.(t|tar\.)gz)$/i) {
        $href->{"EXTRACTWITH"} = "gzip -d -c \@\@ | tar -xf -";
        $pkg =~ s/$1$//;
    } elsif ($pkg =~ /(\.(t|tar\.)bz2?)$/i) {
        $href->{"EXTRACTWITH"} = "bzip2 -d -c \@\@ | tar -xf -";
        $pkg =~ s/$1$//;
    } elsif ($pkg =~ /(\.(t|tar\.)Z)$/i) {
        $href->{"EXTRACTWITH"} = "compress -d -c \@\@ | tar -xf -";
        $pkg =~ s/$1$//;
    } elsif ($pkg =~ /(\.zip)$/i) {
        $href->{"EXTRACTWITH"} = "unzip";
        $pkg =~ s/$1$//;
    } elsif ($pkg =~ /(\.(c|cpio\.)gz)$/i) {
        $href->{"EXTRACTWITH"} = "gzip -d -c \@\@ | cpio -iud";
        $pkg =~ s/$1$//;
    } elsif ($pkg =~ /(\.(c|cpio\.)bz2?)$/i) {
        $href->{"EXTRACTWITH"} = "bzip2 -d -c \@\@ | cpio -iud";
        $pkg =~ s/$1$//;
    } elsif ($pkg =~ /(\.(c|cpio\.)Z)$/i) {
        $href->{"EXTRACTWITH"} = "compress -d -c \@\@ | cpio -iud";
        $pkg =~ s/$1$//;
    } elsif ($pkg =~ /(_[^\.]+\.deb)$/i) {
        $href->{"EXTRACTWITH"} = "ar x \@\@";
        $pkg =~ s/$1$//;
    } elsif ($pkg =~ /(\.[^\.]+\.rpm)$/i) {
        $href->{"EXTRACTWITH"} = "rpm2cpio \@\@ | cpio -iud";
        $pkg =~ s/$1$//;
    } else {
        wprint "Unrecognized package file format.\n";
        for ($href->{"EXTRACTWITH"} = ""; $href->{"EXTRACTWITH"}; ) {
            $href->{"EXTRACTWITH"} = &prompt_user("Please enter command to extract $pkg (specify \@\@ for $pkg)");
            if ($href->{"EXTRACTWITH"} !~ /\@\@/) {
                eprint "The command must contain \@\@ at the position where the archive filename should go.  Please try again.\n\n";
                $href->{"EXTRACTWITH"} = "";
            }
        }
    }
    if (! $href->{"EXTRACTWITH"}) {
        eprint "Unrecognized package file format.\n";
        return undef;
    } else {
        dprint "Extraction command for $pkg is $href->{EXTRACTWITH}.\n";
    }

    # Parse out package name and version.
    if ($pkg =~ /^(.*)-(\d[^-]+)$/) {
        @{$href}{("NAME", "VERSION")} = ($1, $2);
    } else {
        wprint "Unable to parse package name/version from base name $pkg.\n";
        $href->{"NAME"} = &prompt_user("Please enter package name", $pkg);
        $href->{"VERSION"} = &prompt_user("Please enter package version", "1.0");
    }
    if (! $href->{"NAME"} || ! $href->{"VERSION"}) {
        eprint "Unparseable package file base name $pkg.\n";
        return undef;
    } else {
        dprint "Package $href->{NAME}, version $href->{VERSION}.\n";
    }
    return 1;
}

sub
create_spec_file(\%)
{
    my $href = $_[0];
    my $template = $href->{"TEMPLATE"};
    my $pkgname = $href->{"NAME"};
    my $specfile = sprintf("%s/%s.spec", $pkgname, $pkgname);
    my $ret;

    if (!(-d $pkgname || &mkdirhier($pkgname))) {
        eprint "Unable to create directory $pkgname -- $!\n";
        return;
    }

    if (! $template->verify()) {
        eprintf("Cannot package; template %s/%s not found.\n",
                $template->directory(), $template->file());
        return;
    }

    # Assign variables.
    foreach my $key (keys(%{$href})) {
        $template->vars($key, $href->{$key});
    }
    $template->delimiter('@');

    # Generate the spec file
    $ret = $template->generate($specfile);
    if (!defined($ret)) {
        eprint "Unable to open template file -- $!\n";
    } elsif (! $ret) {
        eprint "Unable to create spec file $specfile -- $!\n";
    } else {
        print "Package $pkgname created.\n";
    }
}

# main() here is basically the same as main() in C
sub
main
{
    my @valid_opts;
    my $errors = 0;
    my %package;

    # Signal handling
    $SIG{"HUP"} = 'IGNORE';
    $SIG{"INT"} = \&handle_signal;
    $SIG{"TERM"} = \&handle_signal;
    $SIG{"QUIT"} = \&handle_fatal_signal;
    $SIG{"ILL"} = \&handle_fatal_signal;
    $SIG{"ABRT"} = \&handle_fatal_signal;
    $SIG{"FPE"} = \&handle_fatal_signal;
    $SIG{"SEGV"} = \&handle_fatal_signal;
    $SIG{"BUS"} = \&handle_fatal_signal;
    $SIG{"TSTP"} = \&handle_fatal_signal;
    $SIG{"TTIN"} = \&handle_fatal_signal;
    $SIG{"TTOU"} = \&handle_fatal_signal;

    # Set up the basic variables
    $progname = "specgen";
    $version = "0.1";
    umask 022;

    # See the Getopt::Long man page for details on the syntax of this line
    @valid_opts = ("h|help", "v|version", "d|debug", "t|template=s");
    Getopt::Long::Configure("no_getopt_compat", "bundling", "no_ignore_case");
    Getopt::Long::GetOptions(@valid_opts);

    # Post-parse the options stuff
    select STDOUT; $| = 1;
    if ($opt_v) {
        # Do not edit this variable.  It is updated automatically by CVS when you commit
        my $rcs_info = 'CVS Revision $Revision: 1.1 $ created on $Date: 2004/03/25 02:58:40 $ by $Author: mej $ ';

        $rcs_info =~ s/\$\s*Revision: (\S+) \$/$1/;
        $rcs_info =~ s/\$\s*Date: (\S+) (\S+) \$/$1 at $2/;
        $rcs_info =~ s/\$\s*Author: (\S+) \$ /$1/;
        print "\n";
	print "$progname $version by Michael Jennings <mej\@eterm.org>\n";
        print "Copyright (c) 2004, Michael Jennings\n";
        print "  ($rcs_info)\n";
        print "\n";
	return MEZZANINE_SUCCESS;
    } elsif ($opt_h || !scalar(@ARGV)) {
	&print_usage_info();   # Never returns
    }
    &debug_set($opt_d);

    foreach my $pkg (@ARGV) {
        my $template = new Mezzanine::Template;

        # Initialize hash.
        %package = %package_start;

        # Create template object for new spec file.
        if ($opt_t) {
            if (-d $opt_t) {
                $template->directory($opt_t);
            } elsif (-f $opt_t) {
                $template->file(&basename($opt_t));
                $template->directory(&dirname($opt_t));
            }
        }
        if (! $template->file()) {
            $template->file("GNU-autosplat.spec");
        }
        $template->find($template->directory());
        $package{"TEMPLATE"} = $template;

        $package{"TARBALL"} = $pkg;
        &parse_tarball_name(\%package);



        &create_spec_file(\%package);
    }
    return $errors;
}

exit &main();
