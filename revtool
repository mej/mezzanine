#!/usr/bin/perl
#
# revtool -- Source Code Revision Control Tool
# 
# Copyright (C) 2000, Michael Jennings
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software, its documentation and marketing & publicity
# materials, and acknowledgment shall be given in the documentation, materials
# and software packages that this Software was used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# $Id: revtool,v 1.48 2000/08/07 21:35:52 mej Exp $
#

# Include the Perl Modules we need
use POSIX 'strftime';
use Getopt::Long;

# Constants
#
# 1-20 are generic errors
sub REVTOOL_NO_SERVER()           {1;}
sub REVTOOL_SERVER_CRASH()        {2;}
sub REVTOOL_BAD_LOGIN()           {3;}
sub REVTOOL_COMMAND_FAILED()      {4;}
sub REVTOOL_ACCESS_DENIED()       {5;}
sub REVTOOL_NO_SOURCES()          {6;}

# 21-40 are retrieval/update errors
sub REVTOOL_FILE_NOT_FOUND()      {21;}
sub REVTOOL_FILE_REMOVED()        {22;}
sub REVTOOL_CONFLICT_FOUND()      {23;}
sub REVTOOL_INVALID_TAG()         {24;}

# 41-60 are add/remove errors
sub REVTOOL_BAD_ADDITION()        {41;}
sub REVTOOL_BAD_REMOVAL()         {42;}

# 61-80 are commit errors
sub REVTOOL_NEED_UPDATE()         {61;}
sub REVTOOL_BAD_LOG_ENTRY()       {62;}

# 127 is a catch-all
sub REVTOOL_UNSPECIFIED_ERROR()   {127;}

# Print usage information
sub
print_usage_info
{
    print "\n";
    $leader = "$progname $version Usage Information";
    $underbar = $leader;
    $underbar =~ s/./-/g;
    print "$leader\n$underbar\n";
    print "\n";
    print "  Syntax:   $progname [ options ] [ files ]\n";
    print "\n";
    print "    -h --help                Show this usage information\n";
    print "    -d --debug               Turn on debugging\n";
    print "    -v --version             Show version and copyright\n";
    print "    -g --get                 Download and/or merge the current sources from the master tree\n";
    print "    -p --put                 Upload new changes to the master tree\n";
    print "    -a --add                 Mark new files for addition into the master tree\n";
    print "    -r --remove              Delete files and mark them for deletion in the master tree\n";
    print "    -q --query <type>        Query for a particular type of information\n";
    print "    -i --import              Import a new set of sources, or update the vendor branch for a package\n";
    print "    -T --rtag <tag>          Tag one or more complete modules directly\n";
    print "    -t --tag <tag>           Specify a symbolic tag for an operation, or tag local sources\n";
    print "       --ptag                Specified tag is a product tag (overrides tag checking; use with care)\n";
    print "    -b --branch              When performing a tag, make it a branch tag\n";
    print "    -l --login               Perform a login to the repository\n";
    print "    -R --recurse             Operate recursively (this is the default for some commands)\n";
    print "    -k [code]                Specify keyword handling when adding files (use -kb to add binary files)\n";
    print "    -D --dir                 Specify an alternative repository (\$CVSROOT)\n";
    print "    -x --exclusive           Only commit the specified files\n";
    print "       --addlist \"files\"     Specify which files to add so that adds and removes can coincide\n";
    print "       --remlist \"files\"     Specify which files to remove so that adds and removes can coincide\n";
    print "       --reset               Reset sticky tags, dates, etc. in the current module\n";
    print "    -P --protocol <proto>    Specify which protocol to use (cvs or bk)\n";
    print "\n";
    exit(0);
}

# Generate timestamp for debugging/log file
sub
get_timestamp
{
    strftime("%A, %d %B %Y %H:%M:%S %Z", localtime);
}

# Debugging output
sub
dprintf
{
    return if (! $debug);
    print "[debug:$progname] ";
    my $fmt = shift;
    printf $fmt, @_;
}
sub
dprint
{
    print "[debug:$progname] ", @_ if ($debug);
}

# Print an error
sub
eprintf
{
    print STDERR "$progname:  Error:  ";
    my $fmt = shift;
    printf STDERR $fmt, @_;
}
sub
eprint
{
    print STDERR "$progname:  Error:  ", @_;
}

# Return the contents of a file as a string
sub
cat_file
{
    my $filename = $_[0];
    my $contents = "";

    open(FF, "$filename") || return undef;
    while (<FF>) {
        $contents .= $_;
    }
    return $contents;
}

# Check a tag for validity
sub
check_tag
{
    my ($module, $tag) = @_;

    # The regexp's below enforce the following tag rules:
    #   1. Branch tags must begin with a branch key, hypen, the package name, hyphen, e.g. VA-KERNEL-
    #   2. Non-branch tags are the same, but without the branch key at the beginning, e.g. KERNEL-
    #   3. Tags must contain only uppercase characters and hyphens.  Note that this rule is more
    #      restrictive than CVS's own rules but is enforced for standards compliance.
    #   4. Product tags are only subject to rule #3.

    if ($tag !~ /^[-A-Z0-9]+$/) {
        return 0;
    }
    if ($mode ne "ptag") {
        if ($opt_b) {
            if ($tag !~ /^([A-Z]+)-$module-/) {
                return 0;
            }
        } else {
            if ($tag !~ /^$module-/) {
                return 0;
            }
        }
    }
    return 1;
}

# This routine dispatches server requests to the appropriate
# routine based on the selected protocol (cvs or bk).
sub
talk_to_server
{
    if ($protocol eq "cvs") {
        return &talk_to_cvs_server(@_);
    } elsif ($protocol eq "bk") {
        return &talk_to_bk_server(@_);
    }
}

# This routine handles interaction with the master CVS server
sub
talk_to_cvs_server
{
    my ($type, $cmd) = @_;
    my ($err, $tries, $line);
    my (@tags, @links, @ignores, @not_found, @removed, @conflicts);

    for ($err = 0; (($err == -1) || ($tries == 0)); $tries++) {
        $err = 0;
        dprint "About to run $cmd\n";
        if (!open(CMD, "$cmd 2>&1 |")) {
            eprint "Execution of \"$cmd\" failed -- $!";
            return REVTOOL_COMMAND_FAILED;
        }
        while (<CMD>) {
            chomp($line = $_);
            if ($line =~ /^cvs \w+: Diffing/) {
                dprint "$line\n";
            } else {
                print "$line\n";
            }

            # The following routines do output checking for fatal errors,
            # non-fatal (retryable) errors, and expected command output

            # First, fatal errors
            if ($line =~ /^cvs \w+: cannot find password/) {
                eprint "You must login to the repository first.\n";
                $err = REVTOOL_BAD_LOGIN;
                last;
            } elsif ($line =~ /^cvs \[\w+ aborted\]: authorization failed: server \S+ rejected access/) {
                eprint "Your userid or password was not valid";
                $err = REVTOOL_BAD_LOGIN;
                last;
            } elsif ($line =~ /^cvs \[\w+ aborted\]: \S+ requires write access to the repository/) {
                eprint "You do not have write access to the master repository.\n";
                $err = REVTOOL_ACCESS_DENIED;
                last;
            } elsif ($line =~ /^cvs server: cannot find module .(\S+). /) {
                push @not_found, $1;
                $err = REVTOOL_FILE_NOT_FOUND;
            } elsif ($line =~ /^cvs server: warning: (.+) is not \(any longer\) pertinent/
                     || $line =~ /^cvs server: warning: newborn (\S+) has disappeared/) {
                push @removed, $1;
                $err = REVTOOL_FILE_REMOVED;
            } elsif ($line =~ /^C (.+)$/) {
                push @conflicts, $1;
                $err = REVTOOL_CONFLICT_FOUND;
            } elsif ($line =~ /^cvs \[\w+ aborted\]: no such tag/
                     || $line =~ /^cvs \S+: warning: new-born \S+ has disappeared$/) {
                eprint "$opt_t is not a valid tag for $file_list\n";
                $err = REVTOOL_INVALID_TAG;
            } elsif ($line =~ /^cvs server: nothing known about/) {
                $line =~ s/^cvs server: nothing known about//;
                if ($type eq "add") {
                    eprint "You tried to add a file which does not exist locally ($line).\n";
                    $err = REVTOOL_BAD_ADDITION;
                } else {
                    eprint "You tried to remove a file which does not exist in the repository ($line).\n";
                    $err = REVTOOL_BAD_REMOVAL;
                }

            # Retryable errors
            } elsif ($line =~ /^cvs \[\w+ aborted\]: connect to \S+ failed: Connection refused/) {
                if ($tries < 10) {
                    $err = -1;
                    print "The CVS server seems to be down.  I'll wait a bit and try again.\n";
                    sleep 3;
                } else {
                    eprint "The CVS server was unreachable.\n";
                    $err = REVTOOL_NO_SERVER;
                    last;
                }
            } elsif ($line =~ /^Unknown host (\S+)\.$/) {
                if ($tries < 10) {
                    $err = -1;
                    print "I can't seem to resolve $1.  I'll wait a bit and try again.\n";
                    sleep 3;
                } else {
                    eprint "The CVS server name ($1) does not resolve.\n";
                    $err = REVTOOL_NO_SERVER;
                    last;
                }
            } elsif ($line =~ /^cvs \[\w+ aborted\]: received .* signal/) {
                if ($tries < 10) {
                    $err = -1;
                    print "The CVS server crashed.  I'll wait a bit and try again.\n";
                    sleep 3;
                } else {
                    eprint "The CVS server kept crashing.\n";
                    $err = REVTOOL_SERVER_CRASH;
                    last;
                }

            # Expected output
            } elsif ($line =~ /^\s*Existing Tags:\s*$/) {
                if ($type eq "query_tags") {
                    my $tmp;

                    while (($tmp = <CMD>) !~ /^\s*$/) {
                        last if ($tmp =~ /^\s*No Tags Exist\s*$/);
                        $tmp =~ s/^\s*(\S+)\s+\((\w+):\s*([\d.]+)\)$/$1 at $2 $3/;
                        push @tags, $tmp;
                    }
                    last;
                }
            } elsif ($line =~ /^I (.+)$/) {
                push @ignores, $1;
            } elsif ($line =~ /^L (.+)$/) {
                push @links, $1;
            }
        }
        close(CMD);
        dprint "Command returned $?\n";
    }
    if ($err == 0 && $? != 0) {
        eprint "An unknown error must have occured, because the command returned $?\n";
        $err = REVTOOL_UNSPECIFIED_ERROR;
    }
    if ($err) {
        if ($#conflicts != -1) {
            eprint "The following files had conflicts:  ", join(" ", @conflicts), "\n";
        }
        if ($#not_found != -1) {
            eprint "The following files/modules were not found in the repository:  ", join(" ", @not_found), "\n";
        }
        if ($#removed != -1) {
            eprint "The following files/modules were removed from the repository:  ", join(" ", @removed), "\n";
        }
    } else {
        if ($#tags >= 0) {
            print @tags;
        } else {
            print "No tags found.\n";
        }
    }
    if ($#links >= 0) {
        print "The following symbolic links were ignored (not imported):  ", join(" ", @links), "\n";
    }
    if ($#ignores >= 0) {
        print "The following files were ignored (not imported):  ", join(" ", @ignores), "\n";
    }
    return ($err);
}

# This routine handles interaction with the master BK server
sub
talk_to_bk_server
{
    my ($type, $cmd) = @_;

    return REVTOOL_UNSPECIFIED_ERROR;
}

# Login to the repository
sub
login_to_master
{
    my $login = $_[0];
    my ($cmd, $line, $pass, $err, $msg, $found);
    local (*CMD, *CVSPASS);

    if (-t STDIN) {
        $cmd = "/bin/sh -c \"cvs -d $login login\"";
        $err = &talk_to_server("login", $cmd);
        if ($err) {
            return 0;
        }
    } else {
        dprint "Performing automated login with an empty password.\n";
        open(CVSPASS, "$ENV{HOME}/.cvspass") || return 0;
        $found = 0;
        while (<CVSPASS>) {
            chomp($line = $_);
            if ($line =~ /^$login/) {
                $found = 1;
                last;
            }
        }
        close(CVSPASS);
        if ($found) {
            dprint "Login not required.\n";
        } else {
            dprint "Login not found.  Adding cvspass entry.\n";
            open(CVSPASS, ">> $ENV{HOME}/.cvspass");
            print CVSPASS "$login A\n";
            close(CVSPASS);
        }
    }
    return 1;
}

# Commit changes to the master repository
sub
commit_to_master
{
    my $logfile = "/var/tmp/.cvs.commit.$$";
    my ($cmd, $username, $fullname, $err, $tries, $line, $module);
    my @stat_info;
    my $cwd = `pwd`;
    my $file_list = join(" ", @_);

    $cwd =~ s/^\S+\/([^\/]+)$/$1/;  # Remove all but the last part
    chomp($cwd);
    dprint "cwd is $cwd\n";
    open(LOGFILE, ">$logfile") || die("Cannot write to $logfile -- $!\n");
    dprint("Opened log file $logfile for commit log\n");
    $username = $ENV{"LOGNAME"};
    @pw_info = getpwnam($username);
    $fullname = $pw_info[6];
    printf LOGFILE "%-25s%45s\n\n", scalar localtime, ($fullname ? "$fullname ($username)" : "$username");
    close(LOGFILE);
    chomp($module = &cat_file("CVS/Repository"));
    dprint "Current directory is \"$cwd\", module name is \"$module\"\n";
    if (! $opt_x) {
        if ($module ne $cwd) {
            # We're not in the module directory.  Offer to cd to it.
            $opt_x = 1;  # For now, just don't write the ChangeLog
        }
    }
    if (! $opt_x) {  # This extra check will go away when the above section is fleshed out.
        if (! -f "ChangeLog") {
            open(CL, ">ChangeLog");
            print "WARNING:  You have no ChangeLog here.  I have created one for you.\n";
            &add_new_files("ChangeLog");
        } else {
            open(CL, ">>ChangeLog");
            if ($file_list !~ /^\s*$/ && $file_list !~ /ChangeLog/) {
                $file_list = "$file_list ChangeLog";
            }
        }
    }        
    print "Please edit your commit message now...\n";
    system($ENV{"EDITOR"} ? $ENV{"EDITOR"} : "vi", $logfile);

    # Abort if the logfile was not modified or is too small.
    @stat_info = stat($logfile);
    if ($stat_info[7] <= 72) {
        print "Commit message was unmodified or is too short.  Aborting commit.\n";
        return REVTOOL_BAD_LOG_ENTRY;
    }
    if (! $opt_x) {
        open(LOGFILE, "<$logfile");
        while (<LOGFILE>) {
            print CL $_;
        }
        print CL "----------------------------------------------------------------------\n";
        close(CL);
        close(LOGFILE);
    }

    $cmd = sprintf("/bin/sh -c \"cvs $cvsroot commit %s -F $logfile $file_list\"", ($opt_t ? "-r $opt_t" : ""));
    $err = &talk_to_server("put", $cmd);
    unlink $logfile;
    return ($err);
}

# Update from the master repository
sub
update_from_master
{
    my $file_list = join(" ", @_);
    my ($tag, $err, $tries, $line, $cmd, $file, $mode);
    my (@conflicts, @not_found, @removed, @co, @up);

    if ($opt_reset) {
        $tag = "-A";
    } elsif ($opt_t) {
        $tag = "-r $opt_t";
    }
    dprint "File list is \"$file_list\", tag is \"$tag\"\n";

    # Figure out which files/modules exist and update those.  Checkout the rest.
    foreach $file (split(/\s+/, $file_list)) {
        if (-e $file) {
            dprint "Updating $file\n";
            push @up, $file;
        } else {
            dprint "Checking out $file\n";
            push @co, $file;
        }
    }
    if ($#up == -1 && $#co == -1) {
        @up = (" ");
    }

    foreach $mode (0, 1) {
        my ($flist, $subcmd);

        if ($mode) {
            next if ($#co < 0);
            $flist = join(" ", @co);
            $subcmd = "checkout $tag";
        } else {
            next if ($#up < 0);
            $flist = join(" ", @up);
            $subcmd = "update $tag -Pd";
        }
        $cmd = "/bin/sh -c \"cvs $cvsroot $subcmd $flist\"";
        # The weird OR on the next line makes sure we don't lose
        # a previous $err if the second try succeeds.
        $err = (&talk_to_server("get", $cmd) || $err);
    }
    return $err;
}

# Add new files
sub
add_new_files
{
    my @files = @_;
    my ($file_list, $cmd, $err, $tries, $line);

    if ($#files == -1) {
        if (-t STDIN) {
            print "You've asked me to add files, but you didn't tell me what files to add.\n";
            print "Please enter a whitespace-separated list of files or wildcards:\n";
            $file_list = <STDIN>;
            @files = glob($file_list);
        } else {
            return REVTOOL_BAD_ADDITION;
        }
    }
    $file_list = join(" ", @files);
    $cmd = sprintf("/bin/sh -c \"cvs $cvsroot add %s $file_list\"", ($opt_k ? "-k$opt_k" : ""));
    $err = &talk_to_server("add", $cmd);
    return ($err);
}

# Delete old files
sub
delete_old_files
{
    my @files = @_;
    my ($file_list, $cmd, $err, $tries, $line);

    if ($#files == -1) {
        if (-t STDIN) {
            print "You've asked me to remove files, but you didn't tell me what files to remove.\n";
            print "Please enter a whitespace-separated list of files or wildcards:\n";
            $file_list = <STDIN>;
            @files = glob($file_list);
        } else {
            return REVTOOL_BAD_REMOVAL;
        }
    }
    $file_list = join(" ", @files);
    $cmd = sprintf("/bin/sh -c \"cvs $cvsroot remove -f %s $file_list\"", ($opt_R ? "-R" : ""));
    $err = &talk_to_server("remove", $cmd);
    return ($err);
}

# List tags
sub
query_tags
{
    my @files = @_;
    my ($file_list, $cmd, $err, $tries, $line);
    my @tags;

    $file_list = join(" ", @files);
    $cmd = "/bin/sh -c \"cvs $cvsroot status -v $file_list\"";
    $err = &talk_to_server("query_tags", $cmd);
    return $err;
}

# Query file/directory status
sub
query_status
{
    my @files = @_;
    my ($file_list, $cmd, $err, $tries, $line);

    $file_list = join(" ", @files);
    $cmd = "/bin/sh -c \"cvs $cvsroot status -v $file_list\"";
    $err = &talk_to_server("query_status", $cmd);
    return $err;
}

sub
query_log
{
    my @files = @_;
    my ($file_list, $cmd, $err, $tries, $line);

    $file_list = join(" ", @files);
    $cmd = "/bin/sh -c \"cvs $cvsroot log $file_list\"";
    $err = &talk_to_server("query_log", $cmd);
    return $err;
}

sub
query_annotation
{
    my @files = @_;
    my ($file_list, $cmd, $err, $tries, $line, $rev);

    $file_list = join(" ", @files);
    $rev = "-r $tag -f" if ($tag);
    $cmd = "/bin/sh -c \"cvs $cvsroot annotate $rev $file_list\"";
    $err = &talk_to_server("query_annotation", $cmd);
    return $err;
}

sub
query_diff
{
    my @files = @_;
    my ($file_list, $cmd, $err, $rev1, $rev2, $tries, $line);

    $file_list = join(" ", @files);
    if ($tag && $tag =~ /\s/) {
        ($rev1, $rev2) = split(/\s+/, $tag);
    } elsif ($rtag && $rtag =~ /\s/) {
        ($rev1, $rev2) = split(/\s+/, $rtag);
    } elsif ($tag && $rtag) {
        $rev1 = $tag;
        $rev2 = $rtag;
    } elsif ($tag || $rtag) {
        eprint "Two tags (if any) are required to do a diff.\n";
        return REVTOOL_INVALID_TAG;
    }
    $rev1 = "-r $rev1" if ($rev1);
    $rev2 = "-r $rev2" if ($rev2);
    $cmd = "/bin/sh -c \"cvs $cvsroot diff -N -R -u $rev1 $rev2 $file_list\"";
    $err = &talk_to_server("query_diff", $cmd);
    return $err;
}

sub
query_release_diff
{
    my @files = @_;
    my ($file_list, $cmd, $err, $rev1, $rev2, $tries, $line);

    $file_list = join(" ", @files);
    if ($tag && $tag =~ /\s/) {
        ($rev1, $rev2) = split(/\s+/, $tag);
    } elsif ($rtag && $rtag =~ /\s/) {
        ($rev1, $rev2) = split(/\s+/, $rtag);
    } elsif ($tag && $rtag) {
        $rev1 = $tag;
        $rev2 = $rtag;
    } else {
        eprint "Two tags (if any) are required to do a diff.\n";
        return REVTOOL_INVALID_TAG;
    }
    $cmd = "/bin/sh -c \"cvs $cvsroot rdiff -R -u -r $rev1 -r $rev2 $file_list\"";
    $err = &talk_to_server("query_rdiff", $cmd);
    return $err;
}

# Tag the sources
sub
tag_local_sources
{
    my $file_list = join(" ", @_);
    my ($module, $mod_tag, $line, $tries, $err, $msg);
    local *CMD;

    if (-d "CVS") {
        chomp($module = &cat_file("CVS/Repository"));
    } elsif ($_[0] && -d "$_[0]/CVS") {
        $module = $_[0];
    } else {
        eprint "I don't see any CVS sources to tag here....\n";
        return REVTOOL_NO_SOURCES;
    }
    ($mod_tag = $module) =~ tr/[a-z]/[A-Z]/;

    if (! &check_tag($mod_tag, $tag)) {
        eprint "Tag \"$tag\" is not valid for module $module\n";
        return REVTOOL_INVALID_TAG;
    }

    $cmd = "/bin/sh -c \"cvs $cvsroot tag -F " . ($opt_b ? "-b " : "") . "$tag $file_list\"";
    $err = &talk_to_server("tag", $cmd);
    return $err;
}

# Tag the repository
sub
tag_repository_sources
{
    my $file_list = join(" ", @_);
    my ($module, $mod_tag, $line, $tries, $err, $msg);
    local *CMD;

    if (-d "CVS") {
        chomp($module = &cat_file("CVS/Repository"));
    } elsif ($_[0]) {
        $module = $_[0];
    } else {
        eprint "I don't see any CVS sources to tag here....\n";
        return REVTOOL_NO_SOURCES;
    }
    ($mod_tag = $module) =~ tr/[a-z]/[A-Z]/;

    if (! &check_tag($mod_tag, $rtag)) {
        eprint "Tag \"$rtag\" is not valid for module $module\n";
        return REVTOOL_INVALID_TAG;
    }

    $cmd = "/bin/sh -c \"cvs $cvsroot rtag -F " . ($opt_b ? "-b " : "") . "$rtag $file_list\"";
    $err = &talk_to_server("rtag", $cmd);
    return $err;
}

# Import a new set of vendor sources for a new module
sub
import_vendor_sources
{
    my ($module, $vendor_tag, $release_tag, $version, $cmd, $line, $tries, $err, $msg);
    my (@ignores, @links, @conflicts);
    local *CMD;

    if ($#_ == 0) {
        $module = $_[0];
    } else {
        chomp($module = `pwd`);
        $module =~ s/^.*\/([^\/]+)$/$1/;
    }
    ($vendor_tag = $module) =~ tr/[a-z]/[A-Z]/;
    $vendor_tag =~ s/[^-A-Z0-9]/-/g;
    if ($tag) {
        $release_tag = $tag;
    } elsif ($rtag) {
        $release_tag = $rtag;
    } elsif (-t STDIN) {
        print "Enter the release tag (in the form $vendor_tag-<version>):\n";
        $release_tag = <STDIN>;
    } else {
        eprint "No valid release tag was given.  I can't import without it.\n";
        return REVTOOL_INVALID_TAG;
    }
    dprint "Using module name $module, vendor tag $vendor_tag, release tag $release_tag\n";

    $opt_b = 0;  # Stupidity protection  :-)
    if (! &check_tag($vendor_tag, $release_tag)) {
        eprint "Release tag \"$tag\" is not valid for module $module\n";
        return REVTOOL_INVALID_TAG;
    }
    ($version = $release_tag) =~ s/^[^-]+-//;
    $version =~ tr/-/./;
    $version =~ tr/[A-Z]/[a-z]/;
    $msg = "Import of $module $version";

    $cmd = "/bin/sh -c \"cvs $cvsroot import"
            . ' -k' . ($opt_k || 'o')
            . ($opt_x ? ' -I!' : '')
            . " -m '$msg' $module $vendor_tag $release_tag\"";
    $err = &talk_to_server("import", $cmd);
    return $err;
}

# main() here is basically the same as main() in C
sub
main
{
    if ($login) {
        &login_to_master($login);
        return if ($mode eq "login");
    }
    if ($mode eq "import") {
        &import_vendor_sources(@ARGV);
    } elsif ($mode eq "query") {
        if ($query eq "t") {
            &query_tags(@ARGV);
        } elsif ($query eq "s") {
            &query_status(@ARGV);
        } elsif ($query eq "l") {
            &query_log(@ARGV);
        } elsif ($query eq "a") {
            &query_annotation(@ARGV);
        } elsif ($query eq "d") {
            &query_diff(@ARGV);
        } elsif ($query eq "D") {
            &query_release_diff(@ARGV);
        }
    } elsif ($mode eq "tag" || $mode eq "ptag") {
        &tag_local_sources(@ARGV);
    } elsif ($mode eq "rtag") {
        &tag_repository_sources(@ARGV);
    } else {
        if ($opt_addlist) {
            $addlist = $opt_addlist;
        } elsif ($opt_a) {
            $addlist = join(" ", @ARGV);
            @ARGV = ();
        } else {
            $addlist = 0;
        }
        if ($opt_remlist) {
            $remlist = $opt_remlist;
        } elsif ($opt_r && !$opt_a) {
            $remlist = join(" ", @ARGV);
            @ARGV = ();
        } else {
            $remlist = 0;
        }
        if ($addlist) {
            &add_new_files($addlist);
        }
        if ($remlist) {
            &delete_old_files($remlist);
        }
        if ($opt_g || $opt_reset) {
            $retval = &update_from_master(@ARGV);
        } elsif ($opt_p) {
            if (!($retval = &update_from_master($opt_x ? @ARGV : undef))) {
                if ($opt_x) {
                    &commit_to_master(@ARGV, ($addlist ? $addlist : undef), ($remlist ? $remlist : undef));
                } else {
                    &commit_to_master();
                }
            }
        }
    }
}

BEGIN {

    # Set up the basic variables
    $progname = "revtool";
    $version = "1.2";
    $argc = $#ARGV + 2;
    $retval = 0;
    $defproto = "cvs";

    # Synchronize output so it doesn't get all jumbled
    select STDERR; $| = 1;
    select STDOUT; $| = 1;

    # See the Getopt::Long man page for details on the syntax of this line
    @valid_opts = ("h|help", "v|version", "d|debug", "g|get", "p|put", "a|add", "r|remove",
                   "q|query=s", "R|recurse", "t|tag=s", "i|import", "k=s", "D|dir=s",
                   "x|exclusive", "addlist=s", "remlist=s", "T|rtag=s", "l|login", "b|branch",
                   "ptag", "reset", "P|protocol");

    Getopt::Long::Configure("no_getopt_compat", "bundling", "no_ignore_case");
    Getopt::Long::GetOptions(@valid_opts);
    $debug = $opt_d;
    $protocol = ($opt_P ? $opt_P : $defproto);
    if (!grep($protocol eq $_, ("cvs", "bk"))) {
        eprint "Invalid protocol \"$protocol\".  Using default protocol $defproto.\n";
        $protocol = $defproto;
    }
    if ($opt_i) {
        $mode = "import";
    } elsif ($opt_q) {
        $mode = "query";
        $query = $opt_q;
    } elsif ($opt_p) {
        $mode = "put";
    } elsif ($opt_g) {
        $mode = "get";
    } elsif ($opt_a) {
        $mode = "add";
    } elsif ($opt_r) {
        $mode = "remove";
    } elsif ($opt_ptag) {
        $mode = "ptag";
    } elsif ($opt_t) {
        $mode = "tag";
    } elsif ($opt_T || $opt_b) {
        $mode = "rtag";
    } elsif ($opt_reset) {
        $mode = "reset";
    } elsif ($opt_l) {
        $mode = "login";
    }
    $cvsroot = "-d $opt_D" if ($opt_D);
    $tag = $opt_t;
    $rtag = $opt_T;
    dprint "Debugging is on, mode is $mode, CVSROOT is $cvsroot, tag is $tag, rtag is $rtag\n";
    if ($opt_l) {
        if ($opt_D) {
            $login = $opt_D;
        } elsif (-f "CVS/Root") {
            chomp($login = &cat_file("CVS/Root"));
        } elsif ($ENV{CVSROOT}) {
            $login = $ENV{CVSROOT};
        }
    }
    if ($opt_v) {
        # Do not edit this variable.  It is updated automatically by CVS when you commit
        my $rcs_info = 'CVS Revision $Revision: 1.48 $ created on $Date: 2000/08/07 21:35:52 $ by $Author: mej $ ';

        $rcs_info =~ s/\$\s*Revision: (\S+) \$/$1/;
        $rcs_info =~ s/\$\s*Date: (\S+) (\S+) \$/$1 at $2/;
        $rcs_info =~ s/\$\s*Author: (\S+) \$ /$1/;
        print "\n";
	print "$progname $version by Michael Jennings <mej\@eterm.org>\n";
        print "Copyright (c) 2000, Michael Jennings and VA Linux Systems, Inc.\n";
        print "  ($rcs_info)\n";
        print "\n";
	exit(0);
    }
    if ($opt_h || $argc == 1) {
	&print_usage_info();   # Never returns
    }
}

&main();

END {

}

exit $retval;
